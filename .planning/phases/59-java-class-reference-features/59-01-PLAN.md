---
phase: 59-java-class-reference-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - java-interop/src/main/java/bbj/interop/InteropService.java
  - java-interop/src/main/java/bbj/interop/data/MethodInfo.java
  - java-interop/src/main/java/bbj/interop/data/FieldInfo.java
  - java-interop/src/main/java/bbj/interop/data/ClassInfo.java
  - bbj-vscode/src/language/java-types.langium
  - bbj-vscode/src/language/java-interop.ts
autonomous: true
requirements:
  - FEAT-02
  - FEAT-03
  - FEAT-04

must_haves:
  truths:
    - "Java backend returns isStatic and isDeprecated flags for every method and field"
    - "Java backend returns constructor signatures for every class"
    - "Langium JavaMethod/JavaField/JavaClass types include isStatic, deprecated, and constructors properties"
    - "java-interop.ts resolves and stores isStatic, deprecated, and constructor data during class resolution"
  artifacts:
    - path: "java-interop/src/main/java/bbj/interop/data/MethodInfo.java"
      provides: "isStatic and isDeprecated boolean fields"
      contains: "isStatic"
    - path: "java-interop/src/main/java/bbj/interop/data/FieldInfo.java"
      provides: "isStatic and isDeprecated boolean fields"
      contains: "isDeprecated"
    - path: "java-interop/src/main/java/bbj/interop/data/ClassInfo.java"
      provides: "isDeprecated boolean and constructors list"
      contains: "constructors"
    - path: "java-interop/src/main/java/bbj/interop/InteropService.java"
      provides: "Reflection extraction for isStatic, isDeprecated, and constructors"
      contains: "isDeprecated"
    - path: "bbj-vscode/src/language/java-types.langium"
      provides: "isStatic, deprecated, and constructors in Langium type model"
      contains: "isStatic"
    - path: "bbj-vscode/src/language/java-interop.ts"
      provides: "Resolution wiring for isStatic, deprecated, and constructors"
      contains: "isStatic"
  key_links:
    - from: "java-interop/src/main/java/bbj/interop/InteropService.java"
      to: "java-interop/src/main/java/bbj/interop/data/MethodInfo.java"
      via: "mi.isStatic = Modifier.isStatic(m.getModifiers())"
      pattern: "isStatic.*Modifier"
    - from: "bbj-vscode/src/language/java-interop.ts"
      to: "bbj-vscode/src/language/java-types.langium"
      via: "method.isStatic set from raw JSON data"
      pattern: "method\\.isStatic"
---

<objective>
Add isStatic, isDeprecated, and constructor data to the Java backend reflection service and Langium type model.

Purpose: Provides the data foundation that Plan 02 (static method completion, .class resolution) and Plan 03 (deprecated indicators, constructor completion) need. Without these fields being available on JavaMethod/JavaField/JavaClass, the completion provider cannot distinguish static from instance methods, cannot mark deprecated items, and cannot offer constructor signatures.

Output: Java backend returns enriched class metadata; Langium types carry isStatic, deprecated, and constructor arrays; java-interop.ts resolves and stores all new fields during class resolution.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/59-java-class-reference-features/59-CONTEXT.md
@bbj-vscode/src/language/java-types.langium
@bbj-vscode/src/language/java-interop.ts
@java-interop/src/main/java/bbj/interop/InteropService.java
@java-interop/src/main/java/bbj/interop/data/MethodInfo.java
@java-interop/src/main/java/bbj/interop/data/FieldInfo.java
@java-interop/src/main/java/bbj/interop/data/ClassInfo.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add isStatic, isDeprecated, and constructor extraction to Java backend</name>
  <files>
    java-interop/src/main/java/bbj/interop/data/MethodInfo.java
    java-interop/src/main/java/bbj/interop/data/FieldInfo.java
    java-interop/src/main/java/bbj/interop/data/ClassInfo.java
    java-interop/src/main/java/bbj/interop/InteropService.java
  </files>
  <action>
    1. In `MethodInfo.java`, add two public boolean fields:
       - `public boolean isStatic;`
       - `public boolean isDeprecated;`

    2. In `FieldInfo.java`, add two public boolean fields:
       - `public boolean isStatic;`
       - `public boolean isDeprecated;`

    3. In `ClassInfo.java`, add:
       - `public boolean isDeprecated;`
       - `public List<MethodInfo> constructors;` (import java.util.List if not already)

    4. In `InteropService.java` `loadClassInfo()` method:
       a. After extracting fields, set `fi.isStatic = Modifier.isStatic(f.getModifiers())` and `fi.isDeprecated = f.isAnnotationPresent(Deprecated.class)` for each field.
       b. After extracting methods, set `mi.isStatic = Modifier.isStatic(m.getModifiers())` and `mi.isDeprecated = m.isAnnotationPresent(Deprecated.class)` for each method.
       c. Set `classInfo.isDeprecated = clazz.isAnnotationPresent(Deprecated.class)` on the ClassInfo.
       d. Extract constructors: `clazz.getConstructors()` (public constructors only). For each constructor, create a `MethodInfo` with:
          - `name = clazz.getSimpleName()` (constructor name is the class simple name)
          - `returnType = className` (the FQN of the class)
          - `isStatic = false`
          - `isDeprecated = constructor.isAnnotationPresent(Deprecated.class)`
          - `parameters` mapped from `constructor.getParameters()` using same pattern as methods
          - `declaringClass = className`
       e. Store the constructor list in `classInfo.constructors`.

    Note: `Modifier` is already imported. `java.lang.reflect.Constructor` needs to be imported.
  </action>
  <verify>
    `cd java-interop && mvn compile` succeeds without errors.
  </verify>
  <done>
    MethodInfo has isStatic and isDeprecated fields. FieldInfo has isStatic and isDeprecated fields. ClassInfo has isDeprecated and constructors fields. InteropService populates all new fields via reflection. Java backend compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add isStatic, deprecated, and constructors to Langium type model and java-interop.ts resolution</name>
  <files>
    bbj-vscode/src/language/java-types.langium
    bbj-vscode/src/language/java-interop.ts
  </files>
  <action>
    1. In `java-types.langium`:
       a. Add to `JavaMethod` interface: `isStatic: boolean` and `deprecated: boolean`
       b. Add to `JavaField` interface: `isStatic: boolean` and `deprecated: boolean`
       c. Add to `JavaClass` interface: `deprecated: boolean` and `constructors: JavaMethod[]`

    2. In `java-interop.ts` `resolveClass()` method:
       a. After the existing field resolution loop (`for (const field of javaClass.fields)`), ensure `field.isStatic` and `field.deprecated` are preserved from the raw JSON (they come directly from the Java backend, so they should already be present in the deserialized object — but ensure types are set correctly).
       b. After the existing method resolution loop, similarly ensure `method.isStatic` and `method.deprecated` are preserved from the raw JSON.
       c. After the existing method loop, add constructor resolution: iterate over `javaClass.constructors ?? []`. For each constructor:
          - Set `$type = JavaMethod.$type` (constructors use the same type)
          - Resolve `resolvedReturnType` to the class itself (using `resolveClassByName(constructor.returnType, ...)`)
          - Resolve each parameter's `resolvedType`
          - Set `constructor.isStatic = false` and preserve `constructor.deprecated`
          - Call `AstUtils.linkContentToContainer(constructor)`
       d. Ensure `javaClass.constructors ??= []` early in the method (like `javaClass.classes ??= []`).
       e. Ensure `javaClass.deprecated` is preserved from the raw JSON (boolean field, should come through deserialization).

    3. Run `npm run langium:generate` in `bbj-vscode/` to regenerate TypeScript types from the updated Langium grammar.

    Note: The raw JSON from the Java backend will include `isStatic`, `isDeprecated` (Java naming), and `constructors` fields. The Langium grammar uses `deprecated` (not `isDeprecated`) and `isStatic`. The deserialized JSON will have `isDeprecated` from Java but the Langium type expects `deprecated`. So in java-interop.ts, explicitly map: `(field as any).deprecated = (field as any).isDeprecated ?? false` and `(method as any).deprecated = (method as any).isDeprecated ?? false`. Same for constructors. This mapping is needed because Java DTO uses `isDeprecated` but Langium type uses `deprecated`.
  </action>
  <verify>
    Run `cd bbj-vscode && npm run langium:generate && npm run build` — both succeed. Verify generated `ast.ts` contains `isStatic`, `deprecated`, and `constructors` properties on the expected interfaces.
  </verify>
  <done>
    Langium grammar defines isStatic and deprecated on JavaMethod/JavaField, deprecated and constructors on JavaClass. Generated TypeScript types include all new fields. java-interop.ts resolves and maps all new fields during class resolution, including constructor parameter type resolution. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `cd java-interop && mvn compile` passes
2. `cd bbj-vscode && npm run langium:generate && npm run build` passes
3. `cd bbj-vscode && npm test` passes (existing tests unbroken)
4. Generated `ast.ts` contains `isStatic: boolean` on JavaMethod and JavaField interfaces
5. Generated `ast.ts` contains `deprecated: boolean` on JavaMethod, JavaField, and JavaClass interfaces
6. Generated `ast.ts` contains `constructors: JavaMethod[]` on JavaClass interface
</verification>

<success_criteria>
- Java backend extracts and returns isStatic, isDeprecated for methods and fields, isDeprecated for classes, and constructor signatures
- Langium type model includes all new fields in its grammar and generated TypeScript
- java-interop.ts resolves constructor parameter types and maps isDeprecated to deprecated
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/59-java-class-reference-features/59-01-SUMMARY.md`
</output>
