---
phase: 59-java-class-reference-features
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/java-interop.ts
  - bbj-vscode/src/language/bbj-scope.ts
  - bbj-vscode/src/language/bbj-completion-provider.ts
autonomous: false
requirements: [FEAT-02, FEAT-03, FEAT-04]
gap_closure: true

must_haves:
  truths:
    - "After `USE java.lang.String`, typing `String.` offers static methods (valueOf, format, join) — not just `.class`"
    - "After `java.lang.String.`, completion offers only static methods (not instance methods like charAt)"
    - "Typing `(` after `new ClassName` auto-triggers completion instead of requiring Ctrl+Space"
    - "When constructor completion fails silently, the user gets an empty list instantly — not a slow fallthrough to default completion"
  artifacts:
    - path: "bbj-vscode/src/language/java-interop.ts"
      provides: "isStatic and other method properties set BEFORE class is registered in resolvedClasses"
      contains: "resolvedClasses.set"
    - path: "bbj-vscode/src/language/bbj-scope.ts"
      provides: "isClassRef detection for both SymbolRef and MemberCall receivers"
      contains: "isMemberCall"
    - path: "bbj-vscode/src/language/bbj-completion-provider.ts"
      provides: "( trigger character and empty CompletionList fallback"
      contains: "triggerCharacters.*("
  key_links:
    - from: "bbj-vscode/src/language/java-interop.ts"
      to: "resolvedClasses map"
      via: "method property loop completes before resolvedClasses.set()"
      pattern: "method\\.isStatic.*resolvedClasses\\.set"
    - from: "bbj-vscode/src/language/bbj-scope.ts"
      to: "static method filter"
      via: "isClassRef detection on MemberCall receivers resolving to JavaClass"
      pattern: "isMemberCall.*isClassRef"
---

<objective>
Fix the isStatic race condition preventing static method completion on USE class references, extend isClassRef detection to MemberCall receivers (FQN paths), add '(' as a completion trigger character, and prevent slow fallthrough when constructor completion returns undefined.

Purpose: Close 4 UAT gaps — static methods on USE refs (Tests 4+5), constructor trigger (Test 8), and FQN showing instance methods.
Output: Three modified LS source files with race condition fix, MemberCall class-ref detection, and completion provider hardening.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/59-java-class-reference-features/59-UAT.md
@.planning/phases/59-java-class-reference-features/59-01-SUMMARY.md
@.planning/phases/59-java-class-reference-features/59-02-SUMMARY.md
@.planning/phases/59-java-class-reference-features/59-03-SUMMARY.md
@.planning/debug/use-import-static-completion.md
@.planning/debug/constructor-completion.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix isStatic race condition and extend isClassRef to MemberCall receivers</name>
  <files>
    bbj-vscode/src/language/java-interop.ts
    bbj-vscode/src/language/bbj-scope.ts
    bbj-vscode/src/language/bbj-completion-provider.ts
  </files>
  <action>
**File 1: java-interop.ts — Fix the isStatic race condition**

The root cause: `resolvedClasses.set(className, javaClass)` at line 385 registers the class BEFORE the method property loop (lines 399-403) sets `method.isStatic`, `method.deprecated`, `field.isStatic`, `field.deprecated`. Any concurrent access to `getResolvedClass()` between these two points gets methods with `isStatic=undefined` (defaulting to `false`).

Fix: Move `this.resolvedClasses.set(className, javaClass)` (currently at line 385) to AFTER the entire method/field/constructor processing loop completes (after all method.isStatic, method.deprecated, field.isStatic, field.deprecated, constructors have been populated). The line should go after the try-catch block that processes fields, methods, and constructors (around line 440+, after the constructor processing loop ends).

Keep the error-path `resolvedClasses.set()` in the catch block at the end of resolveClass() so failed resolutions still register (preventing infinite recursion). The key change is: for the HAPPY PATH, registration happens after all properties are populated.

Important: The `this.storeJavaClass()` call at line 380 must also move with it or stay where it is — check what storeJavaClass does. If it adds the class to the AST tree (container assignment), it should stay early. Only `resolvedClasses.set()` needs to move.

**File 2: bbj-scope.ts — Extend isClassRef detection to MemberCall receivers**

Currently (lines 162-169), `isClassRef` is only set to `true` when the receiver is a `SymbolRef` that resolves to a `JavaClass`. This misses FQN paths like `java.lang.String.` where the receiver is a `MemberCall` chain.

Add an `else if (isMemberCall(receiver))` block after the existing `isSymbolRef` check:

```typescript
let isClassRef = false;
if (isSymbolRef(receiver)) {
    try {
        const ref = receiver.symbol.ref;
        isClassRef = isJavaClass(ref);
    } catch {
        // cyclic reference, ignore
    }
} else if (isMemberCall(receiver)) {
    // FQN path: java.lang.String. — receiver is a MemberCall chain
    // Check if the resolved member is a JavaClass
    try {
        const ref = receiver.member.ref;
        isClassRef = isJavaClass(ref);
    } catch {
        // cyclic reference, ignore
    }
}
```

This ensures `java.lang.String.` triggers the static-only completion branch at line 176-183, matching the behavior of `String.` (via USE import).

**File 3: bbj-completion-provider.ts — Add '(' trigger and prevent slow fallthrough**

(a) Add `'('` to triggerCharacters at line 14:
```typescript
override readonly completionOptions = {
    triggerCharacters: ['#', '(']
};
```

(b) In `getCompletion()` (lines 21-31), when the trigger character is `'('`, call `getConstructorCompletion()` and if it returns undefined, return an empty CompletionList instead of falling through to `super.getCompletion()`:

```typescript
override async getCompletion(document: LangiumDocument, params: CompletionParams, cancelToken?: CancellationToken): Promise<CompletionList | undefined> {
    if (params.context?.triggerCharacter === '#') {
        return this.getFieldCompletion(document, params);
    }
    if (params.context?.triggerCharacter === '(') {
        return this.getConstructorCompletion(document, params) ?? { items: [], isIncomplete: false };
    }
    // Non-trigger completion (Ctrl+Space) — try constructor first, then default
    const constructorCompletion = this.getConstructorCompletion(document, params);
    if (constructorCompletion) {
        return constructorCompletion;
    }
    return super.getCompletion(document, params, cancelToken);
}
```

Key difference: When trigger is `'('`, always return a result (constructor items or empty list) — NEVER fall through to the slow default provider. When trigger is NOT `'('` (e.g., Ctrl+Space), keep existing behavior of trying constructor then falling through.
  </action>
  <verify>
1. `npm run build` — TypeScript compiles cleanly, no errors
2. `npm test` — all 511 tests pass, no regressions
3. Grep java-interop.ts to confirm `resolvedClasses.set` appears AFTER the method property loop (not before)
4. Grep bbj-scope.ts to confirm `isMemberCall(receiver)` appears in the isClassRef detection block
5. Grep bbj-completion-provider.ts to confirm `triggerCharacters` includes `'('` and the `'('` trigger returns empty list on failure
  </verify>
  <done>
- resolvedClasses.set() is called after all method/field/constructor properties are populated (race condition eliminated)
- isClassRef is true for both SymbolRef and MemberCall receivers that resolve to JavaClass
- '(' is a registered trigger character for completion
- When trigger is '(' and constructor completion fails, an empty CompletionList is returned (no slow fallthrough)
  </done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 2: Deploy updated java-interop JAR to BBj runtime</name>
  <files>
    java-interop/src/main/java/bbj/interop/data/MethodInfo.java
    java-interop/src/main/java/bbj/interop/data/FieldInfo.java
    java-interop/src/main/java/bbj/interop/data/ClassInfo.java
    java-interop/src/main/java/bbj/interop/InteropService.java
  </files>
  <action>
The Language Server code for deprecated strikethrough (FEAT-03) and constructor data (FEAT-04) is already correct — implemented in plans 59-01 through 59-03. The TypeScript side maps `isDeprecated`, `isStatic`, and `constructors` from the Java backend JSON. However, BBj's bundled Java interop JAR predates commit a02e009 and does NOT send these fields. The `?? false` fallback means deprecated is always false and constructors is always empty when running against the BBj-bundled interop.

Task 1 above fixes the LS-side race condition so that when the data DOES arrive, it works correctly. But the data itself must come from an updated JAR.

Human action required — build and deploy the java-interop module:
1. Build the java-interop module from this repo's source
2. Deploy the resulting JAR into BBj's runtime classpath (replacing the bundled version)
3. Restart BBj and the language server
  </action>
  <verify>
1. Type `.` on a `java.util.Date` instance — `getHours()` should show with strikethrough
2. Type `new java.util.HashMap(` — constructor signatures should appear
3. After `USE java.lang.String`, type `String.` — static methods with correct isStatic=true should appear
  </verify>
  <done>
- Deprecated methods (e.g., Date.getHours()) display strikethrough in completion list
- Constructor signatures appear after `new ClassName(`
- isStatic, isDeprecated, and constructors fields arrive from the Java backend
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes — no TypeScript errors
2. `npm test` passes — all existing tests pass (511+)
3. Static method completion: After USE import, class reference shows static methods (not just .class)
4. FQN path: `java.lang.String.` shows static methods only (not instance methods like charAt)
5. Constructor trigger: `(` auto-triggers completion requests
6. Constructor fallback: Failed constructor completion returns empty list instantly (not slow default)
7. No regressions in existing .class resolution or field completion (#) features
</verification>

<success_criteria>
- UAT Test 4 (static methods on USE refs) root cause fixed — race condition eliminated, static methods populate before class is accessible
- UAT Test 5 (inherited statics) follows from Test 4 fix — getMethods() already includes superclass methods
- UAT Test 8 (constructor completion) LS-side issues fixed — trigger character added, fallthrough prevented
- FQN paths now correctly filter to static-only completion (isClassRef detection extended)
- UAT Tests 6 (deprecated) and 8 (constructor data) deployment dependency documented as human action
</success_criteria>

<output>
After completion, create `.planning/phases/59-java-class-reference-features/59-04-SUMMARY.md`
</output>
