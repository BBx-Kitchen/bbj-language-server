---
phase: 59-java-class-reference-features
plan: 02
type: execute
wave: 2
depends_on:
  - 59-01
files_modified:
  - bbj-vscode/src/language/bbj-scope.ts
  - bbj-vscode/src/language/bbj-type-inferer.ts
  - bbj-vscode/test/completion-test.test.ts
autonomous: true
requirements:
  - FEAT-01
  - FEAT-02

must_haves:
  truths:
    - "Writing `.class` after a Java object reference resolves to java.lang.Class without an unresolvable warning"
    - "Chained access like `a!.class.getName()` completes Class methods and resolves correctly"
    - "Typing `.` on a USE class reference offers static methods of that class in the completion list"
    - "Inherited static methods from superclasses appear in static method completion"
    - "Static methods only appear (no static fields/constants) per user decision"
    - "Overloaded static methods appear as separate completion items"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-scope.ts"
      provides: ".class member scope and static-only method filtering for class references"
      contains: "class"
    - path: "bbj-vscode/src/language/bbj-type-inferer.ts"
      provides: ".class type resolution returning java.lang.Class"
      contains: "java.lang.Class"
    - path: "bbj-vscode/test/completion-test.test.ts"
      provides: "Tests for .class and static method completion"
      contains: "class"
  key_links:
    - from: "bbj-vscode/src/language/bbj-scope.ts"
      to: "bbj-vscode/src/language/bbj-type-inferer.ts"
      via: "typeInferer.getType(receiver) drives scope selection for member calls"
      pattern: "typeInferer\\.getType"
    - from: "bbj-vscode/src/language/bbj-scope.ts"
      to: "bbj-vscode/src/language/java-interop.ts"
      via: "javaInterop.getResolvedClass('java.lang.Class') for .class scope"
      pattern: "getResolvedClass.*Class"
    - from: "bbj-vscode/src/language/bbj-type-inferer.ts"
      to: "bbj-vscode/src/language/java-interop.ts"
      via: "javaInterop.getResolvedClass('java.lang.Class') for .class type"
      pattern: "getResolvedClass.*java\\.lang\\.Class"
---

<objective>
Implement .class property resolution and static method completion on Java class references.

Purpose: FEAT-01 enables `.class` to resolve to java.lang.Class so users can chain Class methods (e.g., `a!.class.getName()`). FEAT-02 enables static method completion when typing `.` on a USE class reference variable, so users see only static methods of the referenced class.

Output: .class resolves to java.lang.Class in scope and type inferer; USE class references offer static-only method completion; tests cover both features.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/59-java-class-reference-features/59-CONTEXT.md
@.planning/phases/59-java-class-reference-features/59-01-SUMMARY.md
@bbj-vscode/src/language/bbj-scope.ts
@bbj-vscode/src/language/bbj-type-inferer.ts
@bbj-vscode/src/language/bbj-completion-provider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement .class resolution in scope and type inferer</name>
  <files>
    bbj-vscode/src/language/bbj-scope.ts
    bbj-vscode/src/language/bbj-type-inferer.ts
  </files>
  <action>
    **In `bbj-scope.ts`:**

    In the `getScope()` method, find the MemberCall branch (line ~154: `if (context.property === 'member' && isMemberCall(context.container))`). Currently when `isJavaClass(receiverType)`, it returns scope from `stream(receiverType.fields).concat(receiverType.methods)`.

    Modify the `isJavaClass(receiverType)` branch to ALSO include a synthetic `.class` descriptor in the scope. Create a synthetic `AstNodeDescription` for `class` that points to java.lang.Class:
    ```
    const javaLangClass = this.javaInterop.getResolvedClass('java.lang.Class');
    const classDesc = javaLangClass
        ? this.descriptions.createDescription(javaLangClass, 'class')
        : undefined;
    const members = stream(receiverType.fields).concat(receiverType.methods);
    if (classDesc) {
        return this.createScopeForNodes(members.concat([classDesc]));
    }
    return this.createScopeForNodes(members);
    ```

    Also add `.class` to the `isBbjClass(receiverType)` branch's outer scope — BBj class instances should also support `.class`. In the `isBbjClass(receiverType)` branch, wrap the existing return in an outer scope that includes the `.class` descriptor, or add `.class` to the stream:
    ```
    const javaLangClass = this.javaInterop.getResolvedClass('java.lang.Class');
    const classDesc = javaLangClass
        ? this.descriptions.createDescription(javaLangClass, 'class')
        : undefined;
    const bbjScope = this.createBBjClassMemberScope(receiverType);
    const outerScope = super.getScope(context);
    const bbjMemberScope = new StreamScopeWithPredicate(bbjScope.getAllElements(), outerScope);
    if (classDesc) {
        return new StreamScopeWithPredicate(stream([classDesc]), bbjMemberScope);
    }
    return bbjMemberScope;
    ```

    **In `bbj-type-inferer.ts`:**

    In the `getTypeInternal()` method, find the `isMemberCall(expression)` branch. After resolving `member = expression.member.ref`, add a check BEFORE the existing member resolution: if the member reference text is `class`, return `java.lang.Class` directly:
    ```
    if (isMemberCall(expression)) {
        // Check for .class property — resolves to java.lang.Class
        const memberRefText = expression.member.$refText;
        if (memberRefText === 'class') {
            return this.javaInterop.getResolvedClass('java.lang.Class');
        }
        // ... existing member resolution
    }
    ```

    This ensures that `a!.class` resolves to java.lang.Class, and then `a!.class.getName()` will chain correctly because the type inferer returns java.lang.Class for the `.class` member call, and the next `.getName()` member call resolves against java.lang.Class's methods.
  </action>
  <verify>
    `cd bbj-vscode && npm run build` succeeds. `cd bbj-vscode && npm test` passes.
  </verify>
  <done>
    `.class` appears in MemberCall scope for both JavaClass and BbjClass receivers. Type inferer returns java.lang.Class for `.class` member access. Chained access like `a!.class.getName()` resolves correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement static method completion for USE class references</name>
  <files>
    bbj-vscode/src/language/bbj-scope.ts
    bbj-vscode/test/completion-test.test.ts
  </files>
  <action>
    **Static method completion in `bbj-scope.ts`:**

    The key insight: when a user writes `USE java.lang.String` and then types `String.`, the receiver in the MemberCall is a SymbolRef pointing to the JavaClass `String`. The type inferer's `isSymbolRef` branch returns the JavaClass directly when `isClass(reference)`. So the MemberCall scope's `isJavaClass(receiverType)` branch fires.

    The problem: currently it shows ALL methods and fields. For a class reference (not an instance), only static methods should be shown.

    To detect whether the receiver is a class reference (not an instance), check if the receiver is a SymbolRef whose resolved reference is a JavaClass (direct class reference, not an instance variable). In the MemberCall scope branch:

    1. Before the `isJavaClass(receiverType)` check, detect whether this is a class-reference access:
       ```
       // Detect class-reference access: receiver is a SymbolRef directly referencing a JavaClass
       // (e.g., `String.` after `USE java.lang.String`) — show only static methods
       let isClassRef = false;
       if (isSymbolRef(receiver)) {
           try {
               const ref = receiver.symbol.ref;
               isClassRef = isJavaClass(ref);
           } catch {
               // cyclic reference, ignore
           }
       }
       ```

    2. Modify the `isJavaClass(receiverType)` branch to filter based on `isClassRef`:
       ```
       if (isJavaClass(receiverType)) {
           if (isClassRef) {
               // Class reference access — static methods only (no fields per user decision)
               const staticMethods = receiverType.methods.filter(m => m.isStatic);
               // Also include .class
               const javaLangClass = this.javaInterop.getResolvedClass('java.lang.Class');
               const classDesc = javaLangClass
                   ? this.descriptions.createDescription(javaLangClass, 'class')
                   : undefined;
               const scope = this.createScopeForNodes(stream(staticMethods));
               if (classDesc) {
                   return new StreamScopeWithPredicate(stream([classDesc]), scope);
               }
               return scope;
           }
           // Instance access — all methods and fields plus .class
           // (existing code with .class addition from Task 1)
       }
       ```

    3. Import `isSymbolRef` if not already imported in bbj-scope.ts (it IS already imported — verify).

    **Tests in `completion-test.test.ts`:**

    These tests run with EmptyFileSystem so Java interop is not available. The tests should validate the SCOPE MECHANISM, not full Java interop. Since Java classes are not loaded in EmptyFileSystem tests, we can only test that the completion infrastructure doesn't crash. Add a comment explaining that full end-to-end testing requires Java interop which is integration-tested manually.

    However, we CAN add a test verifying that `.class` appears for BBj class instances (since BBj classes are parsed from source in tests):

    ```typescript
    test('class member access on BBj class instance offers .class', async () => {
        // Note: .class completion requires java.lang.Class to be resolved via Java interop.
        // In EmptyFileSystem, Java classes are not available, so .class won't appear.
        // This test validates the mechanism doesn't crash on member access.
        const text = `
    class public MyClass
        method public void doWork()
        methodend
    classend
    declare MyClass foo!
    foo!.<|>
        `
        await completion({
            text,
            index: 0,
            assert: (completions) => {
                const items = completions.items;
                // In EmptyFileSystem, we expect at least the BBj method to appear
                const methodItems = items.filter(i => i.label.startsWith('doWork'));
                expect(methodItems.length).toBeGreaterThanOrEqual(1);
            }
        });
    });
    ```
  </action>
  <verify>
    `cd bbj-vscode && npm run build && npm test` — all pass including new test.
  </verify>
  <done>
    USE class references (e.g., `String.` after `USE java.lang.String`) show only static methods in the completion list. Instance variables show all methods, fields, and `.class`. `.class` is available in the scope for both JavaClass and BbjClass receivers. Tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cd bbj-vscode && npm run build` passes
2. `cd bbj-vscode && npm test` passes (all existing + new tests)
3. `.class` appears in member call scope for JavaClass receivers
4. `.class` appears in member call scope for BbjClass receivers
5. Type inferer returns java.lang.Class for `.class` member access
6. Class references show only static methods (not instance methods or fields)
7. Instance variables show all methods, fields, and `.class`
</verification>

<success_criteria>
- FEAT-01: `.class` resolves to java.lang.Class on any Java object reference, chained access works
- FEAT-02: Static method completion on USE class references shows only static methods (no fields)
- Overloaded static methods appear as separate completion items (handled by existing FunctionNodeDescription mechanism)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/59-java-class-reference-features/59-02-SUMMARY.md`
</output>
