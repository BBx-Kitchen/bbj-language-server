---
phase: 25-type-resolution-crash-fixes
plan: 03
type: execute
wave: 3
depends_on: ["01", "02"]
files_modified:
  - bbj-vscode/src/language/bbj-scope-local.ts
  - bbj-vscode/src/language/java-interop.ts
  - bbj-vscode/src/language/bbj-validator.ts
  - bbj-vscode/test/linking.test.ts
  - bbj-vscode/test/parser.test.ts
autonomous: true

must_haves:
  truths:
    - "A DECLARE statement placed anywhere in a method body is recognized for type resolution"
    - "DECLARE type is authoritative -- it applies to entire method scope regardless of position"
    - "A USE statement referencing a Java inner class does not crash the language server"
    - "Each USE statement is independent -- one failure does not block others from processing"
    - "Warning diagnostic appears on USE lines that cannot be resolved"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-scope-local.ts"
      provides: "DECLARE method-scoped variable registration and crash-safe USE processing"
      contains: "isVariableDecl"
    - path: "bbj-vscode/src/language/java-interop.ts"
      provides: "Inner class dollar-sign handling in extractPackageName"
      contains: "\\$"
    - path: "bbj-vscode/src/language/bbj-validator.ts"
      provides: "Warning diagnostic for unresolvable USE statements"
      contains: "could not be resolved"
    - path: "bbj-vscode/test/linking.test.ts"
      provides: "Tests for DECLARE scope and USE crash resistance"
      contains: "DECLARE"
  key_links:
    - from: "bbj-vscode/src/language/bbj-scope-local.ts"
      to: "processNode"
      via: "isVariableDecl check adding to method scope"
      pattern: "isVariableDecl.*addToScope"
    - from: "bbj-vscode/src/language/java-interop.ts"
      to: "extractPackageName"
      via: "dollar sign handling for inner classes"
      pattern: "\\$.*className"
    - from: "bbj-vscode/src/language/bbj-validator.ts"
      to: "checkUsedClassExists"
      via: "warning diagnostic for unresolvable USE"
      pattern: "warning.*USE|could not be resolved"
---

<objective>
Fix DECLARE scope to cover entire method body regardless of position, fix USE statement crash on Java inner classes, and add warning diagnostic for unresolvable USE statements.

Purpose: DECLARE statements currently go through the generic `else` branch in `processNode` which adds them to their immediate container scope (e.g., the CompoundStatement or statement list they appear in). This means a DECLARE after some code is not visible to earlier references. Per user decision, DECLARE should apply to the entire method scope. Additionally, USE statements referencing Java inner classes (e.g., `use org.jsoup.nodes.Element` where Element is an inner class) crash the server because `extractPackageName` incorrectly parses the package/class boundary. Per user decision, unresolvable USE lines should show a warning diagnostic (not just console.warn).

Output: Updated `bbj-scope-local.ts` with method-scoped DECLARE handling and crash-safe USE processing, updated `java-interop.ts` with inner class support, updated `bbj-validator.ts` with USE warning diagnostic, plus tests.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-type-resolution-crash-fixes/25-CONTEXT.md
@.planning/phases/25-type-resolution-crash-fixes/25-RESEARCH.md
@.planning/phases/25-type-resolution-crash-fixes/25-01-SUMMARY.md
@.planning/phases/25-type-resolution-crash-fixes/25-02-SUMMARY.md
@bbj-vscode/src/language/bbj-scope-local.ts
@bbj-vscode/src/language/java-interop.ts
@bbj-vscode/src/language/bbj-scope.ts
@bbj-vscode/src/language/bbj-module.ts
@bbj-vscode/src/language/bbj-validator.ts
@bbj-vscode/src/language/bbj-nodedescription-provider.ts
@bbj-vscode/src/language/generated/ast.ts
@bbj-vscode/src/language/bbj.langium
@bbj-vscode/test/linking.test.ts
@bbj-vscode/test/parser.test.ts
@bbj-vscode/test/bbj-test-module.ts
@bbj-vscode/test/test-helper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix DECLARE scope, harden USE processing, and add USE warning diagnostic</name>
  <files>bbj-vscode/src/language/bbj-scope-local.ts, bbj-vscode/src/language/java-interop.ts, bbj-vscode/src/language/bbj-validator.ts</files>
  <action>
**DECLARE scope fix (TYPE-04):**

In `processNode` in `BbjScopeComputation`, add a new branch BEFORE the generic `else` block to handle `VariableDecl` nodes (DECLARE statements). Currently VariableDecl falls through to the `else` branch which adds it to `node.$container` -- typically the statement list or CompoundStatement it appears in. Per user decision, DECLARE should be method-scoped (visible everywhere in the containing method).

Add this logic:

```typescript
import { isVariableDecl, isMethodDecl, MethodDecl, VariableDecl } from './generated/ast.js';
// ... (add isVariableDecl to existing imports)
```

In processNode, add a new branch:

```typescript
} else if (isVariableDecl(node) && node.$containerProperty !== 'params') {
    // DECLARE statements should be scoped to the entire method body
    // not just the block they appear in
    const methodScope = AstUtils.getContainerOfType(node, isMethodDecl);
    const scopeHolder = methodScope ?? node.$container;
    if (scopeHolder) {
        const description = this.descriptions.createDescription(node, node.name);
        this.addToScope(scopes, scopeHolder, description);
    }
}
```

Place this BEFORE the existing generic `else` block. The check `$containerProperty !== 'params'` ensures method parameter declarations (which also return VariableDecl from the grammar) don't get double-added -- params are already handled by Langium's default scope computation.

When VariableDecl is inside a method, add it to the MethodDecl scope (the method itself). When it's at the top level (no containing method), add it to its direct container as before.

**USE crash fix (STAB-01):**

Two fixes needed:

1. **In `processNode` for USE statements: add inner class dollar-sign fallback and try/catch wrapping:**

```typescript
if (isUse(node) && node.javaClass) {
    try {
        const javaClassName = getFQNFullname(node.javaClass);
        let javaClass = await this.tryResolveJavaReference(javaClassName, this.javaInterop);

        // If resolution failed, try inner class notation (replace last . with $)
        if (!javaClass && javaClassName.includes('.')) {
            const lastDot = javaClassName.lastIndexOf('.');
            const innerClassName = javaClassName.substring(0, lastDot) + '$' + javaClassName.substring(lastDot + 1);
            javaClass = await this.tryResolveJavaReference(innerClassName, this.javaInterop);
        }

        if (!javaClass) {
            return;
        }
        if (javaClass.error) {
            console.warn(`Java '${javaClassName}' class resolution error: ${javaClass.error}`)
            return;
        }
        const program = node.$container;
        const simpleName = javaClassName.substring(javaClassName.lastIndexOf('.') + 1);
        this.addToScope(scopes, program, this.descriptions.createDescription(javaClass, simpleName))
    } catch (e) {
        console.warn(`Error processing USE statement for ${getFQNFullname(node.javaClass)}: ${e}`);
        return;
    }
}
```

This ensures per user decision: "Each USE statement is independent -- one failure doesn't block others from processing."

2. **In `java-interop.ts`, fix `extractPackageName`** for completeness: when a className contains `$` (e.g., `java.util.Map$Entry`), the package name should still be `java.util`. The current regex `/\.(?=[A-Z])/` would correctly handle `$` notation. The fix is primarily in the processNode USE branch (trying `$` notation on failure).

**USE warning diagnostic (replaces console.warn with proper diagnostic):**

Per user decision: "Warning diagnostic on the specific USE line that couldn't be resolved."

The existing `checkUsedClassExists` in `bbj-validator.ts` already checks `use.javaClass.pathParts.some(pp => pp.symbol.ref === undefined)` and emits an `'error'` severity diagnostic. Per user decision, unresolvable USE statements should show `'warning'` severity instead of `'error'`, because this is a type resolution warning (not a hard error).

Update `checkUsedClassExists` to change the severity:

```typescript
checkUsedClassExists(use: Use, accept: ValidationAcceptor): void {
    if (use.javaClass) {
        const className = getFQNFullname(use.javaClass);
        if(use.javaClass.pathParts.some(pp => pp.symbol.ref === undefined)) {
            accept('warning', `Class '${className}' could not be resolved. Check your classpath configuration.`, { node: use });
        }
        const errorPart = use.javaClass.pathParts.find(pp => pp.symbol.error !== undefined)
        if (errorPart) {
            accept('warning', `Error when loading ${className}: ${errorPart.symbol.error}`, { node: use, property: 'javaClass' });
        }
    }
}
```

Note: Changed from `'error'` to `'warning'` severity, and improved the message to include an actionable suggestion ("Check your classpath configuration"). The diagnostic appears on the USE node itself (the whole statement), per user decision.
  </action>
  <verify>Run `npm test` from `bbj-vscode/` -- all existing tests pass.</verify>
  <done>DECLARE statements are scoped to the entire method body (MethodDecl scope). USE statements with inner class references attempt `$` notation fallback and are wrapped in try/catch to prevent crashes. Unresolvable USE lines emit warning diagnostics (not just console.warn).</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for DECLARE scope and USE crash resistance</name>
  <files>bbj-vscode/test/linking.test.ts, bbj-vscode/test/parser.test.ts</files>
  <action>
Add tests to `linking.test.ts` for DECLARE scope behavior and USE crash resistance.

**DECLARE tests:**

```typescript
test('DECLARE anywhere in method body is recognized for type resolution', async () => {
    const document = await validate(`
        class public MyClass
            method public void test()
                x$ = myVar!.charAt(1)
                declare BBjString myVar!
            methodend
        classend
    `)
    expectNoErrors(document)
})
```

This test has `declare` AFTER usage of `myVar!`. Per user decision, DECLARE applies to entire method scope regardless of position. The `.charAt(1)` call should resolve because `myVar!` is declared as `BBjString`.

Note: This test depends on the type inferer correctly handling VariableDecl (which it already does -- line 24 of bbj-type-inferer.ts handles `isVariableDecl`). The key is that the DECLARE is visible in scope despite appearing after usage.

```typescript
test('DECLARE at top level scope works', async () => {
    const document = await validate(`
        declare BBjString name!
        x = name!.charAt(1)
    `)
    expectNoErrors(document)
})
```

**USE crash resistance tests:**

```typescript
test('USE with unresolvable class does not crash document processing', async () => {
    const document = await validate(`
        use com.nonexistent.FakeClass
        x$ = "hello"
    `)
    // Should parse fine, may have linking/warning for the USE, but should not crash
    expect(document.parseResult.parserErrors.length).toBe(0)
    // The x$ assignment should still work despite the bad USE
})
```

Also add a test to `parser.test.ts`:

```typescript
test('DECLARE statement parses correctly anywhere in method', async () => {
    const document = await parse(`
        class public Test
            method public void m()
                x = 1
                declare BBjString name!
                y = 2
            methodend
        classend
    `)
    expect(document.parseResult.parserErrors.length).toBe(0)
})
```
  </action>
  <verify>Run `npm test` from `bbj-vscode/` -- all new and existing tests pass.</verify>
  <done>DECLARE anywhere in method body is visible to the entire method scope (tested with usage-before-declaration pattern). USE processing is wrapped in try/catch for crash resilience. At least 2 new tests verify DECLARE scope behavior.</done>
</task>

</tasks>

<verification>
1. `cd bbj-vscode && npm test` -- all tests pass (0 failures)
2. New tests cover: DECLARE after usage resolves correctly, DECLARE at top level works, USE crash resilience
3. `processNode` has explicit `isVariableDecl` handling that scopes to MethodDecl
4. USE processing has try/catch wrapping and inner class `$` notation fallback
5. `checkUsedClassExists` emits 'warning' severity (not 'error') for unresolvable USE statements
</verification>

<success_criteria>
- DECLARE placed after usage in a method body is still recognized for type resolution
- DECLARE type is authoritative for the entire method scope
- USE statements with inner classes do not crash the server
- One failing USE does not block other USE statements from processing
- Unresolvable USE lines show warning diagnostic (yellow squiggly)
- All existing tests pass (no regressions)
- TYPE-04 and STAB-01 requirements are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/25-type-resolution-crash-fixes/25-03-SUMMARY.md`
</output>
