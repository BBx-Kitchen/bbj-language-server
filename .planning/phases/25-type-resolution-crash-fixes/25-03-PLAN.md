---
phase: 25-type-resolution-crash-fixes
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/bbj-scope-local.ts
  - bbj-vscode/src/language/java-interop.ts
  - bbj-vscode/test/linking.test.ts
  - bbj-vscode/test/parser.test.ts
autonomous: true

must_haves:
  truths:
    - "A DECLARE statement placed anywhere in a method body is recognized for type resolution"
    - "DECLARE type is authoritative -- it applies to entire method scope regardless of position"
    - "A USE statement referencing a Java inner class does not crash the language server"
    - "Each USE statement is independent -- one failure does not block others from processing"
    - "Warning diagnostic appears on USE lines that cannot be resolved"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-scope-local.ts"
      provides: "DECLARE method-scoped variable registration and crash-safe USE processing"
      contains: "isVariableDecl"
    - path: "bbj-vscode/src/language/java-interop.ts"
      provides: "Inner class dollar-sign handling in extractPackageName"
      contains: "\\$"
    - path: "bbj-vscode/test/linking.test.ts"
      provides: "Tests for DECLARE scope and USE crash resistance"
      contains: "DECLARE"
  key_links:
    - from: "bbj-vscode/src/language/bbj-scope-local.ts"
      to: "processNode"
      via: "isVariableDecl check adding to method scope"
      pattern: "isVariableDecl.*addToScope"
    - from: "bbj-vscode/src/language/java-interop.ts"
      to: "extractPackageName"
      via: "dollar sign handling for inner classes"
      pattern: "\\$.*className"
---

<objective>
Fix DECLARE scope to cover entire method body regardless of position, and fix USE statement crash on Java inner classes.

Purpose: DECLARE statements currently go through the generic `else` branch in `processNode` which adds them to their immediate container scope (e.g., the CompoundStatement or statement list they appear in). This means a DECLARE after some code is not visible to earlier references. Per user decision, DECLARE should apply to the entire method scope. Additionally, USE statements referencing Java inner classes (e.g., `use org.jsoup.nodes.Element` where Element is an inner class) crash the server because `extractPackageName` incorrectly parses the package/class boundary.

Output: Updated `bbj-scope-local.ts` with method-scoped DECLARE handling and crash-safe USE processing, updated `java-interop.ts` with inner class support, plus tests.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-type-resolution-crash-fixes/25-CONTEXT.md
@.planning/phases/25-type-resolution-crash-fixes/25-RESEARCH.md
@bbj-vscode/src/language/bbj-scope-local.ts
@bbj-vscode/src/language/java-interop.ts
@bbj-vscode/src/language/bbj-scope.ts
@bbj-vscode/src/language/bbj-module.ts
@bbj-vscode/src/language/bbj-validator.ts
@bbj-vscode/src/language/bbj-nodedescription-provider.ts
@bbj-vscode/src/language/generated/ast.ts
@bbj-vscode/src/language/bbj.langium
@bbj-vscode/test/linking.test.ts
@bbj-vscode/test/parser.test.ts
@bbj-vscode/test/bbj-test-module.ts
@bbj-vscode/test/test-helper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix DECLARE scope to cover entire method body and harden USE statement processing</name>
  <files>bbj-vscode/src/language/bbj-scope-local.ts, bbj-vscode/src/language/java-interop.ts</files>
  <action>
**DECLARE scope fix (TYPE-04):**

In `processNode` in `BbjScopeComputation`, add a new branch BEFORE the generic `else` block to handle `VariableDecl` nodes (DECLARE statements). Currently VariableDecl falls through to the `else` branch which adds it to `node.$container` -- typically the statement list or CompoundStatement it appears in. Per user decision, DECLARE should be method-scoped (visible everywhere in the containing method).

Add this logic:

```typescript
import { isVariableDecl, isMethodDecl, MethodDecl, VariableDecl } from './generated/ast.js';
// ... (add isVariableDecl to existing imports)
```

In processNode, add a new branch:

```typescript
} else if (isVariableDecl(node) && node.$containerProperty !== 'params') {
    // DECLARE statements should be scoped to the entire method body
    // not just the block they appear in
    const methodScope = AstUtils.getContainerOfType(node, isMethodDecl);
    const scopeHolder = methodScope ?? node.$container;
    if (scopeHolder) {
        const description = this.descriptions.createDescription(node, node.name);
        this.addToScope(scopes, scopeHolder, description);
    }
}
```

Place this BEFORE the existing generic `else` block. The check `$containerProperty !== 'params'` ensures method parameter declarations (which also return VariableDecl from the grammar) don't get double-added -- params are already handled by Langium's default scope computation.

When VariableDecl is inside a method, add it to the MethodDecl scope (the method itself). When it's at the top level (no containing method), add it to its direct container as before.

**USE crash fix (STAB-01):**

The crash happens in `processNode` when processing USE statements with Java inner classes. The `tryResolveJavaReference` method calls `resolveClassByName` which calls `getRawClass` -> `connect` -> backend request. If the backend can't find the class (because the FQN includes an inner class name like `org.jsoup.nodes.Element` where Element is `Document.Element`), it may throw or return an error.

Two fixes needed:

1. **In `java-interop.ts`, fix `extractPackageName`**: The current implementation uses a regex `/\.(?=[A-Z])/` to find the first dot before a capital letter, assuming that's where the class name starts. This works for regular classes (`java.util.HashMap` -> `java.util`) but fails for inner classes where the simple class name has a `$` separator (e.g., `java.util.Map$Entry`).

However, the real issue is: when users write `use java.util.Map.Entry`, the FQN string assembled by `getFQNFullname` is `java.util.Map.Entry` -- but the Java backend expects `java.util.Map$Entry` (dollar sign notation).

The fix should be in `processNode` for USE statements: when `tryResolveJavaReference` fails for a className, try replacing the last `.` with `$` and retry. This handles the case where `java.util.Map.Entry` should actually be resolved as `java.util.Map$Entry`.

```typescript
// In processNode, in the isUse(node) && node.javaClass branch:
if (isUse(node) && node.javaClass) {
    const javaClassName = getFQNFullname(node.javaClass);
    let javaClass = await this.tryResolveJavaReference(javaClassName, this.javaInterop);

    // If resolution failed, try inner class notation (replace last . with $)
    if (!javaClass && javaClassName.includes('.')) {
        const lastDot = javaClassName.lastIndexOf('.');
        const innerClassName = javaClassName.substring(0, lastDot) + '$' + javaClassName.substring(lastDot + 1);
        javaClass = await this.tryResolveJavaReference(innerClassName, this.javaInterop);
    }

    if (!javaClass) {
        return;
    }
    if (javaClass.error) {
        console.warn(`Java '${javaClassName}' class resolution error: ${javaClass.error}`)
        return;
    }
    // ... rest is same
}
```

2. **Wrap the USE processing in try/catch**: The existing `tryResolveJavaReference` already has a try/catch, but there might be errors during the scope addition. Ensure the entire USE branch doesn't crash the document processing. Wrap the USE handler in its own try/catch:

```typescript
if (isUse(node) && node.javaClass) {
    try {
        // ... existing logic with inner class retry
    } catch (e) {
        console.warn(`Error processing USE statement for ${getFQNFullname(node.javaClass)}: ${e}`);
        return;
    }
}
```

This ensures per user decision: "Each USE statement is independent -- one failure doesn't block others from processing."

3. **Also handle the `extractPackageName` function in java-interop.ts** for completeness: when a className contains `$` (e.g., `java.util.Map$Entry`), the package name should still be `java.util`. The current regex `/\.(?=[A-Z])/` would match `java.` (first dot before `util` starts with lowercase, so no match there) then `.M` in `.Map` -- returning `java.util` which is correct. So `extractPackageName` actually works correctly for `$` notation already. The fix is primarily in the processNode USE branch (trying `$` notation on failure).
  </action>
  <verify>Run `npm test` from `bbj-vscode/` -- all existing tests pass.</verify>
  <done>DECLARE statements are scoped to the entire method body (MethodDecl scope). USE statements with inner class references attempt `$` notation fallback and are wrapped in try/catch to prevent crashes.</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for DECLARE scope and USE crash resistance</name>
  <files>bbj-vscode/test/linking.test.ts, bbj-vscode/test/parser.test.ts</files>
  <action>
Add tests to `linking.test.ts` for DECLARE scope behavior and USE crash resistance.

**DECLARE tests:**

```typescript
test('DECLARE anywhere in method body is recognized for type resolution', async () => {
    const document = await validate(`
        class public MyClass
            method public void test()
                x$ = myVar!.charAt(1)
                declare BBjString myVar!
            methodend
        classend
    `)
    expectNoErrors(document)
})
```

This test has `declare` AFTER usage of `myVar!`. Per user decision, DECLARE applies to entire method scope regardless of position. The `.charAt(1)` call should resolve because `myVar!` is declared as `BBjString`.

Note: This test depends on the type inferer correctly handling VariableDecl (which it already does -- line 24 of bbj-type-inferer.ts handles `isVariableDecl`). The key is that the DECLARE is visible in scope despite appearing after usage.

```typescript
test('DECLARE at top level scope works', async () => {
    const document = await validate(`
        declare BBjString name!
        x = name!.charAt(1)
    `)
    expectNoErrors(document)
})
```

**USE crash resistance tests:**

The inner class USE test requires the Java interop backend to be running. Add it to the interop-dependent test section:

```typescript
describe.runIf(isInteropRunning)("Interop related tests", () => {
    // ... existing tests ...

    test('USE with nested/inner class does not crash', async () => {
        const document = await validate(`
            use java.util.Map.Entry
        `)
        // Should not crash -- either resolves or shows an error diagnostic
        expect(document.parseResult.parserErrors.length).toBe(0)
    })
})
```

Note: This test already exists in linking.test.ts ("Resolve nested class in use statement"). However, it only tests `Map.Entry` which works because the scope provider's `JavaSymbol` handling already resolves nested classes via the `nestedClasses` logic in `getScope`. The crash happens differently -- it happens during `processNode` in scope computation when the Java backend is called.

Add a separate non-interop test to verify crash resilience:

```typescript
test('USE with unresolvable class does not crash document processing', async () => {
    const document = await validate(`
        use com.nonexistent.FakeClass
        x$ = "hello"
    `)
    // Should parse fine, may have linking error for the USE, but should not crash
    expect(document.parseResult.parserErrors.length).toBe(0)
    // The x$ assignment should still work despite the bad USE
    const linkingErrors = findLinkingErrors(document)
    // Only the USE line should have issues, not x$
    expect(linkingErrors.every(err => err.message.includes('FakeClass') || err.message.includes('nonexistent'))).toBe(true)
})
```

Actually, this test may not work cleanly because without the Java interop running, ALL java USE statements fail. Let me adjust:

```typescript
test('Multiple USE statements are independent - one failure does not block others', async () => {
    const document = await validate(`
        use java.util.HashMap
        hm! = new HashMap()
        hm!.put("k","v")
    `)
    // This test verifies the basic USE->scope pipeline works
    // The crash resistance is architectural (try/catch) rather than test-observable
    // without the Java backend
    expectNoErrors(document)
})
```

The crash resistance for inner classes is best tested with the Java interop running. The key structural change (try/catch wrapping) prevents crashes regardless.

Also add a test to `parser.test.ts` if a parsing-level test is needed:

```typescript
test('DECLARE statement parses correctly anywhere in method', async () => {
    const document = await parse(`
        class public Test
            method public void m()
                x = 1
                declare BBjString name!
                y = 2
            methodend
        classend
    `)
    expect(document.parseResult.parserErrors.length).toBe(0)
})
```
  </action>
  <verify>Run `npm test` from `bbj-vscode/` -- all new and existing tests pass.</verify>
  <done>DECLARE anywhere in method body is visible to the entire method scope (tested with usage-before-declaration pattern). USE processing is wrapped in try/catch for crash resilience. At least 2 new tests verify DECLARE scope behavior.</done>
</task>

</tasks>

<verification>
1. `cd bbj-vscode && npm test` -- all tests pass (0 failures)
2. New tests cover: DECLARE after usage resolves correctly, DECLARE at top level works, USE crash resilience
3. `processNode` has explicit `isVariableDecl` handling that scopes to MethodDecl
4. USE processing has try/catch wrapping and inner class `$` notation fallback
</verification>

<success_criteria>
- DECLARE placed after usage in a method body is still recognized for type resolution
- DECLARE type is authoritative for the entire method scope
- USE statements with inner classes do not crash the server
- One failing USE does not block other USE statements from processing
- All existing tests pass (no regressions)
- TYPE-04 and STAB-01 requirements are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/25-type-resolution-crash-fixes/25-03-SUMMARY.md`
</output>
