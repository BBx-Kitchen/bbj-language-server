---
phase: 25-type-resolution-crash-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/bbj-type-inferer.ts
  - bbj-vscode/src/language/bbj-validator.ts
  - bbj-vscode/test/linking.test.ts
autonomous: true

must_haves:
  truths:
    - "CAST(object!, BBjString) conveys BBjString type so method completion works on the result"
    - "Implicit getter calls (obj!.Name$) correctly convey the backing field's type for downstream chaining"
    - "CAST with an unresolvable type shows a warning diagnostic and treats result as untyped"
    - "Implicit getter with unresolvable return type offers no completion (only when type is confidently resolved)"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-type-inferer.ts"
      provides: "CAST type inference and implicit getter type resolution"
      contains: "cast"
    - path: "bbj-vscode/src/language/bbj-validator.ts"
      provides: "Warning diagnostic for CAST with unresolvable type"
      contains: "CAST"
    - path: "bbj-vscode/test/linking.test.ts"
      provides: "Tests for CAST and implicit getter type resolution"
      contains: "CAST"
  key_links:
    - from: "bbj-vscode/src/language/bbj-type-inferer.ts"
      to: "LibFunction"
      via: "isLibFunction check in MethodCall branch"
      pattern: "isLibFunction.*cast"
    - from: "bbj-vscode/src/language/bbj-type-inferer.ts"
      to: "FieldDecl type"
      via: "accessor description path resolution"
      pattern: "isFieldDecl.*getClass.*type"
    - from: "bbj-vscode/src/language/bbj-validator.ts"
      to: "TypeInferer"
      via: "getType check on CAST MethodCall"
      pattern: "warning.*CAST|unresolvable"
---

<objective>
Fix CAST() and implicit getter type conveyance in the BBj type inferer so that downstream completion works correctly. Add warning diagnostic when CAST references an unresolvable type.

Purpose: CAST() currently returns `object` (untyped) because the type inferer treats it as a generic MethodCall. Implicit getters (auto-generated accessors like `obj!.Name$`) also fail to convey the backing field's type. Both cases cause completion to silently fail -- no errors, just no suggestions. This plan fixes the type inferer to correctly resolve types in both cases, and adds a warning diagnostic per user decision when CAST references an unresolvable type.

Output: Updated `bbj-type-inferer.ts` with CAST and accessor type handling, updated `bbj-validator.ts` with CAST warning check, plus tests proving the type chain works end-to-end.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-type-resolution-crash-fixes/25-CONTEXT.md
@.planning/phases/25-type-resolution-crash-fixes/25-RESEARCH.md
@bbj-vscode/src/language/bbj-type-inferer.ts
@bbj-vscode/src/language/bbj-scope-local.ts
@bbj-vscode/src/language/bbj-scope.ts
@bbj-vscode/src/language/bbj-nodedescription-provider.ts
@bbj-vscode/src/language/bbj-linker.ts
@bbj-vscode/src/language/bbj-validator.ts
@bbj-vscode/src/language/bbj-module.ts
@bbj-vscode/src/language/generated/ast.ts
@bbj-vscode/src/language/lib/functions.ts
@bbj-vscode/test/linking.test.ts
@bbj-vscode/test/bbj-test-module.ts
@bbj-vscode/test/test-helper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CAST() type resolution and implicit getter type resolution to BBjTypeInferer</name>
  <files>bbj-vscode/src/language/bbj-type-inferer.ts</files>
  <action>
Modify `BBjTypeInferer.getType()` to handle CAST() calls. The current code has a `isMethodCall(expression)` branch that just recurses into `this.getType(expression.method)`. This misses CAST because CAST is a LibFunction returning generic `object` in the library definition.

**Implementation:**

In the `isMethodCall(expression)` branch, BEFORE the existing `return this.getType(expression.method)` line, add logic to detect CAST:

1. Check if `expression.method` is a SymbolRef whose `.symbol.ref` is a LibFunction with name matching 'cast' (case-insensitive)
2. If it is CAST, the FIRST argument (`expression.args[0]`) is the type argument. In BBj, `CAST(obj!, BBjString)` passes the type name as the first arg and the object as the second arg (note: the lib definition says `CAST(param:object, param:object)` -- both are `object` typed params, but the first one is actually a type reference that gets parsed as a BBjTypeRef or SymbolRef).
3. The type argument is parsed as an expression. Check if `expression.args[0].expression` is:
   - A `BBjTypeRef` (via `isBBjTypeRef`): call `expression.args[0].expression.klass.ref` to get the Class
   - A `SymbolRef` (via `isSymbolRef`): check if `.symbol.ref` resolves to a Class (`isClass(ref)`)
4. Return the resolved Class, or `undefined` if unresolvable (per user decision: treat as untyped when CAST references an unresolvable type)

**Also handle implicit getter type resolution in the `isMemberCall` branch:**

The `isMemberCall` branch currently handles `isJavaField`, `isJavaMethod`, `isMethodDecl`, `isJavaPackage`, and `isClass`. It does NOT handle when `member.ref` resolves to a FieldDecl (which happens for auto-generated accessor descriptions).

The accessor descriptions are created in `bbj-scope-local.ts` `createAccessorDescription()` -- they have `type: MethodDecl.$type` but their `path` points to the backing FieldDecl. When `member.ref` is resolved via the path, it lands on the FieldDecl.

Add a check: if `isFieldDecl(member)` in the isMemberCall branch, return `getClass(member.type)`. This covers implicit getter access where the member description has MethodDecl type but resolves to the backing FieldDecl node.

Import any additionally needed type guards (e.g., `isLibFunction`, `isBBjTypeRef` if not already imported).

Note: Do NOT add `isVariableDecl` handling here. VariableDecl already works in the `isSymbolRef` branch (line 24). The gap is specifically for FieldDecl accessed via MemberCall (accessor pattern).
  </action>
  <verify>Run `npm test` from `bbj-vscode/` -- existing tests must still pass (no regressions in type inference).</verify>
  <done>The `getType()` method handles CAST() calls by extracting the type from the first argument, and handles implicit getter MemberCalls where the member resolves to a FieldDecl by returning `getClass(member.type)`. All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add CAST warning diagnostic and tests for CAST/implicit getter type resolution</name>
  <files>bbj-vscode/src/language/bbj-validator.ts, bbj-vscode/test/linking.test.ts</files>
  <action>
**Add CAST warning diagnostic to bbj-validator.ts:**

Per user decision: "When CAST() references an unresolvable type: show warning diagnostic" with "Warning severity (yellow squiggly)" on "the whole statement (CAST())".

Add a new validation check for MethodCall nodes in `registerValidationChecks`:

```typescript
const checks: ValidationChecks<BBjAstType> = {
    // ... existing checks ...
    MethodCall: [validator.checkMemberCallUsingAccessLevels, validator.checkCastTypeResolvable],
};
```

Wait -- `checkMemberCallUsingAccessLevels` is registered on `MemberCall`, not `MethodCall`. Check the existing registrations. `MemberCall` is already registered with `validator.checkMemberCallUsingAccessLevels`. `MethodCall` is a different AST type.

Look at the AST: MethodCall contains `method` (SymbolRef) and `args` (Argument[]). The CAST function is invoked as a MethodCall where `method` is a SymbolRef pointing to the LibFunction 'CAST'.

Add a new check on MethodCall:

```typescript
MethodCall: validator.checkCastTypeResolvable,
```

Implement `checkCastTypeResolvable` in `BBjValidator`:

```typescript
checkCastTypeResolvable(node: MethodCall, accept: ValidationAcceptor): void {
    // Check if this is a CAST() call
    if (!isSymbolRef(node.method)) return;
    const ref = node.method.symbol.ref;
    if (!isLibFunction(ref) || ref.name.toLowerCase() !== 'cast') return;

    // CAST has 2 args: first is the type reference
    if (node.args.length < 1) return;
    const typeArg = node.args[0].expression;

    let resolved = false;
    if (isBBjTypeRef(typeArg)) {
        resolved = typeArg.klass.ref !== undefined;
    } else if (isSymbolRef(typeArg)) {
        resolved = isClass(typeArg.symbol.ref);
    }

    if (!resolved) {
        const typeName = typeArg.$cstNode?.text ?? 'unknown';
        accept('warning', `Type '${typeName}' could not be resolved. CAST result will be untyped.`, {
            node: node
        });
    }
}
```

Add needed imports: `MethodCall`, `isSymbolRef`, `isLibFunction`, `isBBjTypeRef`, `isClass` from generated/ast.js. Note: `MethodCall` and `isLibFunction` may need to be added to the existing import from './generated/ast.js'.

**Tests for CAST and implicit getter type resolution:**

Add tests to `linking.test.ts` that verify CAST() and implicit getter type resolution produce no linking errors.

**Test 1: CAST() conveys type for method completion**

```
test('CAST() conveys type for downstream method calls', async () => {
    const document = await validate(`
        class public MyType
            method public void doSomething()
            methodend
        classend

        obj! = new MyType()
        casted! = CAST(obj!, MyType)
        casted!.doSomething()
    `)
    expectNoErrors(document)
})
```

**Test 2: Implicit getter conveys type**

```
test('Implicit getter conveys return type for method chaining', async () => {
    const document = await validate(`
        class public Container
            field public BBjString Name$
        classend

        c! = new Container()
        c!.getName().charAt(1)
    `)
    expectNoErrors(document)
})
```

Adapt tests to use available fake Java classes. The linking test pattern is: if the member call chain resolves without linking errors, the type was correctly conveyed.

Run the tests and iterate until they pass cleanly.
  </action>
  <verify>Run `npm test` from `bbj-vscode/` -- all new tests pass, zero regressions. Grep bbj-validator.ts for 'CAST' to confirm the warning check exists.</verify>
  <done>At least 2 new tests exist: one for CAST type conveyance and one for implicit getter type conveyance. Both pass. CAST with unresolvable type emits a warning diagnostic on the MethodCall node. All pre-existing tests pass.</done>
</task>

</tasks>

<verification>
1. `cd bbj-vscode && npm test` -- all tests pass (0 failures)
2. New tests specifically cover TYPE-01 (CAST) and TYPE-03 (implicit getter) scenarios
3. The type inferer's `getType()` method has explicit CAST handling (grep for 'cast' in bbj-type-inferer.ts)
4. The type inferer's `isMemberCall` branch handles FieldDecl (grep for 'isFieldDecl' in the MemberCall section)
5. The validator has a `checkCastTypeResolvable` method that emits 'warning' severity on the MethodCall node when CAST type is unresolvable
</verification>

<success_criteria>
- CAST(obj!, SomeType).method() does not produce linking errors when SomeType has that method
- obj!.getField().method() does not produce linking errors when field type has that method
- CAST with unresolvable type produces a warning diagnostic (not error) on the MethodCall node
- All existing tests pass (no regressions)
- TYPE-01 and TYPE-03 requirements are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/25-type-resolution-crash-fixes/25-01-SUMMARY.md`
</output>
