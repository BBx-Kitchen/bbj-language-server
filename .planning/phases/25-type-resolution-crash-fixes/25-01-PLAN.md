---
phase: 25-type-resolution-crash-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/bbj-type-inferer.ts
  - bbj-vscode/src/language/bbj-scope-local.ts
  - bbj-vscode/test/linking.test.ts
autonomous: true

must_haves:
  truths:
    - "CAST(object!, BBjString) conveys BBjString type so method completion works on the result"
    - "Implicit getter calls (obj!.Name$) correctly convey the backing field's type for downstream chaining"
    - "CAST with an unresolvable type shows a warning diagnostic and treats result as untyped"
    - "Implicit getter with unresolvable return type offers no completion (only when type is confidently resolved)"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-type-inferer.ts"
      provides: "CAST type inference and implicit getter type resolution"
      contains: "cast"
    - path: "bbj-vscode/test/linking.test.ts"
      provides: "Tests for CAST and implicit getter type resolution"
      contains: "CAST"
  key_links:
    - from: "bbj-vscode/src/language/bbj-type-inferer.ts"
      to: "LibFunction"
      via: "isLibFunction check in MethodCall branch"
      pattern: "isLibFunction.*cast"
    - from: "bbj-vscode/src/language/bbj-type-inferer.ts"
      to: "FieldDecl type"
      via: "accessor description path resolution"
      pattern: "isFieldDecl.*getClass.*type"
---

<objective>
Fix CAST() and implicit getter type conveyance in the BBj type inferer so that downstream completion works correctly.

Purpose: CAST() currently returns `object` (untyped) because the type inferer treats it as a generic MethodCall. Implicit getters (auto-generated accessors like `obj!.Name$`) also fail to convey the backing field's type. Both cases cause completion to silently fail -- no errors, just no suggestions. This plan fixes the type inferer to correctly resolve types in both cases.

Output: Updated `bbj-type-inferer.ts` with CAST and accessor type handling, plus tests proving the type chain works end-to-end.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-type-resolution-crash-fixes/25-CONTEXT.md
@.planning/phases/25-type-resolution-crash-fixes/25-RESEARCH.md
@bbj-vscode/src/language/bbj-type-inferer.ts
@bbj-vscode/src/language/bbj-scope-local.ts
@bbj-vscode/src/language/bbj-scope.ts
@bbj-vscode/src/language/bbj-nodedescription-provider.ts
@bbj-vscode/src/language/bbj-linker.ts
@bbj-vscode/src/language/generated/ast.ts
@bbj-vscode/src/language/lib/functions.ts
@bbj-vscode/test/linking.test.ts
@bbj-vscode/test/bbj-test-module.ts
@bbj-vscode/test/test-helper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CAST() type resolution to BBjTypeInferer</name>
  <files>bbj-vscode/src/language/bbj-type-inferer.ts</files>
  <action>
Modify `BBjTypeInferer.getType()` to handle CAST() calls. The current code has a `isMethodCall(expression)` branch that just recurses into `this.getType(expression.method)`. This misses CAST because CAST is a LibFunction returning generic `object` in the library definition.

**Implementation:**

In the `isMethodCall(expression)` branch, BEFORE the existing `return this.getType(expression.method)` line, add logic to detect CAST:

1. Check if `expression.method` is a SymbolRef whose `.symbol.ref` is a LibFunction with name matching 'cast' (case-insensitive)
2. If it is CAST, the FIRST argument (`expression.args[0]`) is the type argument. In BBj, `CAST(obj!, BBjString)` passes the type name as the first arg and the object as the second arg (note: the lib definition says `CAST(param:object, param:object)` -- both are `object` typed params, but the first one is actually a type reference that gets parsed as a BBjTypeRef or SymbolRef).
3. The type argument is parsed as an expression. Check if `expression.args[0].expression` is:
   - A `BBjTypeRef` (via `isBBjTypeRef`): call `expression.args[0].expression.klass.ref` to get the Class
   - A `SymbolRef` (via `isSymbolRef`): check if `.symbol.ref` resolves to a Class (`isClass(ref)`)
4. Return the resolved Class, or `undefined` if unresolvable (per user decision: treat as untyped when CAST references an unresolvable type)

**Also handle implicit getter type resolution in the `isMemberCall` branch:**

The `isMemberCall` branch currently handles `isJavaField`, `isJavaMethod`, `isMethodDecl`, `isJavaPackage`, and `isClass`. It does NOT handle when `member.ref` resolves to a FieldDecl (which happens for auto-generated accessor descriptions).

The accessor descriptions are created in `bbj-scope-local.ts` `createAccessorDescription()` -- they have `type: MethodDecl.$type` but their `path` points to the backing FieldDecl. When `member.ref` is resolved via the path, it lands on the FieldDecl.

Add a check: if `isFieldDecl(member)` in the isMemberCall branch, return `getClass(member.type)`. This covers implicit getter access where the member description has MethodDecl type but resolves to the backing FieldDecl node.

Import any additionally needed type guards (e.g., `isLibFunction`, `isBBjTypeRef` if not already imported).

Note: Do NOT add `isVariableDecl` handling here. VariableDecl already works in the `isSymbolRef` branch (line 24). The gap is specifically for FieldDecl accessed via MemberCall (accessor pattern).
  </action>
  <verify>Run `npm test` from `bbj-vscode/` -- existing tests must still pass (no regressions in type inference).</verify>
  <done>The `getType()` method handles CAST() calls by extracting the type from the first argument, and handles implicit getter MemberCalls where the member resolves to a FieldDecl by returning `getClass(member.type)`. All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for CAST and implicit getter type resolution</name>
  <files>bbj-vscode/test/linking.test.ts, bbj-vscode/test/bbj-test-module.ts</files>
  <action>
Add tests to `linking.test.ts` that verify CAST() and implicit getter type resolution produce no linking errors (which proves the type chain works, since member calls on the result would fail with linking errors if the type wasn't resolved).

**Test 1: CAST() conveys type for method completion**

```
test('CAST() conveys type for downstream method calls', async () => {
    const document = await validate(`
        foo$ = "hello"
        result$ = CAST(foo!, BBjString)
        result$.charAt(1)
    `)
    expectNoErrors(document)
})
```

This works because:
- `BBjString` is a well-known class that resolves (similar to how `java.lang.String` works)
- If CAST returns the correct type, `.charAt(1)` links successfully
- If CAST fails to convey type, `.charAt(1)` produces a linking error

Note: `BBjString` may not be available in the test module's fake Java environment. If so, use `java.lang.String` with the existing fake String class. The test may need to use a SymbolRef form for the type argument. Adapt the test to use whatever type is available in the test module's fake classpath. The key is: CAST(expr, SomeKnownType).someMethod() should not produce linking errors.

If the test module's fake classes don't support this pattern, add a BBj class instead:

```
test('CAST() conveys type for downstream method calls', async () => {
    const document = await validate(`
        class public MyType
            method public void doSomething()
            methodend
        classend

        obj! = new MyType()
        casted! = CAST(obj!, MyType)
        casted!.doSomething()
    `)
    expectNoErrors(document)
})
```

**Test 2: Implicit getter conveys type**

```
test('Implicit getter conveys return type for method chaining', async () => {
    const document = await validate(`
        class public Container
            field public BBjString Name$
        classend

        c! = new Container()
        c!.getName().charAt(1)
    `)
    expectNoErrors(document)
})
```

This tests that the auto-generated accessor `getName()` returns the type of the `Name$` field (BBjString), and `.charAt(1)` successfully links against it.

Again, adapt to use available fake Java classes. The linking test pattern is: if the member call chain resolves without linking errors, the type was correctly conveyed.

**Test Module Updates:**

If needed, update `bbj-test-module.ts` to ensure the fake `java.lang.String` class (already exists as `createJavaLangStringClass`) is properly stored and resolvable by name. Currently `resolveClass` is called but `storeJavaClass` may not be invoked in the test module setup. Check if `this.storeJavaClass` is called within `resolveClass` and if the fake classes are findable by `getResolvedClass`. If `getResolvedClass('java.lang.String')` returns undefined in tests, the charAt linking already fails. Since the existing test "String literal is of type java.lang.String type" passes and uses `.charAt(1)`, the fake String class IS working.

Run the tests and iterate until they pass cleanly.
  </action>
  <verify>Run `npm test` from `bbj-vscode/` -- all new tests pass, zero regressions.</verify>
  <done>At least 2 new tests exist: one for CAST type conveyance and one for implicit getter type conveyance. Both pass. All pre-existing tests pass.</done>
</task>

</tasks>

<verification>
1. `cd bbj-vscode && npm test` -- all tests pass (0 failures)
2. New tests specifically cover TYPE-01 (CAST) and TYPE-03 (implicit getter) scenarios
3. The type inferer's `getType()` method has explicit CAST handling (grep for 'cast' in bbj-type-inferer.ts)
4. The type inferer's `isMemberCall` branch handles FieldDecl (grep for 'isFieldDecl' in the MemberCall section)
</verification>

<success_criteria>
- CAST(obj!, SomeType).method() does not produce linking errors when SomeType has that method
- obj!.getField().method() does not produce linking errors when field type has that method
- All existing tests pass (no regressions)
- TYPE-01 and TYPE-03 requirements are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/25-type-resolution-crash-fixes/25-01-SUMMARY.md`
</output>
