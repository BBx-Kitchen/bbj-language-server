---
phase: 25-type-resolution-crash-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/bbj-scope.ts
  - bbj-vscode/src/language/bbj-hover.ts
  - bbj-vscode/src/language/bbj-validator.ts
  - bbj-vscode/test/linking.test.ts
autonomous: true

must_haves:
  truths:
    - "Accessing a super class field via #field! does not produce a warning when the field exists on a parent class"
    - "#field! completion inside a class includes inherited fields from super classes"
    - "Hover on inherited field explicitly says 'inherited from ParentClass'"
    - "If a class extends an unresolvable type, #field! access gets a warning explaining why resolution is incomplete"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-scope.ts"
      provides: "Cycle-safe inheritance chain traversal in createBBjClassMemberScope"
      contains: "visited"
    - path: "bbj-vscode/src/language/bbj-hover.ts"
      provides: "Inherited field hover info with explicit 'inherited from' text"
      contains: "inherited from"
    - path: "bbj-vscode/src/language/bbj-validator.ts"
      provides: "Warning diagnostic for unresolvable super class on MemberCall"
      contains: "unresolvable"
    - path: "bbj-vscode/test/linking.test.ts"
      provides: "Tests for super class field access"
      contains: "super class field"
  key_links:
    - from: "bbj-vscode/src/language/bbj-scope.ts"
      to: "createBBjClassMemberScope"
      via: "recursive traversal with visited set"
      pattern: "visited.*Set.*BbjClass"
    - from: "bbj-vscode/src/language/bbj-scope.ts"
      to: "createScopeForNodes"
      via: "Java class member scope as outer scope in inheritance chain"
      pattern: "createScopeForNodes.*fields.*methods"
    - from: "bbj-vscode/src/language/bbj-hover.ts"
      to: "getAstNodeHoverContent"
      via: "inherited from text appended to hover body"
      pattern: "inherited from"
---

<objective>
Fix super class field resolution so that `#field!` access on inherited fields resolves correctly without warnings, and the full inheritance chain is traversed with cycle protection. Add explicit "inherited from ParentClass" text to hover. Add warning diagnostic when class extends unresolvable type.

Purpose: Currently `createBBjClassMemberScope` in `bbj-scope.ts` handles one level of BBj super class and one level of Java super class, but it doesn't chain Java supers beyond the first one, doesn't protect against cyclic inheritance, and doesn't provide hover info for inherited fields. When a `#field!` accesses an inherited field, it should resolve silently. When the parent class is unresolvable, it should produce a helpful warning.

Output: Updated `bbj-scope.ts` with cycle-safe full inheritance chain traversal, updated `bbj-hover.ts` with "inherited from" info, updated `bbj-validator.ts` with unresolvable super warning, plus tests.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-type-resolution-crash-fixes/25-CONTEXT.md
@.planning/phases/25-type-resolution-crash-fixes/25-RESEARCH.md
@bbj-vscode/src/language/bbj-scope.ts
@bbj-vscode/src/language/bbj-hover.ts
@bbj-vscode/src/language/bbj-validator.ts
@bbj-vscode/src/language/bbj-type-inferer.ts
@bbj-vscode/src/language/bbj-scope-local.ts
@bbj-vscode/src/language/bbj-nodedescription-provider.ts
@bbj-vscode/src/language/generated/ast.ts
@bbj-vscode/test/linking.test.ts
@bbj-vscode/test/bbj-test-module.ts
@bbj-vscode/test/test-helper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cycle-safe full inheritance chain traversal and unresolvable super warning</name>
  <files>bbj-vscode/src/language/bbj-scope.ts, bbj-vscode/src/language/bbj-validator.ts</files>
  <action>
**Modify `createBBjClassMemberScope` in `BbjScopeProvider`:**

1. **Add cycle protection**: Add an optional `visited?: Set<BbjClass>` parameter. On each recursive call, check if the class is already in the visited set. If so, return the current descriptions without recursing further. Add the current class to the visited set before recursing.

2. **Chain Java super classes**: Currently when `superType` is a JavaClass, the method returns a scope with the JavaClass's fields and methods but doesn't traverse the JavaClass's own super classes. This is acceptable because Java interop resolves the full hierarchy on the Java side -- when `resolveClass` processes a JavaClass, it already includes inherited members. So the existing behavior for JavaClass supers is correct. No change needed for JavaClass chaining.

3. **Handle missing super type**: When `bbjType.extends.length == 1` but `getClass(bbjType.extends[0])` returns undefined (unresolvable type), the current code falls through the if/else-if block entirely and returns `this.createCaseSensitiveScope(descriptions)` at the bottom -- no Object members at all. This is a bug. Fix: after the `if (isBbjClass)` and `else if (isJavaClass)` checks, add an else clause that still chains to java.lang.Object:

```typescript
createBBjClassMemberScope(bbjType: BbjClass, methodsOnly: boolean = false, visited?: Set<BbjClass>): StreamScope {
    // Cycle protection
    if (!visited) {
        visited = new Set();
    }
    if (visited.has(bbjType)) {
        return this.createCaseSensitiveScope([]);
    }
    visited.add(bbjType);

    const document = AstUtils.getDocument(bbjType)
    const typeScope = document?.localSymbols?.getStream(bbjType).toArray()
    let descriptions: AstNodeDescription[] = []
    if (typeScope) {
        descriptions.push(...typeScope.filter((member: AstNodeDescription) => !methodsOnly || member.type === MethodDecl.$type))
    }
    if (bbjType.extends.length == 1) {
        const superType = getClass(bbjType.extends[0]);
        if (isBbjClass(superType)) {
            return this.createCaseSensitiveScope(descriptions, this.createBBjClassMemberScope(superType, methodsOnly, visited))
        } else if (isJavaClass(superType)) {
            return this.createCaseSensitiveScope(descriptions, this.createScopeForNodes(stream(superType.fields).concat(superType.methods)))
        }
        // else: extends clause present but unresolvable -- fall through to Object
    }
    // No extends or unresolvable extends: chain to java.lang.Object
    const javaObject = this.javaInterop.getResolvedClass('java.lang.Object');
    if (javaObject) {
        const members = stream(javaObject.fields).concat(javaObject.methods);
        return this.createCaseSensitiveScope(descriptions, this.createScopeForNodes(members))
    }
    return this.createCaseSensitiveScope(descriptions)
}
```

Key changes from the original:
- Added `visited` parameter with cycle detection
- Moved the `java.lang.Object` fallback outside the `else` block so it applies to BOTH "no extends" AND "unresolvable extends" cases
- Removed the `else` wrapping around the Object fallback

4. **Update callers**: The two call sites in `getScope()` that call `createBBjClassMemberScope(receiverType)` and `createBBjClassMemberScope(bbjType, false)` don't need to pass `visited` since it's optional and defaults to a new Set.

**Add unresolvable super class warning to bbj-validator.ts:**

Per user decision: "If a class extends an unresolvable type, each #field! access gets a warning explaining why resolution is incomplete."

Update the existing `MemberCall` check registration to include a new check. In `registerValidationChecks`, change:

```typescript
MemberCall: validator.checkMemberCallUsingAccessLevels,
```

to:

```typescript
MemberCall: [validator.checkMemberCallUsingAccessLevels, validator.checkUnresolvableSuperAccess],
```

Implement `checkUnresolvableSuperAccess` in `BBjValidator`:

```typescript
checkUnresolvableSuperAccess(memberCall: MemberCall, accept: ValidationAcceptor): void {
    // Only check #field! access pattern (instance access within a class)
    if (!memberCall.instanceAccess) return;

    // Get the class context of the usage
    const classOfUsage = AstUtils.getContainerOfType(memberCall, isClass);
    if (!classOfUsage || !isBbjClass(classOfUsage)) return;

    // Check if this class has an unresolvable super
    if (classOfUsage.extends.length !== 1) return;
    const superType = getClass(classOfUsage.extends[0]);
    if (superType !== undefined) return; // Super is resolvable, no warning needed

    // The member resolved (no linking error), but super class is unresolvable
    // so we may be missing inherited members
    const member = memberCall.member?.ref;
    if (member) return; // Member resolved fine despite unresolvable super -- no warning

    // Member did NOT resolve AND super is unresolvable -- warn that super is the likely cause
    const superName = classOfUsage.extends[0]?.$cstNode?.text ?? 'unknown';
    accept('warning', `Cannot resolve member '${memberCall.member?.$refText}'. Parent class '${superName}' could not be resolved -- inherited members are unavailable.`, {
        node: memberCall,
        property: 'member'
    });
}
```

Add any needed imports: `getClass` from bbj-nodedescription-provider.
  </action>
  <verify>Run `npm test` from `bbj-vscode/` -- existing tests pass. No regressions in scope resolution.</verify>
  <done>`createBBjClassMemberScope` has cycle protection via visited Set, and the java.lang.Object fallback applies to both "no extends" and "unresolvable extends" cases. Unresolvable super class produces a warning diagnostic on MemberCall.</done>
</task>

<task type="auto">
  <name>Task 2: Add inherited field hover info with explicit "inherited from" text and tests</name>
  <files>bbj-vscode/src/language/bbj-hover.ts, bbj-vscode/test/linking.test.ts</files>
  <action>
**Hover info for inherited fields -- explicit "inherited from ParentClass" text:**

Per user decision: "Hover/tooltip on inherited fields should say 'inherited from ParentClass' as helpful info."

In `bbj-hover.ts`, update `getAstNodeHoverContent` to add an explicit "inherited from ParentClass" line in the hover body for fields and methods that belong to a different class than where they are used.

The challenge: `getAstNodeHoverContent` receives the resolved definition node (the FieldDecl or MethodDecl), not the usage site. The hover infrastructure resolves the reference target and passes that node.

**Approach:** Modify the FieldDecl branch in `documentationHeader()` to include the owner class name (matching the MethodDecl pattern which already uses `ownerClass()`):

```typescript
if (isFieldDecl(node)) {
    const owner = ownerClass(node)
    return `${javaTypeAdjust(getFQNFullname(node.type) ?? 'Object')} ${owner}${(node as any)['simpleName'] ? (node as any)['simpleName'] : node.name}`;
}
```

This shows `String ParentClass.name$` which indicates the declaring class.

**Additionally**, in `getAstNodeHoverContent`, after calling `documentationHeader(node)`, if the node is a FieldDecl or MethodDecl and belongs to a BbjClass, append an explicit "inherited from" note to the hover markdown body. Since the hover provider doesn't have access to the usage site, we can always include the owner class info:

```typescript
protected override async getAstNodeHoverContent(node: AstNode): Promise<string | undefined> {
    const header = documentationHeader(node)
    if (isBbjClass(node) || isBBjClassMember(node)) {
        const comments = this.getAstNodeComments(node);
        // Add "inherited from" note for class members
        let inheritedNote = '';
        if ((isFieldDecl(node) || isMethodDecl(node)) && isClass(node.$container)) {
            inheritedNote = `\n\n*inherited from ${node.$container.name}*`;
        }
        if (comments) {
            return this.createMarkdownContent(header, comments + inheritedNote);
        }
        if (inheritedNote) {
            return this.createMarkdownContent(header, inheritedNote.trim());
        }
    }
    // ... rest unchanged
```

This adds "*inherited from ParentClass*" to the hover body whenever a class member is hovered. When hovering from the declaring class itself, it still shows the owner but it's accurate (the field IS defined in that class). When hovering from a child class, it clearly shows which parent class defines the member.

Add `isMethodDecl` to the imports at the top if not already imported.

**Tests for super class field resolution:**

Add to `linking.test.ts`:

```typescript
test('Super class field access via #field! resolves without warning', async () => {
    const document = await validate(`
        class public Parent
            field public BBjString name$
        classend

        class public Child extends Parent
            method public void test()
                x$ = #name$
            methodend
        classend
    `)
    expectNoErrors(document)
})

test('Multi-level inheritance field access resolves', async () => {
    const document = await validate(`
        class public GrandParent
            field public BBjString legacy$
        classend

        class public Parent extends GrandParent
        classend

        class public Child extends Parent
            method public void test()
                x$ = #legacy$
            methodend
        classend
    `)
    expectNoErrors(document)
})

test('Super class method access resolves without error', async () => {
    const document = await validate(`
        class public Parent
            method public void greet()
            methodend
        classend

        class public Child extends Parent
            method public void test()
                #this!.greet()
            methodend
        classend
    `)
    expectNoErrors(document)
})
```
  </action>
  <verify>Run `npm test` from `bbj-vscode/` -- all new and existing tests pass. Grep bbj-hover.ts for 'inherited from' to confirm the text appears.</verify>
  <done>Inherited fields from super classes resolve via `#field!` without linking errors. Hover on fields shows explicit "inherited from ParentClass" text in the hover body. Unresolvable super class produces a warning on MemberCall. At least 3 new tests verify multi-level inheritance field and method access.</done>
</task>

</tasks>

<verification>
1. `cd bbj-vscode && npm test` -- all tests pass (0 failures)
2. New tests cover: single-level inheritance field access, multi-level inheritance field access, super class method access
3. `createBBjClassMemberScope` has a `visited` parameter for cycle protection
4. Hover on inherited fields shows explicit "inherited from ParentClass" text
5. Unresolvable super class produces warning diagnostic on MemberCall nodes
</verification>

<success_criteria>
- `#field!` on inherited fields produces no linking error or warning
- Multi-level BBj class inheritance is traversed correctly
- Cyclic inheritance doesn't cause stack overflow
- Hover body contains explicit "inherited from ParentClass" text
- Unresolvable super class produces warning on #field! access
- All existing tests pass (no regressions)
- TYPE-02 requirement is satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/25-type-resolution-crash-fixes/25-02-SUMMARY.md`
</output>
