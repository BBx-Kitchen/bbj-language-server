---
phase: 25-type-resolution-crash-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/bbj-scope.ts
  - bbj-vscode/src/language/bbj-hover.ts
  - bbj-vscode/test/linking.test.ts
autonomous: true

must_haves:
  truths:
    - "Accessing a super class field via #field! does not produce a warning when the field exists on a parent class"
    - "#field! completion inside a class includes inherited fields from super classes"
    - "Hover on inherited field says 'inherited from ParentClass'"
    - "If a class extends an unresolvable type, #field! access gets a warning explaining why resolution is incomplete"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-scope.ts"
      provides: "Cycle-safe inheritance chain traversal in createBBjClassMemberScope"
      contains: "visited"
    - path: "bbj-vscode/src/language/bbj-hover.ts"
      provides: "Inherited field hover info"
      contains: "inherited"
    - path: "bbj-vscode/test/linking.test.ts"
      provides: "Tests for super class field access"
      contains: "super class field"
  key_links:
    - from: "bbj-vscode/src/language/bbj-scope.ts"
      to: "createBBjClassMemberScope"
      via: "recursive traversal with visited set"
      pattern: "visited.*Set.*BbjClass"
    - from: "bbj-vscode/src/language/bbj-scope.ts"
      to: "createScopeForNodes"
      via: "Java class member scope as outer scope in inheritance chain"
      pattern: "createScopeForNodes.*fields.*methods"
---

<objective>
Fix super class field resolution so that `#field!` access on inherited fields resolves correctly without warnings, and the full inheritance chain is traversed with cycle protection.

Purpose: Currently `createBBjClassMemberScope` in `bbj-scope.ts` handles one level of BBj super class and one level of Java super class, but it doesn't chain Java supers beyond the first one, doesn't protect against cyclic inheritance, and doesn't provide hover info for inherited fields. When a `#field!` accesses an inherited field, it should resolve silently. When the parent class is unresolvable, it should produce a helpful warning.

Output: Updated `bbj-scope.ts` with cycle-safe full inheritance chain traversal, updated `bbj-hover.ts` with "inherited from" info, plus tests.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-type-resolution-crash-fixes/25-CONTEXT.md
@.planning/phases/25-type-resolution-crash-fixes/25-RESEARCH.md
@bbj-vscode/src/language/bbj-scope.ts
@bbj-vscode/src/language/bbj-hover.ts
@bbj-vscode/src/language/bbj-type-inferer.ts
@bbj-vscode/src/language/bbj-scope-local.ts
@bbj-vscode/src/language/bbj-nodedescription-provider.ts
@bbj-vscode/src/language/generated/ast.ts
@bbj-vscode/test/linking.test.ts
@bbj-vscode/test/bbj-test-module.ts
@bbj-vscode/test/test-helper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cycle-safe full inheritance chain traversal to createBBjClassMemberScope</name>
  <files>bbj-vscode/src/language/bbj-scope.ts</files>
  <action>
Modify `createBBjClassMemberScope` in `BbjScopeProvider` to:

1. **Add cycle protection**: Add an optional `visited?: Set<BbjClass>` parameter. On each recursive call, check if the class is already in the visited set. If so, return the current descriptions without recursing further. Add the current class to the visited set before recursing.

2. **Chain Java super classes**: Currently when `superType` is a JavaClass, the method returns a scope with the JavaClass's fields and methods but doesn't traverse the JavaClass's own super classes. This is acceptable because Java interop resolves the full hierarchy on the Java side -- when `resolveClass` processes a JavaClass, it already includes inherited members. So the existing behavior for JavaClass supers is correct. No change needed for JavaClass chaining.

3. **Handle missing super type**: When `bbjType.extends.length == 1` but `getClass(bbjType.extends[0])` returns undefined (unresolvable type), the current code falls through to the `else` branch which adds `java.lang.Object` as the implicit super. This is wrong -- if there IS an explicit extends clause that can't be resolved, we shouldn't silently fall through. Instead, if `getClass` returns undefined and extends exists, still create the scope with current descriptions and Object as outer scope (since Object is always the root), but the linking error on the extends clause itself will already flag the issue.

Actually, looking at the current code more carefully: The `else` branch only runs when `bbjType.extends.length != 1` (i.e., length 0). When extends.length is 1 but getClass returns undefined, the code falls through the if/else-if block entirely and returns `this.createCaseSensitiveScope(descriptions)` at the bottom -- no Object members at all. This is a bug. Fix: after the `if (isBbjClass)` and `else if (isJavaClass)` checks, add an else clause that still chains to java.lang.Object:

```typescript
createBBjClassMemberScope(bbjType: BbjClass, methodsOnly: boolean = false, visited?: Set<BbjClass>): StreamScope {
    // Cycle protection
    if (!visited) {
        visited = new Set();
    }
    if (visited.has(bbjType)) {
        return this.createCaseSensitiveScope([]);
    }
    visited.add(bbjType);

    const document = AstUtils.getDocument(bbjType)
    const typeScope = document?.localSymbols?.getStream(bbjType).toArray()
    let descriptions: AstNodeDescription[] = []
    if (typeScope) {
        descriptions.push(...typeScope.filter((member: AstNodeDescription) => !methodsOnly || member.type === MethodDecl.$type))
    }
    if (bbjType.extends.length == 1) {
        const superType = getClass(bbjType.extends[0]);
        if (isBbjClass(superType)) {
            return this.createCaseSensitiveScope(descriptions, this.createBBjClassMemberScope(superType, methodsOnly, visited))
        } else if (isJavaClass(superType)) {
            return this.createCaseSensitiveScope(descriptions, this.createScopeForNodes(stream(superType.fields).concat(superType.methods)))
        }
        // else: extends clause present but unresolvable -- fall through to Object
    }
    // No extends or unresolvable extends: chain to java.lang.Object
    const javaObject = this.javaInterop.getResolvedClass('java.lang.Object');
    if (javaObject) {
        const members = stream(javaObject.fields).concat(javaObject.methods);
        return this.createCaseSensitiveScope(descriptions, this.createScopeForNodes(members))
    }
    return this.createCaseSensitiveScope(descriptions)
}
```

Key changes from the original:
- Added `visited` parameter with cycle detection
- Moved the `java.lang.Object` fallback outside the `else` block so it applies to BOTH "no extends" AND "unresolvable extends" cases
- Removed the `else` wrapping around the Object fallback

4. **Update callers**: The two call sites in `getScope()` that call `createBBjClassMemberScope(receiverType)` and `createBBjClassMemberScope(bbjType, false)` don't need to pass `visited` since it's optional and defaults to a new Set.
  </action>
  <verify>Run `npm test` from `bbj-vscode/` -- existing tests pass. No regressions in scope resolution.</verify>
  <done>`createBBjClassMemberScope` has cycle protection via visited Set, and the java.lang.Object fallback applies to both "no extends" and "unresolvable extends" cases.</done>
</task>

<task type="auto">
  <name>Task 2: Add inherited field hover info and tests for super class field resolution</name>
  <files>bbj-vscode/src/language/bbj-hover.ts, bbj-vscode/test/linking.test.ts</files>
  <action>
**Hover info for inherited fields:**

In `bbj-hover.ts`, update `getAstNodeHoverContent` or `documentationHeader` to indicate when a field or method is inherited. When a FieldDecl or MethodDecl is accessed via a MemberCall, and the member's container class differs from the class containing the usage, add "(inherited from ParentClass)" to the hover text.

This is best done in `documentationHeader()` by checking if the node's `$container` (the declaring class) can be compared against some context. However, `documentationHeader` receives just the node, not the usage context.

A simpler approach: In `getAstNodeHoverContent`, when the node is a FieldDecl or MethodDecl that belongs to a BbjClass, check if that class is different from the class context of the usage. But hover resolves the definition node, not the usage node.

**Practical approach:** Extend the FieldDecl hover header in `documentationHeader()` to include the owner class name. Currently it shows `String Name$`. Change to show `Container.Name$` for class members (similar to how methods already show `ownerClass(node)` via the `ownerClass()` helper). The `ownerClass()` function already exists and returns `ClassName.` for class members. Apply it to FieldDecl:

```typescript
if (isFieldDecl(node)) {
    const owner = ownerClass(node)
    return `${javaTypeAdjust(getFQNFullname(node.type) ?? 'Object')} ${owner}${node.name}`;
}
```

This way, when hovering over `#name$` on an inherited field from `ParentClass`, the hover shows `String ParentClass.name$` which makes the inheritance origin clear.

For a more explicit "inherited from" indication, we would need access to both the usage context and the definition. This can be done in `getAstNodeHoverContent`:

After calling `documentationHeader(node)`, if `isFieldDecl(node) || isMethodDecl(node)`, and the node's container is a BbjClass, append a note:
- Get the containing class from the hover context (the AST node being hovered). However, the hover provider only gets the resolved definition node. The `AstNodeHoverProvider.getHoverContent` method receives the `HoverParams` with position, from which it resolves to the AST node at that position. The node passed to `getAstNodeHoverContent` is already the resolved reference target.

To detect inheritance: if the field/method declaration's $container class is different from the class where `#field!` is used, it's inherited. But we don't have the usage site in `getAstNodeHoverContent`.

**Simpler practical solution per user decision:** Just ensure the owner class name appears in the hover. The existing `ownerClass()` helper already does this for methods. Add it for fields too. This gives users the "inherited from ParentClass" information implicitly by showing `ParentClass.fieldName` in the hover.

**Tests for super class field resolution:**

Add to `linking.test.ts`:

```typescript
test('Super class field access via #field! resolves without warning', async () => {
    const document = await validate(`
        class public Parent
            field public BBjString name$
        classend

        class public Child extends Parent
            method public void test()
                x$ = #name$
            methodend
        classend
    `)
    expectNoErrors(document)
})

test('Multi-level inheritance field access resolves', async () => {
    const document = await validate(`
        class public GrandParent
            field public BBjString legacy$
        classend

        class public Parent extends GrandParent
        classend

        class public Child extends Parent
            method public void test()
                x$ = #legacy$
            methodend
        classend
    `)
    expectNoErrors(document)
})
```

These tests verify that `#field!` access on inherited fields does not produce linking errors, which proves the scope traversal correctly includes parent class members.

Also test method access on super class:

```typescript
test('Super class method access resolves without error', async () => {
    const document = await validate(`
        class public Parent
            method public void greet()
            methodend
        classend

        class public Child extends Parent
            method public void test()
                #this!.greet()
            methodend
        classend
    `)
    expectNoErrors(document)
})
```
  </action>
  <verify>Run `npm test` from `bbj-vscode/` -- all new and existing tests pass.</verify>
  <done>Inherited fields from super classes resolve via `#field!` without linking errors. Hover on fields shows the owner class name. At least 2 new tests verify multi-level inheritance field and method access.</done>
</task>

</tasks>

<verification>
1. `cd bbj-vscode && npm test` -- all tests pass (0 failures)
2. New tests cover: single-level inheritance field access, multi-level inheritance field access, super class method access
3. `createBBjClassMemberScope` has a `visited` parameter for cycle protection
4. Hover on inherited fields shows the declaring class name
</verification>

<success_criteria>
- `#field!` on inherited fields produces no linking error or warning
- Multi-level BBj class inheritance is traversed correctly
- Cyclic inheritance doesn't cause stack overflow
- Owner class name appears in field hover text
- All existing tests pass (no regressions)
- TYPE-02 requirement is satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/25-type-resolution-crash-fixes/25-02-SUMMARY.md`
</output>
