---
phase: 28-variable-scoping-declaration-order
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/bbj.langium
  - bbj-vscode/src/language/validations/check-variable-scoping.ts
  - bbj-vscode/src/language/bbj-validator.ts
autonomous: true

must_haves:
  truths:
    - "A variable used before its LET/DIM/assignment/DREAD in program scope shows a hint-severity diagnostic with the variable name and first-assignment line"
    - "A variable used after its assignment shows no use-before-assignment diagnostic"
    - "A DECLARE variable used before the DECLARE statement does NOT trigger use-before-assignment (whole-scope visibility)"
    - "Multiple DECLARE statements for the same variable with different types produce an error-severity diagnostic"
    - "The grammar stores the 'auto' keyword as a boolean property on VariableDecl"
  artifacts:
    - path: "bbj-vscode/src/language/validations/check-variable-scoping.ts"
      provides: "Use-before-assignment validation + conflicting DECLARE detection"
      min_lines: 80
    - path: "bbj-vscode/src/language/bbj.langium"
      provides: "VariableDecl with auto boolean property"
      contains: "auto?='auto'?"
    - path: "bbj-vscode/src/language/bbj-validator.ts"
      provides: "Registration of variable scoping checks"
      contains: "registerVariableScopingChecks"
  key_links:
    - from: "bbj-vscode/src/language/bbj-validator.ts"
      to: "bbj-vscode/src/language/validations/check-variable-scoping.ts"
      via: "import and call in registerValidationChecks"
      pattern: "registerVariableScopingChecks"
    - from: "bbj-vscode/src/language/validations/check-variable-scoping.ts"
      to: "bbj-vscode/src/language/generated/ast.ts"
      via: "AST type guards and node types"
      pattern: "isLetStatement|isArrayDeclarationStatement|isDreadStatement|isVariableDecl"
---

<objective>
Implement use-before-assignment diagnostics and conflicting DECLARE detection for BBj variable scoping.

Purpose: Variables in program and method scope should warn when used before any assignment (LET, DIM, DREAD, FOR init, plain assignment). DECLARE variables have whole-scope visibility and are exempt. Multiple DECLAREs with conflicting types are flagged as errors.

Output: New validation file, grammar update for DECLARE AUTO, and registration wiring.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-variable-scoping-declaration-order/28-CONTEXT.md
@.planning/phases/28-variable-scoping-declaration-order/28-RESEARCH.md
@bbj-vscode/src/language/bbj-validator.ts
@bbj-vscode/src/language/bbj-scope-local.ts
@bbj-vscode/src/language/validations/check-classes.ts
@bbj-vscode/src/language/bbj.langium
@bbj-vscode/src/language/generated/ast.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Grammar update for DECLARE AUTO property</name>
  <files>bbj-vscode/src/language/bbj.langium</files>
  <action>
Modify the VariableDecl grammar rule (line 297-298) to capture the `auto` keyword as a boolean property:

Change from:
```
VariableDecl returns VariableDecl:
    'declare' 'auto'? type=QualifiedClass (array?='[' ']')? name=FeatureName;
```

To:
```
VariableDecl returns VariableDecl:
    'declare' auto?='auto'? type=QualifiedClass (array?='[' ']')? name=FeatureName;
```

Then regenerate the Langium AST types by running `npm run langium:generate` from the `bbj-vscode` directory.

Verify the generated `ast.ts` now includes `auto: boolean` on the VariableDecl interface.

IMPORTANT: Do NOT modify any other grammar rules. Only the VariableDecl rule at line 297 needs the change.
  </action>
  <verify>
Run `npm run langium:generate` in `bbj-vscode/` -- should succeed without errors.
Grep `bbj-vscode/src/language/generated/ast.ts` for `auto` in the VariableDecl interface -- should find a boolean property.
Run `npm run build` in `bbj-vscode/` to verify no type errors.
  </verify>
  <done>The VariableDecl AST interface has an `auto: boolean` property. `npm run build` passes.</done>
</task>

<task type="auto">
  <name>Task 2: Create variable scoping validation and register checks</name>
  <files>
    bbj-vscode/src/language/validations/check-variable-scoping.ts
    bbj-vscode/src/language/bbj-validator.ts
  </files>
  <action>
Create `bbj-vscode/src/language/validations/check-variable-scoping.ts` with two validation functions:

**1. `checkUseBeforeAssignment(node: Program | MethodDecl, accept: ValidationAcceptor)`**

Algorithm (two-pass):

Pass 1 -- Build declaration position map:
- Walk the `statements` array (for Program) or `body` array (for MethodDecl) in source order.
- For each statement, record the FIRST assignment position (line number from `$cstNode.range.start.line`) for each variable name (case-insensitive via `.toLowerCase()`).
- Handle these statement types as "declaring" a variable:
  - `LetStatement`: each `assignments[i]` where `isSymbolRef(assignment.variable)` -> record `assignment.variable.symbol.$refText`
  - `ArrayDeclarationStatement`: each `items[i]` -> record `item.name`
  - `DreadStatement`: each `items[i]` where `isSymbolRef(item)` -> record `item.symbol.$refText`. Also handle `isArrayElement(item)` -> extract receiver variable name.
  - `ForStatement`: `init` is an Assignment -> record variable name from `init.variable`
  - Plain assignment (ExpressionStatement that is an Assignment): record variable name
  - `ReadStatement` / `EnterStatement`: their `items` / `variables` where `isInputVariable` and `isSymbolRef` -> record variable name
- MUST recurse into `CompoundStatement.statements` (`;`-separated lines)
- Do NOT record VariableDecl (DECLARE) -- those have whole-scope visibility and are exempt
- For MethodDecl: also record all `params[i].name` at position -1 (always "before" any usage)

Pass 2 -- Check all SymbolRef usages:
- Walk ALL contents of the node using `AstUtils.streamAllContents(node)`
- For each `isSymbolRef(node)`:
  - Get the usage line: `node.$cstNode?.range.start.line`
  - Get the variable name: `node.symbol.$refText?.toLowerCase()`
  - Skip if `node.symbol.ref` is undefined (unresolved reference -- linking warning handles it)
  - Skip if `node.symbol.ref` is a `VariableDecl` (DECLARE has whole-scope visibility)
  - Skip if `node.symbol.ref` is a `FieldDecl` with `$container` that `isBbjClass` (class field, not local)
  - Skip if `node.symbol.ref` is a `ParameterDecl` (method params always visible)
  - Skip if the SymbolRef is inside a LetStatement/ForStatement/DreadStatement as the LHS target of an assignment (the variable being assigned to, not being read)
  - Skip if the variable name is not in the declaration map at all (it may be a global/library/imported symbol)
  - If usage line < declaration line: emit hint diagnostic
    - Message: `'${originalName}' used before assignment (first assigned at line ${declLine + 1})`
    - Severity: `'hint'`
    - Target node: the SymbolRef's `$container` (the containing expression/statement)

**2. `checkConflictingDeclares(node: Program | MethodDecl, accept: ValidationAcceptor)`**

- Collect all `VariableDecl` nodes within the scope (direct children in statements/body, recurse into CompoundStatement)
- Group by variable name (case-insensitive `.toLowerCase()`)
- For groups with 2+ entries: compare types using `getFQNFullname(decl.type)`
- If types differ: emit error on the second (and subsequent) DECLARE
  - Message: `Conflicting DECLARE for '${decl.name}': type '${thisType}' conflicts with '${firstType}' (declared at line ${firstLine + 1})`
  - Severity: `'error'`
  - Target node: the conflicting VariableDecl

**3. Export a `registerVariableScopingChecks(registry: ValidationRegistry)` function**

Follow the pattern from `check-classes.ts`:
```typescript
export function registerVariableScopingChecks(registry: ValidationRegistry): void {
    const checks: ValidationChecks<BBjAstType> = {
        Program: (program, accept) => {
            checkUseBeforeAssignment(program, accept);
            checkConflictingDeclares(program, accept);
        },
        MethodDecl: (method, accept) => {
            checkUseBeforeAssignment(method, accept);
            checkConflictingDeclares(method, accept);
        },
    };
    registry.register(checks);
}
```

**Imports needed:**
- From `langium`: `AstUtils`, `ValidationAcceptor`, `ValidationChecks`, `ValidationRegistry`
- From `../generated/ast.js`: `BBjAstType`, `Program`, `MethodDecl`, `VariableDecl`, `isLetStatement`, `isArrayDeclarationStatement`, `isDreadStatement`, `isForStatement`, `isSymbolRef`, `isVariableDecl`, `isInputVariable`, `isReadStatement`, `isEnterStatement`, `isFieldDecl`, `isBbjClass`, `isMethodDecl`, `isProgram`, `isArrayElement`, `isParameterDecl`, `CompoundStatement`, `isAssignment`
- From `../bbj-nodedescription-provider.js`: `getFQNFullname`

**Wire into bbj-validator.ts:**
- Import `registerVariableScopingChecks` from `./validations/check-variable-scoping.js`
- In the `registerValidationChecks` function, add a call: `registerVariableScopingChecks(registry);` (after `registerClassChecks(registry);`)

**Key implementation notes:**
- BBj is case-insensitive for variable names. Always compare with `.toLowerCase()`.
- Line numbers from `$cstNode.range.start.line` are 0-based. Add 1 for display in messages.
- Use `$cstNode?.range.start.line` with optional chaining -- nodes without CST info should be skipped.
- CompoundStatement nesting: when walking statements, if `node.$type === CompoundStatement.$type`, recurse into `node.statements`.
- For the SymbolRef skip logic: check if the SymbolRef is the LHS of an assignment by checking `isAssignment(node.$container) && node.$container.variable === node`.
- The scope for Program is `program.statements`. For MethodDecl it is `method.body`.
- Do NOT traverse into nested MethodDecl or BbjClass bodies from a Program-level check -- each scope is independent.
- Do NOT traverse into DefFunction bodies from Program-level -- those have their own scope.
  </action>
  <verify>
Run `npm run build` in `bbj-vscode/` -- should compile without errors.
Run `npx vitest run` from the project root -- existing tests should still pass (no regressions).
  </verify>
  <done>
The validation file exists at `bbj-vscode/src/language/validations/check-variable-scoping.ts`. It is imported and registered in `bbj-validator.ts`. The build passes. All existing tests pass without regressions.
  </done>
</task>

</tasks>

<verification>
1. `npm run langium:generate` in `bbj-vscode/` succeeds
2. `npm run build` in `bbj-vscode/` succeeds with no type errors
3. `npx vitest run` from project root -- all existing tests pass (18 known pre-existing failures are acceptable)
4. Grep for `registerVariableScopingChecks` in `bbj-validator.ts` confirms wiring
5. Grep for `auto` in generated `ast.ts` confirms VariableDecl has the boolean property
</verification>

<success_criteria>
- Grammar updated: VariableDecl has `auto?='auto'?` and generated AST reflects it
- Validation file created with checkUseBeforeAssignment and checkConflictingDeclares
- Checks registered for both Program and MethodDecl AST types
- Build passes, no test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/28-variable-scoping-declaration-order/28-01-SUMMARY.md`
</output>
