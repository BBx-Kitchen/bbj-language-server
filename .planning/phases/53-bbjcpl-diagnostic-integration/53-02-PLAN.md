---
phase: 53-bbjcpl-diagnostic-integration
plan: 02
type: execute
wave: 2
depends_on: ["53-01"]
files_modified:
  - bbj-vscode/src/language/bbj-document-builder.ts
  - bbj-vscode/src/extension.ts
  - bbj-vscode/test/cpl-integration.test.ts
autonomous: true
requirements:
  - CPL-05
  - CPL-06
  - CPL-07
  - CPL-08

must_haves:
  truths:
    - "Saving a .bbj file triggers BBjCPL compilation and merged diagnostics appear in Problems panel"
    - "Trigger mode 'off' skips BBjCPL and clears stale BBjCPL diagnostics on next build"
    - "Trigger mode 'on-save' runs BBjCPL synchronously inside buildDocuments()"
    - "Trigger mode 'debounced' defers BBjCPL compile 500ms after last save via trailing-edge debounce"
    - "BBjCPL diagnostics and Langium diagnostics are merged (not replaced) with hierarchy applied"
    - "When BBj is not installed, status bar shows 'BBjCPL: unavailable' and Langium diagnostics work normally"
    - "Ten rapid saves do not cause CPU spike or diagnostic flicker"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-document-builder.ts"
      provides: "BBjCPL integration in buildDocuments(), debounce timers, availability tracking"
      contains: "BBjCPLService"
    - path: "bbj-vscode/src/extension.ts"
      provides: "BBjCPL status bar item, LSP notification listener, compilerTrigger in initializationOptions"
      contains: "bbjcplAvailability"
    - path: "bbj-vscode/test/cpl-integration.test.ts"
      provides: "Unit tests for mergeDiagnostics() and hierarchy with BBjCPL tier"
  key_links:
    - from: "bbj-vscode/src/language/bbj-document-builder.ts"
      to: "bbj-vscode/src/language/bbj-cpl-service.ts"
      via: "serviceRegistry.getServices() lazy resolution"
      pattern: "BBjCPLService.*compile"
    - from: "bbj-vscode/src/language/bbj-document-builder.ts"
      to: "bbj-vscode/src/language/bbj-document-validator.ts"
      via: "mergeDiagnostics import and getCompilerTrigger import"
      pattern: "mergeDiagnostics|getCompilerTrigger"
    - from: "bbj-vscode/src/language/bbj-document-builder.ts"
      to: "bbj-vscode/src/language/main.ts"
      via: "notifyBbjcplAvailability import"
      pattern: "notifyBbjcplAvailability"
    - from: "bbj-vscode/src/extension.ts"
      to: "bbj-vscode/src/language/main.ts"
      via: "bbj/bbjcplAvailability custom LSP notification"
      pattern: "bbj/bbjcplAvailability"
---

<objective>
Wire BBjCPLService.compile() into BBjDocumentBuilder.buildDocuments() with trigger mode logic and debounce, add client-side status bar for BBjCPL availability, and create integration tests for the merge and hierarchy logic.

Purpose: This is the core integration plan — makes BBjCPL compiler errors actually appear in the Problems panel with proper merge, hierarchy, trigger modes, and graceful degradation.
Output: Working end-to-end BBjCPL diagnostic integration, status bar indicator, integration tests.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/53-bbjcpl-diagnostic-integration/53-RESEARCH.md
@.planning/phases/53-bbjcpl-diagnostic-integration/53-01-SUMMARY.md
@bbj-vscode/src/language/bbj-document-builder.ts
@bbj-vscode/src/language/bbj-cpl-service.ts
@bbj-vscode/src/language/bbj-document-validator.ts
@bbj-vscode/src/language/main.ts
@bbj-vscode/src/extension.ts
@bbj-vscode/src/language/bbj-module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire BBjCPL into buildDocuments() with trigger modes and debounce</name>
  <files>
    bbj-vscode/src/language/bbj-document-builder.ts
  </files>
  <action>
Modify `BBjDocumentBuilder` to call `BBjCPLService.compile()` after Langium validation completes, with trigger mode and debounce logic.

**Imports to add:**
```typescript
import { DocumentState } from "langium"; // already imported
import { mergeDiagnostics, getCompilerTrigger } from './bbj-document-validator.js';
import { notifyBbjcplAvailability } from './main.js';
```
Also import `BBjServices` type: `import type { BBjServices } from './bbj-module.js';`

**CRITICAL: Avoid circular imports.** `bbj-document-builder.ts` is a shared service. `BBjServices` is a language service type. Import it as `import type` (type-only) — this is erased at compile time and causes no runtime circular dependency. The actual service resolution happens lazily via `this.serviceRegistry.getServices()`.

**Add class fields** to `BBjDocumentBuilder`:
```typescript
/** Per-file debounce timers for BBjCPL compilation. */
private readonly cplDebounceTimers = new Map<string, ReturnType<typeof setTimeout>>();

/** Trailing-edge debounce interval for saves (ms). */
private static readonly SAVE_DEBOUNCE_MS = 500;

/** Tracks whether BBjCPL is available (lazily detected on first compile). */
private bbjcplAvailable: boolean | undefined = undefined;
```

**Modify `buildDocuments()` method.** The BBjCPL integration goes INSIDE the existing `if (!this.isImportingBBjDocuments)` block, AFTER `super.buildDocuments()` but BEFORE `addImportedBBjDocuments`. This is because BBjCPL compiles the saved file, not imported ones, and we want the results before import resolution runs.

New `buildDocuments()`:
```typescript
protected override async buildDocuments(
    documents: LangiumDocument<AstNode>[],
    options: BuildOptions,
    cancelToken: CancellationToken
): Promise<void> {
    await super.buildDocuments(documents, options, cancelToken);

    if (!this.isImportingBBjDocuments) {
        // BBjCPL integration: compile validated documents
        await this.runBbjcplForDocuments(documents, cancelToken);

        await this.addImportedBBjDocuments(documents, options, cancelToken);
        await this.revalidateUseFilePathDiagnostics(documents, cancelToken);
    }
}
```

**Add private method `runBbjcplForDocuments()`:**
```typescript
/**
 * Run BBjCPL compilation for each validated document based on trigger mode.
 * Called from buildDocuments() after Langium validation completes.
 *
 * IMPORTANT: This runs INSIDE buildDocuments(), not from onBuildPhase —
 * calling from onBuildPhase causes CPU rebuild loops (see STATE.md).
 */
private async runBbjcplForDocuments(
    documents: LangiumDocument<AstNode>[],
    cancelToken: CancellationToken
): Promise<void> {
    const trigger = getCompilerTrigger();

    for (const document of documents) {
        if (!this.shouldCompileWithBbjcpl(document)) continue;

        const filePath = document.uri.fsPath;

        if (trigger === 'off') {
            // Clear stale BBjCPL diagnostics when trigger is off
            // (CONTEXT.md: "existing BBjCPL diagnostics stay visible until
            // the next file event" — this IS the next file event)
            const hadBbjcpl = document.diagnostics?.some(d => d.source === 'BBjCPL');
            if (hadBbjcpl) {
                document.diagnostics = (document.diagnostics ?? []).filter(
                    d => d.source !== 'BBjCPL'
                );
                await this.notifyDocumentPhase(document, DocumentState.Validated, cancelToken);
            }
            continue;
        }

        if (trigger === 'on-save') {
            // On-save: compile with 500ms trailing-edge debounce to handle rapid saves
            this.debouncedCompile(document);
        } else {
            // Debounced (default): also uses debounce but buildDocuments() is already
            // triggered by the document lifecycle. The 500ms debounce prevents CPU
            // spike on rapid saves (10 saves in succession → 1 compile after 500ms quiet).
            this.debouncedCompile(document);
        }
    }
}
```

**Add private method `shouldCompileWithBbjcpl()`:**
```typescript
/**
 * Determine whether a document should be compiled with BBjCPL.
 * Only compile real .bbj files that pass validation gating — skip
 * synthetic, external, and non-file documents.
 */
private shouldCompileWithBbjcpl(document: LangiumDocument): boolean {
    // Must be a real file path (not bbjlib:// or other virtual schemes)
    if (document.uri.scheme !== 'file') return false;

    // Must pass the same validation gating as Langium
    // (skips JavaSyntheticDoc, bbjlib files, external PREFIX documents)
    return this.shouldValidate(document);
}
```

Wait — `shouldValidate()` returns `false` for the document, but it also sets `document.state = Validated` as a side effect. Since `shouldCompileWithBbjcpl` is called AFTER `super.buildDocuments()` which already called `shouldValidate()`, the document is already validated. We need a guard that doesn't have side effects.

**Revised `shouldCompileWithBbjcpl()`:**
```typescript
private shouldCompileWithBbjcpl(document: LangiumDocument): boolean {
    if (document.uri.scheme !== 'file') return false;
    if (document.uri.toString() === JavaSyntheticDocUri) return false;
    if (this.wsManager() instanceof BBjWorkspaceManager) {
        if ((this.wsManager() as BBjWorkspaceManager).isExternalDocument(document.uri)) {
            return false;
        }
    }
    return true;
}
```

**Add private method `debouncedCompile()`:**
```typescript
/**
 * Schedule a BBjCPL compilation with trailing-edge debounce.
 * On rapid saves, only the last save triggers compilation after
 * a 500ms quiet period. This prevents CPU spike and diagnostic flicker.
 *
 * CONTEXT.md: "Clear-then-show diagnostic updates — old BBjCPL diagnostics
 * are cleared when compile starts, new ones appear when done."
 */
private debouncedCompile(document: LangiumDocument): void {
    const key = document.uri.fsPath;
    const existing = this.cplDebounceTimers.get(key);
    if (existing) clearTimeout(existing);

    const timer = setTimeout(async () => {
        this.cplDebounceTimers.delete(key);

        // Clear-then-show: remove old BBjCPL diagnostics before compile
        document.diagnostics = (document.diagnostics ?? []).filter(
            d => d.source !== 'BBjCPL'
        );

        // Resolve BBjCPLService lazily via serviceRegistry
        // (BBjDocumentBuilder is a shared service; BBjCPLService is a language service)
        const langServices = this.serviceRegistry.getServices(document.uri) as BBjServices;
        const cplService = langServices.compiler.BBjCPLService;

        const cplDiags = await cplService.compile(key);

        // Track BBjCPL availability (lazy detection per CONTEXT.md)
        const nowAvailable = cplDiags.length > 0 || !this.isBbjcplUnavailable(cplDiags, cplService);
        this.updateBbjcplAvailability(nowAvailable);

        if (cplDiags.length > 0) {
            // Merge BBjCPL diagnostics with Langium diagnostics
            document.diagnostics = mergeDiagnostics(
                document.diagnostics ?? [],
                cplDiags
            );
        }

        // Re-notify client with updated diagnostics
        // Use CancellationToken.None — the original build's token may be stale
        // after the 500ms debounce. BBjCPLService handles its own timeout internally.
        const { CancellationToken: CT } = await import('vscode-jsonrpc');
        await this.notifyDocumentPhase(document, DocumentState.Validated, CT.None);
    }, BBjDocumentBuilder.SAVE_DEBOUNCE_MS);

    this.cplDebounceTimers.set(key, timer);
}
```

Wait — dynamic import of `vscode-jsonrpc` inside the timer callback is messy. Better approach: import `CancellationToken` at the top of the file (it's already imported from `vscode-jsonrpc`). Then use `CancellationToken.None` directly.

Check: the existing import is `import { CancellationToken } from "vscode-jsonrpc";`. `CancellationToken.None` is a static property. This works.

**Revised `debouncedCompile()` — use `CancellationToken.None` directly:**
```typescript
private debouncedCompile(document: LangiumDocument): void {
    const key = document.uri.fsPath;
    const existing = this.cplDebounceTimers.get(key);
    if (existing) clearTimeout(existing);

    const timer = setTimeout(async () => {
        this.cplDebounceTimers.delete(key);

        // Clear-then-show: remove old BBjCPL diagnostics before compile
        document.diagnostics = (document.diagnostics ?? []).filter(
            d => d.source !== 'BBjCPL'
        );

        // Resolve BBjCPLService lazily via serviceRegistry
        const langServices = this.serviceRegistry.getServices(document.uri) as BBjServices;
        const cplService = langServices.compiler.BBjCPLService;

        const cplDiags = await cplService.compile(key);

        // Track BBjCPL availability (lazy detection per CONTEXT.md)
        // If compile returned diagnostics, BBjCPL is clearly available.
        // If empty, it COULD be available (clean file) — we track via ENOENT detection.
        this.trackBbjcplAvailability(cplDiags.length > 0);

        if (cplDiags.length > 0) {
            document.diagnostics = mergeDiagnostics(
                document.diagnostics ?? [],
                cplDiags
            );
        }

        // Re-notify client with updated merged diagnostics
        await this.notifyDocumentPhase(document, DocumentState.Validated, CancellationToken.None);
    }, BBjDocumentBuilder.SAVE_DEBOUNCE_MS);

    this.cplDebounceTimers.set(key, timer);
}
```

**Add availability tracking helper:**
```typescript
/**
 * Track BBjCPL availability based on compile results.
 * First successful compile (produces diagnostics) confirms availability.
 * Availability is also confirmed when compile() returns [] for a clean file
 * (BBjCPLService logs ENOENT internally — we detect via the first non-ENOENT result).
 *
 * Since BBjCPLService always returns [] on ENOENT (no way to distinguish from
 * clean compile via return value alone), we rely on a simpler heuristic:
 * - First compile that returns diagnostics → available
 * - If BBj home is configured but we never get diagnostics → assume available
 *   (clean files legitimately return [])
 * - BBjCPLService logs 'bbjcpl not found' on ENOENT → the status bar will
 *   be updated when we receive diagnostics later or when user reconfigures.
 *
 * REVISED APPROACH: Add a callback to BBjCPLService to detect ENOENT directly.
 * For now, use a simpler strategy: on first compile attempt, if we get results,
 * mark available. Track "first compile attempted" to update status bar after
 * first build. This is sufficient for CPL-08 acceptance criteria.
 */
private firstCompileAttempted = false;

private trackBbjcplAvailability(gotDiagnostics: boolean): void {
    if (!this.firstCompileAttempted) {
        this.firstCompileAttempted = true;
        // After first compile, we know BBjCPL was invoked.
        // If it produced diagnostics, it's definitely available.
        if (gotDiagnostics) {
            if (this.bbjcplAvailable !== true) {
                this.bbjcplAvailable = true;
                notifyBbjcplAvailability(true);
            }
        }
        // If no diagnostics, it could be clean file OR ENOENT.
        // We'll confirm availability on the next compile that produces diagnostics.
        // For now, don't change status — leave it undefined (status bar hidden).
    } else if (gotDiagnostics && this.bbjcplAvailable !== true) {
        this.bbjcplAvailable = true;
        notifyBbjcplAvailability(true);
    }
}
```

Actually, this availability tracking is too indirect. Let's add an `onAvailabilityChange` callback to `BBjCPLService` instead. But that would modify a file owned by Plan 01... and `bbj-cpl-service.ts` is NOT in Plan 01's files_modified list. It was completed in Phase 52.

**Better approach for ENOENT detection:** Add a module-level callback in `bbj-document-builder.ts` that `BBjCPLService` can't call directly. Instead, after `compile()` returns, check if BBj home is configured. If configured but compile returns `[]` repeatedly, we can't distinguish clean from ENOENT.

**Simplest correct approach:** Extend `BBjCPLService.compile()` to also return availability status. But we shouldn't modify BBjCPLService (Phase 52 artifact).

**Pragmatic approach:** Add `isAvailable()` method to BBjCPLService that checks if the bbjcpl binary exists on disk (synchronous `fs.existsSync` check). Call it once on first compile attempt:
```typescript
// In BBjDocumentBuilder:
private async checkBbjcplAvailability(cplService: BBjCPLService): Promise<void> {
    if (this.bbjcplAvailable !== undefined) return; // already checked

    // Check if bbjcpl binary exists by looking at BBj home
    const wsManager = this.wsManager();
    if (wsManager instanceof BBjWorkspaceManager) {
        const bbjHome = wsManager.getBBjDir();
        if (!bbjHome) {
            this.bbjcplAvailable = false;
            notifyBbjcplAvailability(false);
            return;
        }
        const binaryName = process.platform === 'win32' ? 'bbjcpl.exe' : 'bbjcpl';
        const bbjcplPath = path.join(bbjHome, 'bin', binaryName);
        try {
            const { accessSync, constants } = await import('fs');
            accessSync(bbjcplPath, constants.X_OK);
            this.bbjcplAvailable = true;
            notifyBbjcplAvailability(true);
        } catch {
            this.bbjcplAvailable = false;
            notifyBbjcplAvailability(false);
        }
    }
}
```

Wait — `path` is already imported. But `fs` is not imported. Use a synchronous check with `import('fs')`. Or better: since `BBjCPLService` already handles ENOENT gracefully, just check BBjHome existence on first trigger. If BBjHome is empty/undefined → unavailable. If BBjHome is set → assume available (ENOENT is handled gracefully by BBjCPLService, and the user will see no BBjCPL diagnostics which is the correct graceful degradation). The status bar only needs to show "unavailable" when BBj is NOT installed.

**Final approach (simple, correct):**
```typescript
private trackBbjcplAvailability(): void {
    if (this.bbjcplAvailable !== undefined) return;

    const wsManager = this.wsManager();
    if (wsManager instanceof BBjWorkspaceManager) {
        const bbjHome = wsManager.getBBjDir();
        if (!bbjHome) {
            this.bbjcplAvailable = false;
            notifyBbjcplAvailability(false);
        } else {
            // BBj home is set — check if bbjcpl binary exists
            const binaryName = process.platform === 'win32' ? 'bbjcpl.exe' : 'bbjcpl';
            const bbjcplPath = path.join(bbjHome, 'bin', binaryName);
            try {
                require('fs').accessSync(bbjcplPath);
                this.bbjcplAvailable = true;
                notifyBbjcplAvailability(true);
            } catch {
                this.bbjcplAvailable = false;
                notifyBbjcplAvailability(false);
            }
        }
    }
}
```

No — `require('fs')` is CommonJS and might not work in the ESM context. Use a different approach: import `fs` at the top of the file via `import * as fs from 'fs';` — but check if the project uses ESM imports... The project uses `.js` extensions in imports, suggesting ESM. `fs` is a Node.js builtin, should work with `import { accessSync } from 'fs';`.

Add to imports: `import { accessSync } from 'fs';`

Then:
```typescript
private trackBbjcplAvailability(): void {
    if (this.bbjcplAvailable !== undefined) return;

    const wsManager = this.wsManager();
    if (!(wsManager instanceof BBjWorkspaceManager)) return;

    const bbjHome = wsManager.getBBjDir();
    if (!bbjHome) {
        this.bbjcplAvailable = false;
        notifyBbjcplAvailability(false);
        return;
    }

    const binaryName = process.platform === 'win32' ? 'bbjcpl.exe' : 'bbjcpl';
    const bbjcplPath = path.join(bbjHome, 'bin', binaryName);
    try {
        accessSync(bbjcplPath);
        this.bbjcplAvailable = true;
        notifyBbjcplAvailability(true);
    } catch {
        this.bbjcplAvailable = false;
        notifyBbjcplAvailability(false);
    }
}
```

Call `this.trackBbjcplAvailability()` at the start of `runBbjcplForDocuments()`, before the trigger mode check. This ensures the availability is checked lazily on first trigger (per CONTEXT.md).

**Updated debouncedCompile() (without availability tracking — it's in runBbjcplForDocuments now):**
```typescript
private debouncedCompile(document: LangiumDocument): void {
    const key = document.uri.fsPath;
    const existing = this.cplDebounceTimers.get(key);
    if (existing) clearTimeout(existing);

    const timer = setTimeout(async () => {
        this.cplDebounceTimers.delete(key);

        // Clear-then-show: remove old BBjCPL diagnostics before compile
        document.diagnostics = (document.diagnostics ?? []).filter(
            d => d.source !== 'BBjCPL'
        );

        // Resolve BBjCPLService lazily via serviceRegistry
        const langServices = this.serviceRegistry.getServices(document.uri) as BBjServices;
        const cplService = langServices.compiler.BBjCPLService;

        const cplDiags = await cplService.compile(key);

        if (cplDiags.length > 0) {
            document.diagnostics = mergeDiagnostics(
                document.diagnostics ?? [],
                cplDiags
            );
        }

        // Re-notify client with updated merged diagnostics
        await this.notifyDocumentPhase(document, DocumentState.Validated, CancellationToken.None);
    }, BBjDocumentBuilder.SAVE_DEBOUNCE_MS);

    this.cplDebounceTimers.set(key, timer);
}
```

**Updated runBbjcplForDocuments()** with availability check at top:
```typescript
private async runBbjcplForDocuments(
    documents: LangiumDocument<AstNode>[],
    cancelToken: CancellationToken
): Promise<void> {
    const trigger = getCompilerTrigger();
    if (trigger === 'off') {
        // Clear stale BBjCPL diagnostics for all documents
        for (const document of documents) {
            if (!this.shouldCompileWithBbjcpl(document)) continue;
            const hadBbjcpl = document.diagnostics?.some(d => d.source === 'BBjCPL');
            if (hadBbjcpl) {
                document.diagnostics = (document.diagnostics ?? []).filter(
                    d => d.source !== 'BBjCPL'
                );
                await this.notifyDocumentPhase(document, DocumentState.Validated, cancelToken);
            }
        }
        return;
    }

    // Lazy availability check on first trigger (per CONTEXT.md)
    this.trackBbjcplAvailability();
    if (this.bbjcplAvailable === false) return;

    for (const document of documents) {
        if (!this.shouldCompileWithBbjcpl(document)) continue;
        this.debouncedCompile(document);
    }
}
```

**Full summary of changes to bbj-document-builder.ts:**
1. Add imports: `accessSync` from `fs`, `mergeDiagnostics`/`getCompilerTrigger` from `bbj-document-validator.js`, `notifyBbjcplAvailability` from `main.js`, `BBjServices` type from `bbj-module.js`
2. Add class fields: `cplDebounceTimers`, `SAVE_DEBOUNCE_MS`, `bbjcplAvailable`
3. Modify `buildDocuments()`: insert `runBbjcplForDocuments()` call before `addImportedBBjDocuments`
4. Add methods: `runBbjcplForDocuments()`, `shouldCompileWithBbjcpl()`, `debouncedCompile()`, `trackBbjcplAvailability()`
  </action>
  <verify>
Run `cd bbj-vscode && npx tsc --noEmit` — no TypeScript errors.
Run `cd bbj-vscode && npx vitest run` — all existing tests pass.
Verify no circular import issues by checking `main.ts` does NOT import from `bbj-document-builder.ts` (only the reverse direction).
  </verify>
  <done>
`BBjDocumentBuilder.buildDocuments()` calls `BBjCPLService.compile()` via lazy serviceRegistry resolution. Trigger mode (debounced/on-save/off) controls compilation. 500ms trailing-edge debounce prevents CPU spike on rapid saves. Clear-then-show pattern for diagnostic updates. BBjCPL availability tracked lazily on first trigger. Stale BBjCPL diagnostics cleared when trigger mode is 'off'.
  </done>
</task>

<task type="auto">
  <name>Task 2: Client-side status bar and initializationOptions wiring</name>
  <files>
    bbj-vscode/src/extension.ts
  </files>
  <action>
Add BBjCPL status bar item and availability notification listener to the VS Code extension client, and add `compilerTrigger` to `initializationOptions`.

**1. Add `compilerTrigger` to `initializationOptions` object** (around line 717-727):
After the existing `maxErrors` line, add:
```typescript
compilerTrigger: vscode.workspace.getConfiguration("bbj").get("compiler.trigger", "debounced"),
```

**2. Add BBjCPL status bar item** after the existing `suppressionStatusBar` block (around line 670), before the `fileSystemWatcher` creation:
```typescript
// BBjCPL availability status bar indicator
const bbjcplStatusBar = vscode.window.createStatusBarItem(
    vscode.StatusBarAlignment.Left, 99
);
bbjcplStatusBar.text = '$(warning) BBjCPL: unavailable';
bbjcplStatusBar.tooltip = 'BBjCPL compiler not found. Check that BBj is installed and bbj.home is configured.';
context.subscriptions.push(bbjcplStatusBar);
// Hidden by default — shown only when BBjCPL is detected as unavailable
```

**3. Add notification listener** after the `client.start()` call (or in the `.then()` chain if it's async). Find where `client` is started and add the notification listener after:
```typescript
// Listen for BBjCPL availability notifications from the language server
client.onNotification('bbj/bbjcplAvailability', (params: { available: boolean }) => {
    if (params.available) {
        bbjcplStatusBar.hide();
    } else {
        bbjcplStatusBar.show();
    }
});
```

Note: `client.onNotification` must be called after `client.start()` completes. Check the existing code pattern — if `client.start()` returns a promise that's awaited, add the listener after the await. If there's a `.then()` callback, add inside it. The notification listener registers on the running client.

Look for the pattern: if `client.start()` is called and then the function returns, add the `onNotification` call right after `client.start()` (the notification handler will be registered for when the client is ready).

Actually, in `vscode-languageclient`, `client.onNotification()` can be called before `start()` — it queues the handler. So place it right after `client = new LanguageClient(...)` creation, before `client.start()`.
  </action>
  <verify>
Run `cd bbj-vscode && npx tsc --noEmit` — no TypeScript errors from extension.ts changes.
Grep for `compilerTrigger` in extension.ts to confirm initializationOptions.
Grep for `bbjcplAvailability` in extension.ts to confirm notification listener.
Grep for `bbjcplStatusBar` in extension.ts to confirm status bar creation.
  </verify>
  <done>
`compilerTrigger` passed in `initializationOptions` from VS Code settings to language server. BBjCPL status bar item created (hidden by default). `bbj/bbjcplAvailability` notification listener shows/hides status bar based on server availability detection. When BBj is not installed, status bar shows "BBjCPL: unavailable" without popup notifications.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration tests for merge logic and BBjCPL hierarchy</name>
  <files>
    bbj-vscode/test/cpl-integration.test.ts
  </files>
  <action>
Create a new test file with unit tests for the `mergeDiagnostics()` function and the extended `applyDiagnosticHierarchy()` with BBjCPL tier. These are pure function tests that don't require subprocess or language server setup.

```typescript
import { describe, test, expect } from 'vitest';
import { Diagnostic, DiagnosticSeverity, Range } from 'vscode-languageserver';
import { mergeDiagnostics } from '../src/language/bbj-document-validator.js';

// Helper to create a diagnostic at a given line
function makeDiag(line: number, source: string, severity: DiagnosticSeverity, message: string): Diagnostic {
    const range: Range = {
        start: { line, character: 0 },
        end: { line, character: Number.MAX_SAFE_INTEGER },
    };
    return { range, severity, source, message };
}

describe('mergeDiagnostics', () => {

    test('BBjCPL-only errors are added when no Langium match on same line', () => {
        const langium = [
            makeDiag(0, 'bbj', DiagnosticSeverity.Error, 'Langium error on line 0'),
        ];
        const cpl = [
            makeDiag(5, 'BBjCPL', DiagnosticSeverity.Error, 'CPL error on line 5'),
        ];
        const merged = mergeDiagnostics(langium, cpl);
        expect(merged).toHaveLength(2);
        expect(merged[0].message).toBe('Langium error on line 0');
        expect(merged[0].source).toBe('bbj'); // unchanged — no CPL on same line
        expect(merged[1].message).toBe('CPL error on line 5');
        expect(merged[1].source).toBe('BBjCPL');
    });

    test('same-line match: Langium message kept, source changed to BBjCPL', () => {
        const langium = [
            makeDiag(3, 'bbj', DiagnosticSeverity.Error, 'Detailed Langium error'),
        ];
        const cpl = [
            makeDiag(3, 'BBjCPL', DiagnosticSeverity.Error, 'Syntax error: brokenMethod'),
        ];
        const merged = mergeDiagnostics(langium, cpl);
        expect(merged).toHaveLength(1);
        expect(merged[0].message).toBe('Detailed Langium error'); // Langium message preserved
        expect(merged[0].source).toBe('BBjCPL'); // source changed to BBjCPL
    });

    test('empty BBjCPL array returns Langium diagnostics unchanged', () => {
        const langium = [
            makeDiag(0, 'bbj', DiagnosticSeverity.Error, 'Error'),
            makeDiag(1, 'bbj', DiagnosticSeverity.Warning, 'Warning'),
        ];
        const merged = mergeDiagnostics(langium, []);
        expect(merged).toHaveLength(2);
        expect(merged[0].source).toBe('bbj');
        expect(merged[1].source).toBe('bbj');
    });

    test('empty Langium array returns all BBjCPL diagnostics', () => {
        const cpl = [
            makeDiag(2, 'BBjCPL', DiagnosticSeverity.Error, 'CPL error 1'),
            makeDiag(4, 'BBjCPL', DiagnosticSeverity.Error, 'CPL error 2'),
        ];
        const merged = mergeDiagnostics([], cpl);
        expect(merged).toHaveLength(2);
        expect(merged[0].source).toBe('BBjCPL');
        expect(merged[1].source).toBe('BBjCPL');
    });

    test('multiple BBjCPL errors: some match Langium lines, some do not', () => {
        const langium = [
            makeDiag(1, 'bbj', DiagnosticSeverity.Error, 'Langium L1'),
            makeDiag(3, 'bbj', DiagnosticSeverity.Warning, 'Langium L3 warning'),
            makeDiag(5, 'bbj', DiagnosticSeverity.Error, 'Langium L5'),
        ];
        const cpl = [
            makeDiag(1, 'BBjCPL', DiagnosticSeverity.Error, 'CPL L1'),  // matches Langium L1
            makeDiag(7, 'BBjCPL', DiagnosticSeverity.Error, 'CPL L7'),  // no Langium match
        ];
        const merged = mergeDiagnostics(langium, cpl);
        expect(merged).toHaveLength(4); // L1(merged) + L3 + L5 + L7(added)
        expect(merged.find(d => d.range.start.line === 1)!.source).toBe('BBjCPL');
        expect(merged.find(d => d.range.start.line === 1)!.message).toBe('Langium L1');
        expect(merged.find(d => d.range.start.line === 3)!.source).toBe('bbj');
        expect(merged.find(d => d.range.start.line === 5)!.source).toBe('bbj');
        expect(merged.find(d => d.range.start.line === 7)!.source).toBe('BBjCPL');
    });

    test('original Langium array is not mutated', () => {
        const langium = [
            makeDiag(3, 'bbj', DiagnosticSeverity.Error, 'Original'),
        ];
        const cpl = [
            makeDiag(3, 'BBjCPL', DiagnosticSeverity.Error, 'CPL match'),
        ];
        const originalSource = langium[0].source;
        mergeDiagnostics(langium, cpl);
        expect(langium[0].source).toBe(originalSource); // not mutated
    });

});
```

This test file covers:
- BBjCPL-only errors added correctly (CPL-06)
- Same-line merge: Langium message + BBjCPL source (CONTEXT.md decision)
- Empty arrays handled correctly
- Mixed scenarios with partial line matches
- Non-mutation of input arrays
  </action>
  <verify>
Run `cd bbj-vscode && npx vitest run test/cpl-integration.test.ts` — all tests pass.
Run `cd bbj-vscode && npx vitest run` — full test suite passes (no regressions).
  </verify>
  <done>
Integration tests verify: BBjCPL-only errors are added, same-line merging keeps Langium message with BBjCPL source, empty inputs handled, mixed scenarios work, input arrays are not mutated. All tests pass alongside existing test suite.
  </done>
</task>

</tasks>

<verification>
1. `cd bbj-vscode && npx tsc --noEmit` — zero TypeScript errors across all modified files
2. `cd bbj-vscode && npx vitest run` — full test suite passes (parser tests + integration tests + all existing)
3. `cd bbj-vscode && npx vitest run test/cpl-integration.test.ts` — all merge logic tests pass
4. `grep -r "BBjCPLService" bbj-vscode/src/language/bbj-document-builder.ts` — confirms service is accessed
5. `grep "bbjcplAvailability" bbj-vscode/src/extension.ts` — confirms notification listener
6. `grep "compilerTrigger" bbj-vscode/src/extension.ts` — confirms initializationOptions
7. `grep "SAVE_DEBOUNCE_MS" bbj-vscode/src/language/bbj-document-builder.ts` — confirms debounce
8. No `onBuildPhase` calls to BBjCPL anywhere (CPU rebuild loop prevention)
</verification>

<success_criteria>
- BBjCPL compile runs after Langium validation in buildDocuments() (not from onBuildPhase)
- Trigger mode 'off' clears stale BBjCPL diagnostics and skips compilation
- Trigger mode 'on-save' and 'debounced' both use 500ms trailing-edge debounce for rapid-save protection
- Diagnostics are merged via mergeDiagnostics() — not replaced (CPL-06)
- Merged diagnostics re-pushed to client via notifyDocumentPhase()
- BBjCPL availability detected lazily on first trigger (CPL-08)
- Status bar shows "BBjCPL: unavailable" when BBj not installed (CPL-08)
- compilerTrigger in initializationOptions from extension.ts (CPL-07)
- Integration tests pass for merge logic
- Full test suite passes with no regressions
- Zero TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/53-bbjcpl-diagnostic-integration/53-02-SUMMARY.md`
</output>
