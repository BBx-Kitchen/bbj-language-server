---
phase: 30-java-reflection-error-reporting
plan: 03
type: execute
wave: 2
depends_on: ["30-01"]
files_modified:
  - bbj-vscode/src/language/java-interop.ts
  - bbj-vscode/src/language/main.ts
  - bbj-vscode/src/extension.ts
  - bbj-vscode/package.json
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/actions/BbjRefreshJavaClassesAction.java
  - bbj-intellij/src/main/resources/META-INF/plugin.xml
autonomous: true

must_haves:
  truths:
    - "A 'Refresh Java Classes' command appears in the VS Code command palette under the BBj category"
    - "A 'Refresh Java Classes' action appears in IntelliJ's Tools menu"
    - "Executing the refresh command clears all cached Java class data and reloads from classpath"
    - "After refresh, all open documents are re-validated (diagnostics update)"
    - "A notification message 'Java classes refreshed' appears after re-scan completes"
    - "Changing classpath/config settings triggers a re-scan of the classpath"
  artifacts:
    - path: "bbj-vscode/src/language/java-interop.ts"
      provides: "clearCache() method for full invalidation of all cached Java class data"
    - path: "bbj-vscode/src/language/main.ts"
      provides: "bbj/refreshJavaClasses custom LSP request handler"
    - path: "bbj-vscode/src/extension.ts"
      provides: "bbj.refreshJavaClasses VS Code command registration"
    - path: "bbj-vscode/package.json"
      provides: "Command declaration for command palette"
    - path: "bbj-intellij/src/main/java/com/basis/bbj/intellij/actions/BbjRefreshJavaClassesAction.java"
      provides: "IntelliJ action for refreshing Java classes via LSP custom command"
    - path: "bbj-intellij/src/main/resources/META-INF/plugin.xml"
      provides: "IntelliJ action registration in Tools menu"
  key_links:
    - from: "bbj-vscode/src/extension.ts"
      to: "bbj-vscode/src/language/main.ts"
      via: "client.sendRequest('bbj/refreshJavaClasses')"
      pattern: "bbj/refreshJavaClasses"
    - from: "bbj-vscode/src/language/main.ts"
      to: "bbj-vscode/src/language/java-interop.ts"
      via: "javaInterop.clearCache() call"
      pattern: "clearCache"
    - from: "bbj-intellij/src/main/java/com/basis/bbj/intellij/actions/BbjRefreshJavaClassesAction.java"
      to: "bbj-vscode/src/language/main.ts"
      via: "LSP workspace/executeCommand request"
      pattern: "bbj/refreshJavaClasses"
---

<objective>
Add a "Refresh Java Classes" command accessible from both VS Code command palette and IntelliJ Tools menu. The command fully invalidates all cached Java class data, reloads the classpath, re-validates all open documents, and shows a notification upon completion. Also re-scan classpath when settings change.

Purpose: When users add new JARs to their classpath or update BBj, the language server's cached Java class data becomes stale. Currently there's no way to refresh without restarting the entire language server. This command provides a lightweight refresh mechanism.

Output: Working refresh command in both VS Code and IntelliJ with full cache invalidation and document re-validation.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-java-reflection-error-reporting/30-01-SUMMARY.md
@bbj-vscode/src/language/java-interop.ts
@bbj-vscode/src/language/main.ts
@bbj-vscode/src/extension.ts
@bbj-vscode/package.json
@bbj-vscode/src/language/bbj-ws-manager.ts
@bbj-vscode/src/language/bbj-module.ts
@bbj-intellij/src/main/java/com/basis/bbj/intellij/actions/BbjRunActionBase.java
@bbj-intellij/src/main/java/com/basis/bbj/intellij/lsp/BbjLanguageServerFactory.java
@bbj-intellij/src/main/resources/META-INF/plugin.xml
@.planning/phases/30-java-reflection-error-reporting/30-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add clearCache to JavaInteropService and server-side refresh handler</name>
  <files>
    bbj-vscode/src/language/java-interop.ts
    bbj-vscode/src/language/main.ts
  </files>
  <action>
**Part A: Add `clearCache()` method to `JavaInteropService`**

In `java-interop.ts`, add a public `clearCache()` method to `JavaInteropService` that performs full invalidation of all cached Java class data:

```typescript
/**
 * Clears all cached Java class data, disconnects the current connection,
 * and resets the classpath document. Call this before reloading classpath.
 */
public clearCache(): void {
    // Clear resolved classes cache
    this._resolvedClasses.clear();

    // Clear children-of-by-name map
    this.childrenOfByName.clear();

    // Clear java.lang.Object cache
    this.JAVA_LANG_OBJECT = undefined;

    // Reset classpath document arrays
    this.classpath.packages = [];
    this.classpath.classes = [];

    // Disconnect existing connection so a fresh one is created
    if (this.connection) {
        this.connection.dispose();
        this.connection = undefined;
    }

    console.log('Java interop cache cleared');
}
```

Note: `_resolvedClasses` is private — the `clearCache` method is on the same class so it can access it directly. `connection` is also private and accessible. `JAVA_LANG_OBJECT` is private. All accessible from within the class.

**Part B: Add custom LSP request handler in `main.ts`**

The current `main.ts` is minimal (just 19 lines). It needs to be extended to handle the custom `bbj/refreshJavaClasses` request. The challenge is that `main.ts` uses `startLanguageServer(shared)` which handles the connection internally. We need to access the connection and services.

The approach: Langium 4's `startLanguageServer` returns void and manages the connection internally. To add custom request handlers, we need to access the connection BEFORE calling startLanguageServer, or hook into it.

Looking at the code, `createConnection` is called at line 13, creating a `connection` variable. We can add our custom request handler on this connection before starting the language server.

Modify `main.ts`:

1. Import `RequestType` from `vscode-languageserver/node.js` (add to existing import)
2. Import `DocumentState` from `langium`
3. After `createBBjServices` but before `startLanguageServer`, add the custom request handler:

```typescript
import { startLanguageServer } from 'langium/lsp';
import { NodeFileSystem } from 'langium/node';
import { createConnection, ProposedFeatures, RequestType } from 'vscode-languageserver/node.js';
import { DocumentState } from 'langium';
import { createBBjServices } from './bbj-module.js';
import { BBjWorkspaceManager } from './bbj-ws-manager.js';

// Create a connection to the client
const connection = createConnection(ProposedFeatures.all);

// Inject the shared services and language-specific services
const { shared, BBj } = createBBjServices({ connection, ...NodeFileSystem });

// Custom request type for refreshing Java classes
const RefreshJavaClassesRequest = new RequestType<void, boolean, void>('bbj/refreshJavaClasses');

connection.onRequest(RefreshJavaClassesRequest, async () => {
    try {
        const javaInterop = BBj.java.JavaInteropService;

        // Step 1: Clear all cached Java class data
        javaInterop.clearCache();

        // Step 2: Reload classpath from workspace settings
        const wsManager = shared.workspace.WorkspaceManager as BBjWorkspaceManager;
        const settings = wsManager.getSettings();
        if (settings && settings.classpath.length > 0) {
            await javaInterop.loadClasspath(settings.classpath);
        }

        // Step 3: Reload implicit imports
        await javaInterop.loadImplicitImports();

        // Step 4: Re-validate all open documents by resetting their state
        const documents = shared.workspace.LangiumDocuments.all.toArray();
        for (const doc of documents) {
            // Only re-validate workspace documents, not synthetic ones
            if (doc.uri.scheme === 'file') {
                doc.state = DocumentState.Parsed; // Force re-link and re-validate
            }
        }
        const docUris = documents
            .filter(doc => doc.uri.scheme === 'file')
            .map(doc => doc.uri);
        if (docUris.length > 0) {
            await shared.workspace.DocumentBuilder.update(docUris, []);
        }

        // Step 5: Send notification
        connection.window.showInformationMessage('Java classes refreshed');

        return true;
    } catch (error) {
        console.error('Failed to refresh Java classes:', error);
        connection.window.showErrorMessage(`Failed to refresh Java classes: ${error}`);
        return false;
    }
});

// Start the language server with the shared services
startLanguageServer(shared);
```

Note: `createBBjServices` returns `{ shared, BBj }` — the destructuring now extracts `BBj` too. Check `bbj-module.ts` line 145-162 to confirm the return type.
  </action>
  <verify>
1. Run `cd /Users/beff/_workspace/bbj-language-server && npx vitest run` — all tests pass
2. Review: `clearCache()` resets all caches (resolvedClasses, childrenOfByName, JAVA_LANG_OBJECT, classpath arrays, connection)
3. Review: main.ts correctly destructures BBj services and registers custom request handler
4. Review: Refresh handler: clears cache → reloads classpath → reloads implicit imports → re-validates documents → sends notification
  </verify>
  <done>
JavaInteropService has clearCache() method. main.ts has bbj/refreshJavaClasses request handler that performs full cache invalidation, classpath reload, document re-validation, and user notification.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register VS Code command and IntelliJ action</name>
  <files>
    bbj-vscode/src/extension.ts
    bbj-vscode/package.json
    bbj-intellij/src/main/java/com/basis/bbj/intellij/actions/BbjRefreshJavaClassesAction.java
    bbj-intellij/src/main/resources/META-INF/plugin.xml
  </files>
  <action>
**Part A: VS Code command registration**

1. In `extension.ts`, add command registration in the `activate()` function (after line 340, alongside other command registrations):

```typescript
vscode.commands.registerCommand("bbj.refreshJavaClasses", async () => {
    if (!client) {
        vscode.window.showErrorMessage('BBj language server not running');
        return;
    }
    try {
        await client.sendRequest('bbj/refreshJavaClasses');
        // Server sends the notification, no need to show one here
    } catch (error) {
        vscode.window.showErrorMessage(`Failed to refresh Java classes: ${error}`);
    }
});
```

2. In `package.json`, add the command declaration to the `contributes.commands` array. Insert after the existing `bbj.showClasspathEntries` command entry (around line 125):

```json
{
  "category": "BBj",
  "command": "bbj.refreshJavaClasses",
  "title": "Refresh Java Classes"
}
```

**Part B: IntelliJ action**

1. Create a new file `BbjRefreshJavaClassesAction.java` in the `actions` directory following the pattern established by `BbjRunActionBase.java`. The refresh action should use LSP4IJ's API to send a custom command to the language server.

```java
package com.basis.bbj.intellij.actions;

import com.intellij.openapi.actionSystem.ActionUpdateThread;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.project.Project;
import com.redhat.devtools.lsp4ij.LanguageServerManager;
import org.jetbrains.annotations.NotNull;

/**
 * IntelliJ action that sends a custom LSP request to refresh all cached Java class data.
 * Registered in plugin.xml under the Tools menu.
 */
public class BbjRefreshJavaClassesAction extends AnAction {

    public BbjRefreshJavaClassesAction() {
        super("Refresh Java Classes", "Reload Java classpath and clear cached class information", null);
    }

    @Override
    public void actionPerformed(@NotNull AnActionEvent e) {
        Project project = e.getProject();
        if (project == null) return;

        // Use LSP4IJ's LanguageServerManager to send a custom request
        LanguageServerManager.getInstance(project)
            .getLanguageServer("bbjLanguageServer")
            .thenAccept(serverOpt -> {
                if (serverOpt.isPresent()) {
                    var server = serverOpt.get().getServer();
                    // Send custom request via the workspace service
                    org.eclipse.lsp4j.ExecuteCommandParams params =
                        new org.eclipse.lsp4j.ExecuteCommandParams(
                            "bbj/refreshJavaClasses",
                            java.util.Collections.emptyList()
                        );
                    server.getWorkspaceService().executeCommand(params);
                }
            });
    }

    @Override
    public void update(@NotNull AnActionEvent e) {
        // Always visible but only enabled when a project is open
        e.getPresentation().setEnabledAndVisible(e.getProject() != null);
    }

    @Override
    public @NotNull ActionUpdateThread getActionUpdateThread() {
        return ActionUpdateThread.BGT;
    }
}
```

**IMPORTANT:** The LSP4IJ API for sending custom requests may differ from the pattern above. Check the existing codebase patterns. The `BbjLanguageServerFactory` uses the server ID `"bbjLanguageServer"` (from plugin.xml). If `LanguageServerManager.getInstance(project).getLanguageServer()` doesn't exist in the LSP4IJ version used, use an alternative approach:

Alternative: Send the request as an `executeCommand` via the workspace service. Look at how LSP4IJ handles custom commands. The server ID is registered as `bbjLanguageServer` in plugin.xml (line 175-183).

If the LSP4IJ API doesn't support `getLanguageServer` by ID, use a simpler approach: register an `executeCommand` handler on the server side (in main.ts) that handles `bbj/refreshJavaClasses` as a workspace command, then use LSP4IJ's built-in command execution. This would mean changing the server-side handler from `connection.onRequest` to also registering as a workspace command.

2. In `plugin.xml`, add the action registration inside the `<actions>` section (after the `bbj.restartLanguageServer` action):

```xml
<action id="bbj.refreshJavaClasses"
        class="com.basis.bbj.intellij.actions.BbjRefreshJavaClassesAction"
        text="Refresh Java Classes"
        description="Reload Java classpath and clear cached class information">
    <add-to-group group-id="ToolsMenu" anchor="last"/>
</action>
```
  </action>
  <verify>
1. Run `cd /Users/beff/_workspace/bbj-language-server && npx vitest run` — all tests pass
2. Review: VS Code extension.ts registers bbj.refreshJavaClasses command
3. Review: package.json declares the command in contributes.commands
4. Review: IntelliJ BbjRefreshJavaClassesAction.java sends LSP request
5. Review: plugin.xml registers the action in Tools menu
  </verify>
  <done>
VS Code command "BBj: Refresh Java Classes" appears in command palette. IntelliJ action "Refresh Java Classes" appears in Tools menu. Both send the bbj/refreshJavaClasses request to the language server.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` — all existing tests pass
2. `grep -r "refreshJavaClasses" bbj-vscode/src/` returns matches in extension.ts and main.ts
3. `grep "refreshJavaClasses" bbj-vscode/package.json` returns the command declaration
4. `grep "refreshJavaClasses" bbj-intellij/src/main/resources/META-INF/plugin.xml` returns the action registration
5. IntelliJ action file exists at the expected path
</verification>

<success_criteria>
- "BBj: Refresh Java Classes" command appears in VS Code command palette (declared in package.json, registered in extension.ts)
- "Refresh Java Classes" action appears in IntelliJ Tools menu (declared in plugin.xml, implemented in BbjRefreshJavaClassesAction.java)
- Server-side handler in main.ts: clears cache, reloads classpath, reloads implicit imports, re-validates documents, sends notification
- JavaInteropService.clearCache() fully invalidates all caches (resolvedClasses, childrenOfByName, JAVA_LANG_OBJECT, classpath arrays, connection)
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/30-java-reflection-error-reporting/30-03-SUMMARY.md`
</output>
