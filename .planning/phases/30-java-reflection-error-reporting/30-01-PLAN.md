---
phase: 30-java-reflection-error-reporting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - java-interop/src/main/java/bbj/interop/InteropService.java
  - bbj-vscode/src/language/java-interop.ts
autonomous: true

must_haves:
  truths:
    - "Methods like setSlot() on BBjControl are returned by the Java interop service and appear as completion candidates"
    - "Existing Java class/method completion for standard BBj API classes continues working without regression"
    - "Debug logging is added to InteropService.java to help diagnose future missing-method issues"
  artifacts:
    - path: "java-interop/src/main/java/bbj/interop/InteropService.java"
      provides: "Java reflection that discovers all public methods including default interface methods"
    - path: "bbj-vscode/src/language/java-interop.ts"
      provides: "TypeScript-side class resolution that preserves all methods from Java backend"
  key_links:
    - from: "java-interop/src/main/java/bbj/interop/InteropService.java"
      to: "bbj-vscode/src/language/java-interop.ts"
      via: "JSON-RPC getClassInfo request/response"
      pattern: "getClassInfo"
---

<objective>
Investigate and fix why recently-added Java methods (e.g., `setSlot()` on BBjControl) are not discovered by the Java interop reflection service.

Purpose: Users cannot get autocomplete for methods like `setSlot()` that exist in modern BBj versions. The root cause is in method discovery — either the classpath doesn't include the right JARs, the reflection filtering is too aggressive, or default interface methods are being dropped somewhere in the pipeline.

Output: Working Java reflection that returns all public methods (including default interface methods) for BBj classes. Debug logging to aid future investigation.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@java-interop/src/main/java/bbj/interop/InteropService.java
@bbj-vscode/src/language/java-interop.ts
@.planning/phases/30-java-reflection-error-reporting/30-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Investigate and fix Java method discovery</name>
  <files>
    java-interop/src/main/java/bbj/interop/InteropService.java
    bbj-vscode/src/language/java-interop.ts
  </files>
  <action>
Investigate why `setSlot()` and similar recently-added methods are not returned by the Java interop service. The investigation has three stages:

**Stage 1: Verify the Java-side reflection**

In `InteropService.java`, the `loadClassInfo()` method (line 165) uses `clazz.getMethods()` which should return all public methods including default interface methods. Add diagnostic logging:

1. In `loadClassInfo()`, after the `methods` list is built (after line 188), add a log line that prints the total method count and class name:
   ```java
   System.out.println("ClassInfo: " + className + " has " + methods.size() + " methods, " + classInfo.fields.size() + " fields");
   ```

2. The `BbjClassLoader` (line 255) extends `URLClassLoader` with parent `ClassLoader.getPlatformClassLoader()`. The platform class loader does NOT include application-level JARs. If BBj's JAR files are loaded via `addUrl()` after initial construction, the classes should be available. But there may be a timing issue:
   - `getMethods()` traverses the class hierarchy. If BBjControl is an interface in one JAR but its parent interfaces are in a different JAR that hasn't been loaded yet, methods from unloaded parents will be missing.
   - Check the `loadClasspath()` method — when the classpath entry is a BBj classpath notation (e.g., `[bbj_default]`), it currently sends to the Java backend. Verify the Java backend resolves BBj classpath entries to actual JAR paths.

3. Check if `getProperTypeName()` (line 248) is dropping array types incorrectly — it strips array wrapper but uses `getComponentType().getCanonicalName()` which could return null for certain types. Add null check:
   ```java
   private String getProperTypeName(Class<?> clazz) {
       if (clazz.isArray()) {
           String name = clazz.getComponentType().getCanonicalName();
           return name != null ? name : clazz.getComponentType().getName();
       }
       String name = clazz.getCanonicalName();
       return name != null ? name : clazz.getName();
   }
   ```

**Stage 2: Check the classpath loading path**

The `loadClasspath()` method in InteropService.java walks directories for `*.jar` files. Check:
1. When entry ends with `/*`, it walks the directory and adds all `.jar` files. But it only handles `file:` URI prefix. BBj classpath notation like `[bbj_default]` is passed through from TypeScript side without resolution.
2. In `bbj-ws-manager.ts`, the classpath from VS Code settings is wrapped as `[classpathName]` (line 107). The Java backend needs to resolve this BBj classpath name to actual JAR paths.
3. If the Java backend doesn't know how to resolve `[bbj_default]`, the BBj-specific JARs won't be loaded, and `Class.forName("com.basis.bbj.proxies.sysgui.BBjControl")` will fail with ClassNotFoundException.

Verify that `loadClassByName()` can find `BBjControl` class. If not, the issue is classpath, not reflection.

**Stage 3: Fix the root cause**

Based on investigation findings, apply the appropriate fix:

- If classpath issue: The `BbjClassLoader` parent is `ClassLoader.getPlatformClassLoader()`. This is intentionally minimal. If the BBj JARs are loaded via `addUrl()` calls in `loadClasspath()`, classes should resolve. BUT `classPath = ClassPath.from(classLoader)` is called INSIDE the forEach loop (line 139), which rebuilds the classPath on each entry. This is correct but expensive. The key question is whether ALL JARs get added before any class resolution happens.

- If methods are present in Java but lost in TypeScript: Check `resolveClass()` in `java-interop.ts` — it iterates `javaClass.methods` (line 297) and resolves return types. If a method's return type resolution fails (throws), the catch block at line 320 swallows the error and continues. But the methods array should already be populated from the JSON-RPC response. Add a debug log in `resolveClass()` after receiving the class to print method count:
  ```typescript
  console.debug(`Resolving class ${className}: ${javaClass.methods?.length ?? 0} methods, ${javaClass.fields?.length ?? 0} fields`);
  ```

- If `getCanonicalName()` returns null for certain types (e.g., anonymous inner classes, local classes): The `getProperTypeName()` fix above handles this.

**IMPORTANT:** The Java source tree is available at `/Users/beff/svn/trunk/com` for reference but do NOT modify it. It's the BBj product source, not part of this project. Use it only to understand class hierarchies and method signatures.

**IMPORTANT:** After making changes to InteropService.java, you do NOT need to rebuild the Java interop service — the user will do that separately. Focus on getting the code right.
  </action>
  <verify>
1. Review the changes to InteropService.java — verify diagnostic logging is added, getProperTypeName has null safety, and any classpath fix is correct.
2. Review any changes to java-interop.ts — verify debug logging is present.
3. Run existing tests: `cd /Users/beff/_workspace/bbj-language-server && npx vitest run` — ensure no regressions.
  </verify>
  <done>
InteropService.java has diagnostic logging for method counts. getProperTypeName is null-safe. Any identified root cause for missing methods is fixed. Debug logging in TypeScript-side resolveClass. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` — all existing tests pass
2. Code review: InteropService.java changes are minimal and targeted
3. Code review: java-interop.ts changes don't break existing resolution flow
</verification>

<success_criteria>
- InteropService.java has diagnostic logging that shows method counts per class
- getProperTypeName is null-safe for edge cases
- Root cause of missing methods is identified and fixed (classpath resolution, reflection filtering, or TypeScript-side method loss)
- No regressions in existing Java class/method completion
</success_criteria>

<output>
After completion, create `.planning/phases/30-java-reflection-error-reporting/30-01-SUMMARY.md`
</output>
