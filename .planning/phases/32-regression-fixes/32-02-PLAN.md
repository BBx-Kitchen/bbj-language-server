---
phase: 32-regression-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/bbj-definition-provider.ts
  - bbj-vscode/src/language/bbj-module.ts
  - bbj-vscode/test/definition.test.ts
autonomous: true

must_haves:
  truths:
    - "Ctrl-click on class name in USE ::filename.bbj::ClassName navigates to the class declaration line"
    - "Navigation works when file is found via PREFIX paths"
    - "If the .bbj file cannot be found via PREFIX paths, no crash occurs"
    - "Existing navigation behavior for non-USE references is unchanged"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-definition-provider.ts"
      provides: "Custom DefinitionProvider with USE statement navigation"
      contains: "BBjDefinitionProvider"
    - path: "bbj-vscode/src/language/bbj-module.ts"
      provides: "Registration of custom DefinitionProvider"
      contains: "BBjDefinitionProvider"
    - path: "bbj-vscode/test/definition.test.ts"
      provides: "Tests for USE statement go-to-definition"
      contains: "USE.*navigate"
  key_links:
    - from: "bbj-vscode/src/language/bbj-definition-provider.ts"
      to: "bbj-vscode/src/language/bbj-module.ts"
      via: "service registration in lsp.DefinitionProvider"
      pattern: "DefinitionProvider.*BBjDefinitionProvider"
    - from: "bbj-vscode/src/language/bbj-definition-provider.ts"
      to: "Langium DefaultDefinitionProvider"
      via: "extends DefaultDefinitionProvider, overrides collectLocationLinks"
      pattern: "extends DefaultDefinitionProvider"
---

<objective>
Enable Ctrl-click on class name in USE statements to navigate to the class declaration in the target .bbj file.

Purpose: USE statement navigation (go-to-definition) broke in v3.1. Developers use `USE ::filename.bbj::ClassName` frequently and expect Ctrl-click on ClassName to jump directly to the class declaration. This is the REG-02 regression (#357).

Output: A custom `BBjDefinitionProvider` that enhances USE statement navigation to jump to the specific class declaration line (not just the file), registered in the DI module.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/32-regression-fixes/32-CONTEXT.md
@.planning/phases/32-regression-fixes/32-RESEARCH.md
@bbj-vscode/src/language/bbj-module.ts
@bbj-vscode/src/language/bbj-scope.ts
@bbj-vscode/node_modules/langium/src/lsp/definition-provider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BBjDefinitionProvider with USE statement navigation</name>
  <files>
    bbj-vscode/src/language/bbj-definition-provider.ts
    bbj-vscode/src/language/bbj-module.ts
  </files>
  <action>
**Create `bbj-vscode/src/language/bbj-definition-provider.ts`:**

Create a class `BBjDefinitionProvider` that extends Langium's `DefaultDefinitionProvider` (from `langium/lsp`).

The key insight: Langium's `DefaultDefinitionProvider.findLinks()` calls `this.references.findDeclarationNodes(source)` which resolves the reference through the linker. For a `USE ::filename.bbj::ClassName` statement, the `bbjClass` reference resolves to the BbjClass AST node in the target document. The default behavior then creates a LocationLink to that node's CST position, which SHOULD work.

The regression likely means the reference isn't resolving properly. Let's first check what actually happens. The `findLinks()` method at line 81-96 of Langium's definition-provider.ts iterates over `this.references.findDeclarationNodes(source)` and for each target, calls `getDocument(target.astNode)`.

Two potential issues:
1. The reference resolution for `bbjClass` might fail (can't find the file via PREFIX paths)
2. The target CST node might point to the wrong location

Override `collectLocationLinks` (NOT `findLinks`) to add USE-specific behavior. Here's the approach:

```typescript
import { AstUtils, CstNode, GrammarUtils } from 'langium';
import { LangiumServices } from 'langium/lsp';
import { DefaultDefinitionProvider, GoToLink } from 'langium/lsp';
import type { DefinitionParams } from 'vscode-languageserver';
import { LocationLink } from 'vscode-languageserver';
import type { MaybePromise } from 'langium';
import type { LangiumDocument } from 'langium';
import { isBbjClass, isUse } from './generated/ast.js';
```

Wait -- `DefaultDefinitionProvider` is exported from `langium/lsp`. Let me check the actual import path. Looking at the Langium source, `DefaultDefinitionProvider` and `GoToLink` are exported from `langium/lsp`. Check via:
- `import { DefaultDefinitionProvider } from 'langium/lsp';`
- If that doesn't work: `import { DefaultDefinitionProvider } from 'langium/lib/lsp/definition-provider.js';`

The class structure:

```typescript
import { AstUtils, CstNode } from 'langium';
import { DefaultDefinitionProvider, GoToLink } from 'langium/lsp';
import type { DefinitionParams } from 'vscode-languageserver';
import { LocationLink } from 'vscode-languageserver';
import { isBbjClass, isUse, type BbjClass } from './generated/ast.js';

export class BBjDefinitionProvider extends DefaultDefinitionProvider {

    protected override collectLocationLinks(sourceCstNode: CstNode, params: DefinitionParams): LocationLink[] | undefined {
        const goToLinks = this.findLinks(sourceCstNode);
        if (goToLinks.length === 0) {
            return undefined;
        }

        return goToLinks.map(link => {
            // For USE statements with BbjClass references, navigate to the class name declaration
            const targetNode = link.target.astNode;
            if (isBbjClass(targetNode)) {
                // Find the name node of the BbjClass (the class name in the declaration)
                const nameNode = this.nameProvider.getNameNode(targetNode);
                if (nameNode) {
                    return LocationLink.create(
                        link.targetDocument.textDocument.uri,
                        targetNode.$cstNode?.range ?? nameNode.range,
                        nameNode.range,
                        link.source.range
                    );
                }
            }

            // Default behavior for all other cases
            return LocationLink.create(
                link.targetDocument.textDocument.uri,
                (link.target.astNode.$cstNode ?? link.target).range,
                link.target.range,
                link.source.range
            );
        });
    }
}
```

The key enhancement: When the target is a BbjClass, we use `this.nameProvider.getNameNode(targetNode)` to find the class name's CST node, which gives us the exact line position. The `targetRange` (first range arg) covers the full class declaration, while `targetSelectionRange` (second range arg) highlights just the class name. This ensures the editor jumps to and highlights the class name line.

Note: `this.nameProvider` is already available from the parent class `DefaultDefinitionProvider` (it stores it in the constructor).

IMPORTANT: Verify the import path for `DefaultDefinitionProvider`. Check `bbj-vscode/node_modules/langium/lsp/index.d.ts` or similar to confirm it's exported from `langium/lsp`. If not, use the direct path `langium/lib/lsp/definition-provider.js`. Also verify `GoToLink` is exported.

If `GoToLink` is not exported from `langium/lsp`, you don't need it since we're overriding `collectLocationLinks` which receives the sourceCstNode, not GoToLink objects. The `findLinks` method is called internally.

**Register in `bbj-vscode/src/language/bbj-module.ts`:**

1. Import `BBjDefinitionProvider` from `./bbj-definition-provider.js`
2. Add to the `lsp` section of `BBjModule`:
   ```typescript
   lsp: {
       DefinitionProvider: (services) => new BBjDefinitionProvider(services),
       HoverProvider: (services) => new BBjHoverProvider(services),
       CompletionProvider: (services) => new BBjCompletionProvider(services),
       // ... existing entries
   },
   ```

IMPORTANT: The `LangiumServices` type from `langium/lsp` should have `lsp.DefinitionProvider` as a valid override slot. If TypeScript complains, check the `PartialLangiumServices` type definition -- `DefinitionProvider` should be in the `lsp` namespace.
  </action>
  <verify>
1. `cd bbj-vscode && npx tsc --noEmit` -- TypeScript compilation succeeds
2. `cd bbj-vscode && npm test` -- all existing tests pass (new provider delegates to default behavior for non-BbjClass targets)
  </verify>
  <done>
`BBjDefinitionProvider` exists in `bbj-vscode/src/language/bbj-definition-provider.ts`, extends `DefaultDefinitionProvider`, overrides `collectLocationLinks` to navigate to BbjClass name nodes for USE statement targets. Registered in `bbj-module.ts`. Existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add automated tests for USE statement definition navigation</name>
  <files>
    bbj-vscode/test/definition.test.ts
  </files>
  <action>
Create `bbj-vscode/test/definition.test.ts` with tests for the USE statement go-to-definition behavior.

The test approach: Use Langium's test utilities to create multi-document workspaces and invoke the DefinitionProvider programmatically.

Look at how `linking.test.ts` sets up services -- use the same pattern with `createBBjTestServices`. For definition testing, we need to:

1. Create services with `createBBjTestServices(EmptyFileSystem)`
2. Parse a document with a USE statement AND a target document with the class
3. Call the DefinitionProvider's `getDefinition` method
4. Assert the result LocationLinks point to the correct file and position

Here's the test structure:

```typescript
import { EmptyFileSystem, LangiumDocument } from 'langium';
import { parseHelper } from 'langium/test';
import { beforeAll, describe, expect, test } from 'vitest';
import { createBBjTestServices } from './bbj-test-module.js';
import { Model } from '../src/language/generated/ast.js';
import { initializeWorkspace } from './test-helper.js';

const services = createBBjTestServices(EmptyFileSystem);

describe('Definition Provider Tests', () => {

    beforeAll(async () => {
        await initializeWorkspace(services.shared);
    });

    test('Go to definition on BBjClass in USE statement navigates to class declaration', async () => {
        // Create the target document with a class definition
        const targetDoc = await parseHelper<Model>(services.BBj)(
            `class public MyWidget\n    field public MyWidget name!\nclassend`,
            { documentUri: 'file:///test/widgets.bbj' }
        );

        // Create the source document with a USE statement referencing the target
        // Note: USE ::filename.bbj::ClassName resolves via PREFIX paths + scope
        // In test, we parse directly so the class should be indexed
        const sourceDoc = await parseHelper<Model>(services.BBj)(
            `use ::widgets.bbj::MyWidget`,
            { documentUri: 'file:///test/main.bbj', validation: true }
        );

        // Get the DefinitionProvider
        const definitionProvider = services.BBj.lsp.DefinitionProvider;

        // Find the position of 'MyWidget' in the USE statement
        // USE ::widgets.bbj::MyWidget
        // The class name starts after '::widgets.bbj::'
        const text = sourceDoc.textDocument.getText();
        const classNameOffset = text.indexOf('MyWidget');
        const position = sourceDoc.textDocument.positionAt(classNameOffset);

        const result = await definitionProvider.getDefinition(sourceDoc, {
            textDocument: { uri: sourceDoc.textDocument.uri },
            position
        });

        // Verify navigation target exists
        expect(result).toBeDefined();
        expect(result!.length).toBeGreaterThan(0);

        // The target should be in widgets.bbj
        const link = result![0];
        expect(link.targetUri).toContain('widgets.bbj');

        // The target selection range should point to the class name 'MyWidget' in the declaration
        // 'class public MyWidget' -- MyWidget starts at column 13 (0-indexed)
        expect(link.targetSelectionRange.start.line).toBe(0); // First line of target doc
    });
```

IMPORTANT: The test might not work exactly as described because of how the scope resolves USE statements with file paths -- the scope provider uses PREFIX paths and file URI matching. In the test environment with EmptyFileSystem, file resolution may not work.

If the full integration test is too complex, create a simpler unit test that verifies the DefinitionProvider's override behavior by mocking or by testing the BbjClass name node resolution:

```typescript
test('DefinitionProvider is registered as BBjDefinitionProvider', () => {
    const provider = services.BBj.lsp.DefinitionProvider;
    expect(provider.constructor.name).toBe('BBjDefinitionProvider');
});
```

Also add a test with an inline BbjClass reference (not via USE file path) to verify navigation works for BbjClass targets within the same document:

```typescript
test('Go to definition on class reference navigates to class declaration', async () => {
    const doc = await parseHelper<Model>(services.BBj)(
        `class public MyClass\nclassend\n\nobj! = new MyClass()`,
        { documentUri: 'file:///test/inline.bbj', validation: true }
    );

    const definitionProvider = services.BBj.lsp.DefinitionProvider;
    // Position on 'MyClass' in 'new MyClass()'
    const text = doc.textDocument.getText();
    const newClassOffset = text.lastIndexOf('MyClass');
    const position = doc.textDocument.positionAt(newClassOffset);

    const result = await definitionProvider.getDefinition(doc, {
        textDocument: { uri: doc.textDocument.uri },
        position
    });

    expect(result).toBeDefined();
    if (result && result.length > 0) {
        // Should navigate to the class declaration on line 0
        expect(result[0].targetSelectionRange.start.line).toBe(0);
    }
});
```

Write tests that are pragmatic -- if the full USE file path resolution doesn't work in the test environment, focus on testing:
1. The BBjDefinitionProvider is registered correctly
2. For BbjClass targets within the same document, navigation goes to the class name node
3. Default navigation for non-BbjClass targets still works (e.g., variable references)

Do NOT make the tests fragile by depending on file system or PREFIX path resolution in the test env.
  </action>
  <verify>
Run `cd bbj-vscode && npx vitest run test/definition.test.ts` -- all new tests pass.
Run `cd bbj-vscode && npm test` -- full suite passes with no regressions.
  </verify>
  <done>
Test file `bbj-vscode/test/definition.test.ts` exists with tests verifying BBjDefinitionProvider registration and BbjClass navigation behavior. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cd bbj-vscode && npx tsc --noEmit` -- no TypeScript errors
2. `cd bbj-vscode && npx vitest run test/definition.test.ts` -- definition tests pass
3. `cd bbj-vscode && npm test` -- full suite passes
4. Grep for `BBjDefinitionProvider` in bbj-module.ts -- registered in lsp section
5. Grep for `extends DefaultDefinitionProvider` in bbj-definition-provider.ts -- confirms override pattern
</verification>

<success_criteria>
- BBjDefinitionProvider is registered and handles go-to-definition requests
- For BbjClass targets (from USE statements or constructors), navigation jumps to the class name line
- Default navigation behavior is preserved for all other reference types
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/32-regression-fixes/32-02-SUMMARY.md`
</output>
