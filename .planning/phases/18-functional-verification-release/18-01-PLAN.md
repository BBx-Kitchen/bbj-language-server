---
phase: 18-functional-verification-release
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/test/functional/chevrotain-tokens.test.ts
  - bbj-vscode/test/functional/lsp-features.test.ts
autonomous: true

must_haves:
  truths:
    - "All 7 Chevrotain false-positive tokens parse correctly in standalone and compound patterns"
    - "Completion provider returns BBj keywords and imported Java class names"
    - "Document symbols are generated for classes, methods, fields, and labels"
    - "Diagnostics report errors on invalid code and report clean on valid code"
    - "Hover provider returns content for BBj keywords and library functions"
    - "Go-to-definition resolves references correctly (verified by linking test coverage)"
    - "All new functional tests pass via npm test"
  artifacts:
    - path: "bbj-vscode/test/functional/chevrotain-tokens.test.ts"
      provides: "Runtime verification tests for 7 Chevrotain unreachable tokens"
      contains: "KEYWORD_STANDALONE"
    - path: "bbj-vscode/test/functional/lsp-features.test.ts"
      provides: "LSP feature verification tests for completion, document symbols, diagnostics, hover, go-to-definition"
      contains: "CompletionProvider"
  key_links:
    - from: "bbj-vscode/test/functional/chevrotain-tokens.test.ts"
      to: "bbj-vscode/src/language/bbj-module.ts"
      via: "createBBjServices(EmptyFileSystem)"
      pattern: "createBBjServices"
    - from: "bbj-vscode/test/functional/lsp-features.test.ts"
      to: "bbj-vscode/test/bbj-test-module.ts"
      via: "createBBjTestServices(EmptyFileSystem)"
      pattern: "createBBjTestServices"
---

<objective>
Write automated functional verification tests proving all 9 language server features work correctly after the Langium 4 upgrade. Critical focus: explicitly verify the 7 Chevrotain "unreachable" tokens (EXTRACT, DELETE, INPUT, ENTER, SAVE, READ, FIND) work at runtime in both standalone and compound statement patterns.

Purpose: Phase 17 identified that Chevrotain produces false-positive "unreachable token" warnings for 7 tokens. This plan provides definitive runtime proof that parsing is correct, plus verifies that LSP features (completion, document symbols, diagnostics, hover, go-to-definition) function properly -- covering FUNC-01 through FUNC-09.

Output: Two test files in bbj-vscode/test/functional/ that pass via `npm test`.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-functional-verification-release/18-CONTEXT.md
@.planning/phases/18-functional-verification-release/18-RESEARCH.md
@.planning/phases/17-build-verification-test-suite/17-02-SUMMARY.md

# Key source files for understanding test patterns
@bbj-vscode/test/parser.test.ts
@bbj-vscode/test/bbj-test-module.ts
@bbj-vscode/test/completion-test.test.ts
@bbj-vscode/test/document-symbol.test.ts
@bbj-vscode/test/linking.test.ts
@bbj-vscode/test/test-helper.ts

# LSP provider source files for understanding APIs
@bbj-vscode/src/language/bbj-hover.ts
@bbj-vscode/src/language/bbj-signature-help-provider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chevrotain token runtime verification tests</name>
  <files>bbj-vscode/test/functional/chevrotain-tokens.test.ts</files>
  <action>
Create `bbj-vscode/test/functional/chevrotain-tokens.test.ts` that proves all 7 Chevrotain false-positive tokens parse correctly at runtime.

Use the established test pattern from `parser.test.ts`:
- Import `createBBjServices` from `../../src/language/bbj-module.js` (use `.js` extension for ESM)
- Import `EmptyFileSystem` from `langium`
- Import `parseHelper` from `langium/test`
- Import `Model` from `../../src/language/generated/ast.js`
- Import `describe, test, expect, beforeAll` from `vitest`
- Create services with `createBBjServices(EmptyFileSystem)`
- Create parse helper with `parseHelper<Model>(services.BBj)`
- Call `beforeAll(() => services.shared.workspace.WorkspaceManager.initializeWorkspace([]))`

For EACH of the 7 tokens (READ, INPUT, ENTER, EXTRACT, DELETE, SAVE, FIND), write TWO test cases:

1. **Standalone pattern** (triggers KEYWORD_STANDALONE via `\s*(\r?\n|;|$)` lookahead):
   Tests that the token works when it appears alone on a line or before a newline/semicolon.

2. **Compound pattern** (triggers individual token):
   Tests that the token works in a compound statement with arguments.

Token-specific test patterns (use realistic BBj syntax from parser.test.ts examples):

- **READ**: Standalone `READ\nPRINT "done"` / Compound `READ(1,KEY="TEST")A$`
- **INPUT**: Standalone `INPUT\na = 9` / Compound `INPUT "Name:", name$`
- **ENTER**: Standalone `ENTER\nsomeVar$ = "TEST"` / Compound `ENTER someVar$, someOtherVar$`
- **EXTRACT**: Compound `EXTRACT(2,KEY="key")data$` (EXTRACT is primarily compound; test `EXTRACT RECORD(1)A$` for the secondary form)
- **DELETE**: Standalone `DELETE\n` / Compound `DELETE label1, label2`
- **SAVE**: Standalone `SAVE\n` / Compound `SAVE "file.txt"`
- **FIND**: Compound `FIND(1,KEY="key")data$` / Also test `FIND RECORD(1)A$`

Each test must assert:
```typescript
expect(doc.parseResult.lexerErrors).toHaveLength(0);
expect(doc.parseResult.parserErrors).toHaveLength(0);
```

Also add a combined test that uses ALL 7 tokens in a single program to prove they coexist without conflicts. Use the compound forms with channel arguments (e.g., `READ(1)A$`, `INPUT "prompt",x$`, etc.) since that is the most realistic usage.

Use `{ validation: true }` where the BBj code is syntactically valid enough for the validator (some standalone forms may need validation disabled if they trigger semantic errors -- use judgment from existing parser.test.ts patterns).

IMPORTANT: Follow the existing convention of defining `expectNoParserLexerErrors` as a local helper function (see parser.test.ts line 13-16).

Do NOT use `createBBjTestServices` -- use `createBBjServices` directly, matching parser.test.ts convention. The test module adds fake Java services we don't need here.
  </action>
  <verify>
Run: `cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npx vitest run test/functional/chevrotain-tokens.test.ts`

All tests pass with zero failures. Specifically: each of the 7 tokens has at least 2 passing tests (standalone + compound), plus the combined test passes.
  </verify>
  <done>14+ test cases pass proving all 7 Chevrotain false-positive tokens parse correctly in both standalone and compound patterns. Zero lexer errors, zero parser errors for all test cases.</done>
</task>

<task type="auto">
  <name>Task 2: Write LSP feature verification tests</name>
  <files>bbj-vscode/test/functional/lsp-features.test.ts</files>
  <action>
Create `bbj-vscode/test/functional/lsp-features.test.ts` that verifies the core LSP features work after the Langium 4 upgrade.

Use `createBBjTestServices` from `../bbj-test-module.js` (NOT `createBBjServices`) because we need the fake Java classes for completion testing. Follow the pattern from `document-symbol.test.ts` and `completion-test.test.ts`.

Setup:
```typescript
import { EmptyFileSystem, LangiumDocument } from 'langium';
import { parseHelper, expectCompletion } from 'langium/test';
import { beforeAll, describe, expect, test } from 'vitest';
import { DiagnosticSeverity } from 'vscode-languageserver';
import { Model } from '../../src/language/generated/ast.js';
import { createBBjTestServices } from '../bbj-test-module.js';
import { initializeWorkspace } from '../test-helper.js';

const services = createBBjTestServices(EmptyFileSystem);
const parse = parseHelper<Model>(services.BBj);
const completion = expectCompletion(services.BBj);
```

Write test suites covering these features (map to FUNC requirements):

**FUNC-02: Diagnostics** (2-3 tests)
- Parse valid BBj code with `{ validation: true }`, assert zero diagnostics with error severity
- Parse intentionally invalid code, assert diagnostics are produced (e.g., `VKEYED "MYFILE",10,80,1000,MODE="somemode"` produces MODE error -- see validation.test.ts)
- Use the `expectNoErrors` helper pattern from document-symbol.test.ts

**FUNC-03: Completion - BBj keywords** (1-2 tests)
- Use `expectCompletion` helper from langium/test (pattern from completion-test.test.ts)
- Test that typing a partial keyword produces completions
- Use the `<|>` cursor marker syntax that `expectCompletion` expects

**FUNC-04: Completion - Java classes** (1 test)
- Use `expectCompletion` with `use java.util.HashMap\nHash<|>` pattern (exactly like completion-test.test.ts)
- Assert `HashMap` appears in completions

**FUNC-05: Hover information** (1-2 tests)
- Parse a BBj program that uses a library function (e.g., `x = STR()`)
- Call the hover provider via `services.BBj.lsp.HoverProvider.getHoverContent(document, { textDocument: { uri: document.textDocument.uri }, position: { line: X, character: Y } })`
- Position the cursor over a known library function name (STR, UNT, etc.)
- Assert that the hover result is defined and contains content (not undefined/null)
- Read `bbj-hover.ts` to understand the exact API signature -- the provider may use `getHoverContent` or the standard Langium `getHoverInfo` method. Use whichever is available.
- If the hover provider API is not easily callable in tests (e.g., requires full LSP setup), verify FUNC-05 by confirming: (1) bbj-hover.ts exists and exports a hover provider class, (2) it is registered in bbj-module.ts, (3) linking.test.ts proves reference resolution works (hover depends on resolved references). Document this as "PASS - Verified by provider registration + reference resolution coverage in linking.test.ts".

**FUNC-07: Go-to-definition** (1-2 tests)
- Go-to-definition depends on reference resolution, which is already tested extensively by `linking.test.ts` (11 non-interop tests covering: library definitions, symbolic labels, string template members, named lib parameters, compound statement scoping, enter verb scoping, case-insensitive BBjAPI access).
- Write at least 1 explicit test: parse code with a variable declaration and usage, then call the references/definition service to verify it resolves. Use `services.BBj.references.References` or `services.BBj.lsp.DefinitionProvider` -- check what's available on the services object.
- If the definition provider API is not easily callable in tests, verify FUNC-07 as "PASS - Verified by linking.test.ts (11 tests proving reference resolution, which is the foundation of go-to-definition)". But attempt the direct test first.

**FUNC-08: Document Symbols** (1-2 tests)
- Parse a BBj program with classes, methods, fields, and labels
- Call `services.BBj.lsp.DocumentSymbolProvider.getSymbols(document, params)`
- Assert correct symbol names and hierarchy (children for class members)
- Follow the exact pattern from document-symbol.test.ts

**FUNC-09: Semantic Tokens** (1 test)
- Parse valid BBj code
- Call `services.BBj.lsp.SemanticTokenProvider.semanticHighlight(document, params)` if the provider exists
- Assert tokens are returned (non-empty array)
- If SemanticTokenProvider is not available on the services, skip this test with a note

Note on FUNC-01 (syntax highlighting): This is handled by TextMate grammar (bbj.tmLanguage.json), not the language server. The Chevrotain token tests in Task 1 verify the parser handles all tokens. No additional test needed.

Note on FUNC-06 (signature help): The signature help provider exists at `bbj-signature-help-provider.ts`. Attempt to test it by calling the provider with a cursor position inside a function call (e.g., after `STR(` ). If the API is not easily callable in tests, verify as "PASS - Provider registered in bbj-module.ts, function call parsing verified by parser tests". But attempt the direct test first.

IMPORTANT: For FUNC-05, FUNC-06, FUNC-07 -- make a genuine attempt to call the provider APIs directly. If that proves impractical (requires full LSP transport, missing method signatures, etc.), fall back to the "verified by infrastructure" approach but document the specific reason why direct testing was not feasible, and cite the specific existing test files that provide coverage.

IMPORTANT: Use `beforeAll(async () => { await initializeWorkspace(services.shared); })` to initialize workspace (pattern from document-symbol.test.ts).

IMPORTANT: Use `.js` extensions in all import paths (ESM convention used throughout the project).
  </action>
  <verify>
Run: `cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npx vitest run test/functional/lsp-features.test.ts`

All tests pass. Then run the full suite: `cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npm test`

Full suite passes with no NEW failures (existing 56/58 pass count maintained or improved).
  </verify>
  <done>LSP feature tests pass covering: diagnostics (valid/invalid code), completion (BBj keywords + Java classes), hover (FUNC-05), go-to-definition (FUNC-07), document symbols (hierarchy), semantic tokens, and signature help (FUNC-06). Each of FUNC-05, FUNC-06, FUNC-07 has either a direct automated test OR a documented verification with specific test file references. Full test suite shows no regressions.</done>
</task>

</tasks>

<verification>
1. `cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npx vitest run test/functional/` -- all functional tests pass
2. `cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npm test` -- full suite passes (56+ tests, no new failures)
3. Both test files exist and follow project conventions
4. FUNC-05, FUNC-06, FUNC-07 each have explicit coverage: either direct test or documented verification citing specific existing tests
</verification>

<success_criteria>
- All 7 Chevrotain tokens verified with standalone + compound patterns (14+ tests)
- LSP feature tests cover completion, document symbols, diagnostics, semantic tokens (5+ tests)
- FUNC-05 (hover): Direct test via HoverProvider OR documented as verified by provider registration + linking.test.ts reference resolution
- FUNC-06 (signature help): Direct test via SignatureHelpProvider OR documented as verified by provider registration + parser tests
- FUNC-07 (go-to-definition): Direct test via DefinitionProvider OR documented as verified by linking.test.ts (11 tests proving reference resolution)
- Full test suite passes with no regressions from Phase 17 baseline
- Test files follow established project patterns (imports, helpers, naming)
</success_criteria>

<output>
After completion, create `.planning/phases/18-functional-verification-release/18-01-SUMMARY.md`
</output>
