---
phase: 29-def-fn-inheritance-resolution
plan: 03
type: execute
wave: 1
depends_on: ["29-01", "29-02"]
files_modified:
  - bbj-vscode/test/classes.test.ts
  - bbj-vscode/test/variable-scoping.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Accessing #field$ defined in a BBj super class resolves without error in subclass method"
    - "Accessing #field$ defined in a grandparent BBj class resolves without error"
    - "Auto-generated field accessor (#getName$()) resolves through BBj super class chain"
    - "DEF FN parameters do NOT leak into the enclosing method scope"
    - "Java inherited method resolution documented as human verification item"
  artifacts:
    - path: "bbj-vscode/test/classes.test.ts"
      provides: "Field inheritance chain resolution tests"
      contains: "field.*super class"
    - path: "bbj-vscode/test/variable-scoping.test.ts"
      provides: "DEF FN parameter non-leakage test"
      contains: "do NOT leak"
  key_links:
    - from: "bbj-vscode/test/classes.test.ts"
      to: "bbj-vscode/src/language/bbj-scope.ts"
      via: "createBBjClassMemberScope traverses fields through inheritance chain"
      pattern: "field.*extends"
    - from: "bbj-vscode/test/variable-scoping.test.ts"
      to: "bbj-vscode/src/language/bbj-scope-local.ts"
      via: "processNode scopes DEF FN params to DefFunction, not container"
      pattern: "DEF FN.*leak"
---

<objective>
Close verification gaps for Phase 29: add missing field inheritance chain tests (Gap 1) and DEF FN parameter non-leakage test (Gap 2). Document JAVA-01 as human-only verification (Gap 3).

Purpose: VERIFICATION.md found that SCOPE-03 (super class field access) has zero tests and SCOPE-02 (DEF FN parameter scoping) is only half-tested (visibility yes, non-leakage no). These gaps leave two phase success criteria unverified.

Output: Field inheritance tests in classes.test.ts, parameter non-leakage test in variable-scoping.test.ts.
</objective>

<execution_context>
@/Users/beff/.claude/agents/gsd-planner.md
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-def-fn-inheritance-resolution/29-VERIFICATION.md
@.planning/phases/29-def-fn-inheritance-resolution/29-01-SUMMARY.md
@.planning/phases/29-def-fn-inheritance-resolution/29-02-SUMMARY.md
@bbj-vscode/test/classes.test.ts
@bbj-vscode/test/variable-scoping.test.ts
@bbj-vscode/test/linking.test.ts
@bbj-vscode/src/language/bbj-scope.ts
@bbj-vscode/src/language/bbj-scope-local.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add field inheritance chain resolution tests</name>
  <files>bbj-vscode/test/classes.test.ts</files>
  <action>
Add tests for field access through the BBj inheritance chain. These tests close Gap 1 from VERIFICATION.md (SCOPE-03: super class field access).

**CRITICAL WORKAROUND:** The test environment uses `EmptyFileSystem` without Java interop. Types like `BBjString` and `BBjNumber` won't resolve. The workaround (proven in linking.test.ts line 157-171) is to define a dummy class type within the same test code:

```bbj
class public MyType
classend
```

Then use `field public MyType Name$` instead of `field public BBjString Name$`. This avoids external type dependencies while testing field declaration, accessor generation, and inheritance chain traversal.

**Add the following tests inside the existing "Inheritance chain resolution" describe block** (after the existing 4 method tests):

1. **Test: "Field declared in BBj super class resolves in subclass via #field"**
   ```bbj
   class public MyType
   classend

   class public Base
       field public MyType Name$
   classend

   class public Child extends Base
       method public doWork()
           #Name$
       methodend
   classend
   ```
   - `#Name$` uses `instanceAccess` (the `#` prefix) which triggers `createBBjClassMemberScope(bbjType, false, new Set())` in the `isSymbolRef` branch of `getScope()` (bbj-scope.ts line 176-177).
   - The scope traversal walks from `Child` to `Base`, finds `Name$` in Base's local symbols.
   - Expect: 0 diagnostics (no linking errors, no validation errors). Filter to only check linking-type errors (`Could not resolve`) because `MyType` not resolving might generate a warning; use `diagnostics.filter(d => d.message.includes('Could not resolve') && /Name/i.test(d.message))` and assert length 0.

   Actually, a cleaner approach: check that there are NO `Could not resolve` errors referencing `Name$`. There may be other diagnostics (e.g., for MyType if it can't fully resolve), but the field itself should resolve.

   Implementation:
   ```typescript
   test("Field declared in BBj super class resolves in subclass via #field", async () => {
       const { diagnostics } = await validate(`
           class public MyType
           classend

           class public Base
               field public MyType Name$
           classend

           class public Child extends Base
               method public doWork()
                   #Name$
               methodend
           classend
       `);
       const fieldErrors = diagnostics.filter(d =>
           d.message.includes('Could not resolve') && /Name\$/i.test(d.message)
       );
       expect(fieldErrors).toHaveLength(0);
   });
   ```

2. **Test: "Field declared in grandparent BBj class resolves"**
   ```typescript
   test("Field declared in grandparent BBj class resolves", async () => {
       const { diagnostics } = await validate(`
           class public MyType
           classend

           class public GrandParent
               field public MyType Title$
           classend

           class public Parent extends GrandParent
           classend

           class public Child extends Parent
               method public doWork()
                   #Title$
               methodend
           classend
       `);
       const fieldErrors = diagnostics.filter(d =>
           d.message.includes('Could not resolve') && /Title\$/i.test(d.message)
       );
       expect(fieldErrors).toHaveLength(0);
   });
   ```

3. **Test: "Field accessor (getName$()) resolves through inheritance chain"**
   Auto-generated getters/setters for fields are created in `bbj-scope-local.ts` lines 185-192 via `createAccessorDescription`. These are scoped to the class's local symbols, so `createBBjClassMemberScope` should find them when traversing the inheritance chain.

   ```typescript
   test("Field accessor resolves through inheritance chain", async () => {
       const { diagnostics } = await validate(`
           class public MyType
           classend

           class public Base
               field public MyType Value$
           classend

           class public Child extends Base
               method public doWork()
                   #getValue$()
               methodend
           classend
       `);
       const accessorErrors = diagnostics.filter(d =>
           d.message.includes('Could not resolve') && /getValue/i.test(d.message)
       );
       expect(accessorErrors).toHaveLength(0);
   });
   ```

**NOTE on error filtering:** We filter for `Could not resolve` errors specifically mentioning the field/accessor name because the `MyType` dummy class may or may not produce its own warnings. The important thing is that the FIELD ITSELF and its ACCESSORS resolve through the inheritance chain.
  </action>
  <verify>Run `npx vitest run bbj-vscode/test/classes.test.ts` -- all 7 tests in "Inheritance chain resolution" pass (4 existing method tests + 3 new field tests). No new failures beyond the 2 pre-existing failures in "Classes access-levels".</verify>
  <done>Field access via #field$ and auto-generated accessor #getField$() both resolve through the BBj inheritance chain (parent and grandparent). SCOPE-03 requirement is verified.</done>
</task>

<task type="auto">
  <name>Task 2: Add DEF FN parameter non-leakage test and document JAVA-01</name>
  <files>bbj-vscode/test/variable-scoping.test.ts</files>
  <action>
Add the missing DEF FN parameter non-leakage test. This closes Gap 2 from VERIFICATION.md (SCOPE-02: parameter scoping completeness).

**Test design rationale:**
- DEF FN parameters are added to `node` (the DefFunction) scope in `bbj-scope-local.ts` lines 100-104, NOT to `node.$container` (the enclosing method/program).
- If the parameter leaks, using `PRINT x` after a `DEF FN(...x...)` would resolve `x` to the parameter, and NO "used before assignment" hint would fire.
- If the parameter does NOT leak (correct behavior), `x` after the DEF FN is a fresh implicit variable with no prior assignment, so the "used before assignment" hint WILL fire.
- Therefore: presence of the "used before assignment" hint proves non-leakage.

**Add the following test inside the existing "DEF FN Parameter Scoping" describe block** (after the 3 existing tests):

```typescript
test('DEF FN parameters do NOT leak into enclosing scope', async () => {
    const result = await validate(`
DEF FNSquare(x)
    RETURN x*x
FNEND
PRINT x
    `);
    // If parameter 'x' leaked from DEF FN into program scope,
    // PRINT x would resolve to the parameter and show no hint.
    // Since it does NOT leak, 'x' is an unassigned variable,
    // so "used before assignment" hint should fire.
    expectHint(result, /x.*used before assignment/i);
});
```

**Why program scope instead of method scope:** Program scope is simpler and avoids complications with method variable scoping. The scoping mechanism is the same -- `addToScope(scopes, node, description)` with `node` being the DefFunction in both cases. If it works at program scope, it works in methods too (the existing method-scope DEF FN parameter visibility tests already prove the mechanism works in methods). The critical test is whether the parameter LEAKS, which is scope-container-agnostic.

**JAVA-01 Human Verification Note:**
Gap 3 (Java inherited methods) cannot be unit tested because the test environment uses EmptyFileSystem without the Java interop socket service. This is already documented in VERIFICATION.md. No test tasks are needed -- this is a human verification item. The implementation relies on Java's `Class.getMethods()` which returns inherited methods. The plan 29-02 SUMMARY confirmed this design and noted no code changes were needed for `createJavaClassMemberScope`.
  </action>
  <verify>Run `npx vitest run bbj-vscode/test/variable-scoping.test.ts` -- all 4 tests in "DEF FN Parameter Scoping" pass (3 existing + 1 new non-leakage test). No regressions.</verify>
  <done>DEF FN parameter non-leakage is verified: using a DEF FN parameter name outside the FN body produces a "used before assignment" hint, proving the parameter scope does not extend beyond the DefFunction. SCOPE-02 is fully satisfied. JAVA-01 documented as human verification only.</done>
</task>

</tasks>

<verification>
1. Run `npx vitest run bbj-vscode/test/classes.test.ts` -- 7 tests in "Inheritance chain resolution" pass (4 method + 3 field), 2 pre-existing failures in "Classes access-levels" unchanged
2. Run `npx vitest run bbj-vscode/test/variable-scoping.test.ts` -- 4 tests in "DEF FN Parameter Scoping" pass (3 visibility + 1 non-leakage), all other tests unchanged
3. Run `npx vitest run` -- full suite, no new regressions beyond pre-existing failures
4. After gap closure, re-run verification: SCOPE-02 should be fully satisfied, SCOPE-03 should be satisfied, JAVA-01 remains human-verify-only
</verification>

<success_criteria>
- #field$ declared in BBj super class resolves in subclass method without linking error
- #field$ declared in grandparent BBj class resolves without linking error
- Auto-generated field accessor (#getValue$()) resolves through inheritance chain
- DEF FN parameters do NOT leak outside the FN body (verified by "used before assignment" hint)
- No regressions in existing tests
- JAVA-01 acknowledged as human verification item (no unit test possible)
</success_criteria>

<output>
After completion, create `.planning/phases/29-def-fn-inheritance-resolution/29-03-SUMMARY.md`
</output>
