---
phase: 29-def-fn-inheritance-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/validations/line-break-validation.ts
  - bbj-vscode/src/language/bbj-scope-local.ts
  - bbj-vscode/src/language/validations/check-variable-scoping.ts
  - bbj-vscode/test/validation.test.ts
  - bbj-vscode/test/variable-scoping.test.ts
autonomous: true

must_haves:
  truths:
    - "Single-line DEF FN inside a class method does not produce line-break validation errors"
    - "Multi-line DEF FN inside a class method continues to work without errors"
    - "DEF FN parameters are visible inside the FN body"
    - "DEF FN parameters do NOT leak into the enclosing method scope"
    - "Enclosing method variables ARE visible inside DEF FN body"
    - "Program-scope DEF FN continues working unchanged"
  artifacts:
    - path: "bbj-vscode/src/language/validations/line-break-validation.ts"
      provides: "Fixed isStandaloneStatement excluding DefFunction container"
      contains: "isDefFunction"
    - path: "bbj-vscode/src/language/bbj-scope-local.ts"
      provides: "DEF FN parameter scoping in processNode"
      contains: "isDefFunction"
    - path: "bbj-vscode/test/validation.test.ts"
      provides: "Tests for DEF FN line-break fix"
      contains: "DEF FN"
    - path: "bbj-vscode/test/variable-scoping.test.ts"
      provides: "Tests for DEF FN parameter scoping"
      contains: "DefFunction"
  key_links:
    - from: "bbj-vscode/src/language/validations/line-break-validation.ts"
      to: "isDefFunction"
      via: "container check in isStandaloneStatement"
      pattern: "isDefFunction\\(node\\.\\$container\\)"
    - from: "bbj-vscode/src/language/bbj-scope-local.ts"
      to: "DefFunction parameters"
      via: "processNode branch for isDefFunction"
      pattern: "isDefFunction\\(node\\)"
---

<objective>
Fix DEF FN handling in class methods: eliminate false line-break validation errors for single-line DEF FN, and add correct parameter scoping so DEF FN parameters are visible in the FN body but do NOT leak into the enclosing method scope.

Purpose: Closes PARSE-01 (#226 line-break bug) and SCOPE-02 (#226 parameter scoping). DEF FN is a commonly used BBj construct for inline functions, and false errors + missing parameter scoping make it unusable inside class methods.

Output: Fixed line-break validation, DEF FN parameter scoping in scope computation, and tests for both.
</objective>

<execution_context>
@/Users/beff/.claude/agents/gsd-planner.md
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-def-fn-inheritance-resolution/29-CONTEXT.md
@.planning/phases/29-def-fn-inheritance-resolution/29-RESEARCH.md
@bbj-vscode/src/language/validations/line-break-validation.ts
@bbj-vscode/src/language/bbj-scope-local.ts
@bbj-vscode/src/language/validations/check-variable-scoping.ts
@bbj-vscode/src/language/generated/ast.ts
@bbj-vscode/test/validation.test.ts
@bbj-vscode/test/variable-scoping.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix line-break validation for single-line DEF FN in methods</name>
  <files>
    bbj-vscode/src/language/validations/line-break-validation.ts
    bbj-vscode/test/validation.test.ts
  </files>
  <action>
Fix the false "needs to end with a line break" / "needs to start in a new line" errors that appear when a single-line `def fnName(params)=expression` is used inside a class method body.

**Root cause:** The `isStandaloneStatement` function (line 119) is a catch-all that returns `true` for statements not inside certain containers. Single-line DEF FN has child nodes (the expression/value part) that are treated as separate statements. The fix is to add `isDefFunction(node.$container)` to the exclusion list.

**Implementation in `line-break-validation.ts`:**

1. In `isStandaloneStatement` function (around line 125-133), add `isDefFunction(node.$container)` to the existing exclusion chain:
   ```
   if (isCompoundStatement(node.$container)
       || isLetStatement(node.$container)
       || isForStatement(node.$container)
       || isArrayDeclarationStatement(node.$container)
       || isDefFunction(node.$container)     // <-- ADD THIS LINE
       || AstUtils.getContainerOfType(previous, isSwitchStatement)
       || AstUtils.getContainerOfType(previous, isIfStatement)
       || isInsideSingleLineIf(node)) {
       return false;
   }
   ```

2. The import for `isDefFunction` is already present on line 4. Verify it's there.

**Tests in `validation.test.ts`:**

Add test(s) in the "BBj validation" describe block (near the existing DEF FN tests around line 186):

- Test: "Single-line DEF FN inside class method has no line-break errors"
  ```bbj
  class public MathHelper
      method public void doMath()
          def fnSquare(x)=x*x
          let y=fnSquare(5)
          print y
      methodend
  classend
  ```
  Expect: 0 diagnostics (no line-break errors)

- Test: "Multi-line DEF FN inside class method still works"
  ```bbj
  class public MathHelper
      method public void calculate()
          DEF FNGCF(X,Y)
              IF FPT(X)<>0 OR FPT(Y)<>0 THEN FNERR 41
              WHILE X<>0
                  LET T=MOD(Y,X),Y=X,X=T
              WEND
              RETURN Y
          FNEND
          LET A=FNGCF(9,6)
      methodend
  classend
  ```
  Expect: 0 diagnostics

- Test: "Program-scope single-line DEF FN continues working"
  ```bbj
  def fnDouble(x)=x*2
  let y=fnDouble(3)
  ```
  Expect: 0 diagnostics
  </action>
  <verify>Run `npx vitest run bbj-vscode/test/validation.test.ts` -- new tests pass, no new failures beyond the 3 pre-existing failures.</verify>
  <done>Single-line DEF FN inside a class method produces zero line-break validation errors. Multi-line and program-scope DEF FN continue working.</done>
</task>

<task type="auto">
  <name>Task 2: Add DEF FN parameter scoping to scope computation and variable scoping validation</name>
  <files>
    bbj-vscode/src/language/bbj-scope-local.ts
    bbj-vscode/src/language/validations/check-variable-scoping.ts
    bbj-vscode/test/variable-scoping.test.ts
  </files>
  <action>
Add DEF FN parameter scoping so parameters are visible inside the FN body but do NOT leak into the enclosing method/program scope.

**Per user decisions (LOCKED):**
- DEF FN parameters are scoped to the FN body only -- they do NOT leak into the enclosing method
- Variables assigned inside DEF FN body are local to the FN -- they do NOT leak into the enclosing scope
- Enclosing method variables (including DECLARE'd ones) ARE visible inside the DEF FN body (closure-like)
- No DEF FN nesting -- DEF FN cannot appear inside another DEF FN
- DEF FN can appear anywhere a statement is valid

**Implementation in `bbj-scope-local.ts` (processNode method, around line 90):**

1. Add import for `isDefFunction` to the import block (add to the existing import from `./generated/ast.js`).

2. Add a new branch in `processNode` BEFORE the `isUse` branch (line 91). The branch should check `isDefFunction(node)` and add its parameters scoped to the DefFunction node itself (NOT its container):

   ```typescript
   if (isDefFunction(node)) {
       // Add DEF FN parameters to the function's own scope, NOT the container.
       // This ensures parameters are visible inside the FN body but don't leak.
       for (const param of node.parameters) {
           if (param.name) {
               const description = this.descriptions.createDescription(param, param.name);
               this.addToScope(scopes, node, description);
           }
       }
   } else if (isUse(node) && node.javaClass) {
   ```

   IMPORTANT: Use `this.addToScope(scopes, node, description)` -- scope to `node` (the DefFunction), NOT `node.$container`. The existing `addToScope` helper (line 292) handles CompoundStatement unwrapping, but DefFunction is not a CompoundStatement, so parameters will be scoped exactly to the DefFunction node.

**Implementation in `check-variable-scoping.ts`:**

The validator already has `if (isDefFunction(child)) { continue; }` on line 214 in the Pass 2 loop, which skips DEF FN bodies during use-before-assignment checks. This is correct -- DEF FN bodies have their own scoping rules.

No changes needed in `check-variable-scoping.ts` UNLESS the walkStatements Pass 1 (line 113) is visiting DEF FN bodies and recording assignments. Check: `walkStatements` (line 48) only recurses into `CompoundStatement`, not DefFunction. So DEF FN body assignments are already excluded from Pass 1. This is correct behavior -- assignments inside DEF FN body are local to the FN.

**Tests in `variable-scoping.test.ts`:**

Add a new describe block "DEF FN Parameter Scoping" after the existing test blocks:

- Test: "DEF FN parameters are visible inside single-line FN body"
  ```bbj
  class public Test
      method public void doWork()
          def fnAdd(a,b)=a+b
          let result = fnAdd(1,2)
      methodend
  classend
  ```
  Expect: 0 diagnostics (no "undefined variable" for a, b inside the FN expression)

- Test: "DEF FN parameters are visible inside multi-line FN body"
  ```bbj
  def fnCalc(x,y)
      let z = x + y
      return z
  fnend
  let result = fnCalc(1,2)
  ```
  Expect: 0 diagnostics

- Test: "DEF FN parameters do NOT leak into enclosing method"
  ```bbj
  class public Test
      method public void doWork()
          def fnSquare(x)=x*x
          print x
      methodend
  classend
  ```
  Expect: The `print x` line should NOT resolve `x` from the DEF FN parameters. Since `x` is not declared in the method scope, it should produce a linking warning (unresolved reference). Verify there IS a diagnostic on the `print x` line.

- Test: "Enclosing method variables visible inside DEF FN body"
  ```bbj
  class public Test
      method public void doWork()
          let multiplier = 2
          def fnScale(x)=x*multiplier
          let result = fnScale(5)
      methodend
  classend
  ```
  Expect: 0 diagnostics (multiplier from enclosing method is visible in DEF FN)

- Test: "Program-scope DEF FN parameters scoped correctly"
  ```bbj
  def fnDouble(n)=n*2
  let result = fnDouble(5)
  ```
  Expect: 0 diagnostics
  </action>
  <verify>Run `npx vitest run bbj-vscode/test/variable-scoping.test.ts` -- new tests pass. Run `npx vitest run bbj-vscode/test/validation.test.ts` -- no new failures beyond pre-existing 3.</verify>
  <done>DEF FN parameters resolve inside the FN body. DEF FN parameters do NOT appear in the enclosing method/program scope. Enclosing scope variables are visible inside DEF FN body (closure behavior).</done>
</task>

</tasks>

<verification>
1. Run full validation test suite: `npx vitest run bbj-vscode/test/validation.test.ts` -- no new failures beyond pre-existing 3
2. Run variable scoping tests: `npx vitest run bbj-vscode/test/variable-scoping.test.ts` -- all pass
3. Run full test suite: `npx vitest run` -- no new regressions beyond pre-existing failures
4. The example from the issue works: `def fnstr_pos(tmp0$,tmp1$,tmp0)=int((pos(tmp0$=tmp1$,tmp0)+tmp0-1)/tmp0)` inside a class method produces no errors
</verification>

<success_criteria>
- Single-line `def fnName(params)=expression` inside class methods: zero line-break errors
- Multi-line DEF FN inside class methods: continues working
- Program-scope DEF FN: continues working
- DEF FN parameters visible in FN body (both single-line and multi-line)
- DEF FN parameters NOT visible in enclosing method/program scope
- Enclosing scope variables visible inside DEF FN body
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/29-def-fn-inheritance-resolution/29-01-SUMMARY.md`
</output>
