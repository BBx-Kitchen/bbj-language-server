---
phase: 24-grammar-parsing-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/bbj.langium
  - bbj-vscode/src/language/generated/ast.ts
  - bbj-vscode/src/language/generated/grammar.ts
  - bbj-vscode/src/language/generated/module.ts
  - bbj-vscode/test/parser.test.ts
autonomous: true

must_haves:
  truths:
    - "endif;rem comment and swend;rem comment parse without error"
    - "A line starting with : REM (colon continuation + comment) parses without error"
    - "DREAD verb with input items parses without error"
    - "DATA statement with values parses without error"
    - "DEF FN / FNEND blocks inside class methods parse without error"
  artifacts:
    - path: "bbj-vscode/src/language/bbj.langium"
      provides: "Grammar rules for DreadStatement, DataStatement, and DEF FN in methods; COMMENT terminal fix"
      contains: "DreadStatement"
    - path: "bbj-vscode/src/language/generated/ast.ts"
      provides: "Generated AST types including DreadStatement, DataStatement"
      contains: "DreadStatement"
    - path: "bbj-vscode/test/parser.test.ts"
      provides: "Tests for GRAM-01, GRAM-03, GRAM-04, GRAM-05"
      contains: "DREAD"
  key_links:
    - from: "bbj.langium"
      to: "generated/ast.ts"
      via: "langium-cli generate"
      pattern: "DreadStatement|DataStatement"
    - from: "bbj.langium DreadStatement"
      to: "bbj.langium SingleStatement"
      via: "grammar alternative"
      pattern: "DreadStatement"
    - from: "bbj.langium MethodDecl"
      to: "bbj.langium DefFunction"
      via: "body alternative"
      pattern: "body\\+\\=.*DefFunction"
---

<objective>
Fix GRAM-01, GRAM-03, GRAM-04, GRAM-05: Grammar extensions for inline REM comments, DREAD/DATA statements, DEF FN in methods, and colon-continuation REM.

Purpose: Valid BBj syntax patterns currently produce false parser errors. This plan adds grammar rules for DREAD/DATA, allows DEF FN inside methods, and fixes the COMMENT terminal to handle inline REM after semicolons. These four fixes together eliminate the majority of false errors in legacy BBj code.

Output: Updated `bbj.langium` grammar, regenerated AST types, and tests proving all four patterns parse correctly.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-grammar-parsing-fixes/24-CONTEXT.md
@.planning/phases/24-grammar-parsing-fixes/24-RESEARCH.md
@bbj-vscode/src/language/bbj.langium
@bbj-vscode/src/language/bbj-module.ts
@bbj-vscode/src/language/bbj-lexer.ts
@bbj-vscode/src/language/bbj-token-builder.ts
@bbj-vscode/src/language/bbj-validator.ts
@bbj-vscode/src/language/generated/module.ts
@bbj-vscode/test/parser.test.ts
@bbj-vscode/test/lexer.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix COMMENT terminal and add DREAD/DATA/DEF-FN-in-methods to grammar</name>
  <files>
    bbj-vscode/src/language/bbj.langium
    bbj-vscode/src/language/generated/ast.ts
    bbj-vscode/src/language/generated/grammar.ts
    bbj-vscode/src/language/generated/module.ts
  </files>
  <action>
Make 4 changes to `bbj-vscode/src/language/bbj.langium`:

**1. Fix COMMENT terminal for inline REM (GRAM-01 and GRAM-05):**

Change the COMMENT terminal (currently line 889):
```
terminal COMMENT: /([rR][eE][mM])([ \t][^\n\r]*)?[\n\r]+/;
```
To make the newline optional (allow end-of-input):
```
terminal COMMENT: /([rR][eE][mM])([ \t][^\n\r]*)?([\n\r]+)?/;
```

The `?` on `[\n\r]+` allows REM at end of file or after semicolons where the lexer has already consumed up to the newline in the preceding token. The existing test "Parse REM as independent statement in compound statement" (PRINT 1; REM compound rem) already works because the COMMENT terminal matches the newline. Making the newline optional extends support to cases like `endif;rem blah` at end-of-file or before the next statement.

**IMPORTANT:** After this change, verify the existing test at parser.test.ts line 253-266 still passes. Also verify that `checkCommentNewLines` validation in `bbj-validator.ts` still works correctly -- it checks that comments are separated by `;` or newline, which is an AST-level check unaffected by the terminal regex.

**2. Add DreadStatement and DataStatement (GRAM-03):**

Add to `SingleStatement` alternatives (around line 116, before `ExpressionStatement`):
```
DreadStatement |
DataStatement |
```

Add the rules after the existing `RestoreStatement` rule (around line 208):
```langium
DreadStatement:
    'DREAD' items+=InputItem (',' items+=InputItem)* Err?
;

DataStatement:
    'DATA' values+=Expression (',' values+=Expression)*
;
```

DreadStatement reuses the existing `InputItem` and `Err` patterns from `ReadStatement`. DataStatement takes comma-separated expressions. Per user decision, DATA semantics (no compound statement) can be enforced in validation later -- grammar should parse it.

Also add `DREAD` to the `KEYWORD_STANDALONE` list in `bbj-token-builder.ts` if DREAD can appear standalone (check: DREAD always needs items, so no -- only add it to SingleStatement alternatives).

**3. Allow DefFunction inside MethodDecl body (GRAM-04):**

Change the MethodDecl rule (currently line 333-340):
```langium
MethodDecl returns MethodDecl:
    MethodDeclStart
    Comments?
    (
        (body+=Statement)*
        endTag='METHODEND'
    )?
;
```

To:
```langium
MethodDecl returns MethodDecl:
    MethodDeclStart
    Comments?
    (
        (body+=(Statement | DefFunction))*
        endTag='METHODEND'
    )?
;
```

This mirrors how `Statements` fragment (line 19-21) already includes `DefFunction` at the top level. The `MethodDecl` interface already has `body: Statement[]` -- check the generated AST to see if DefFunction needs to be added to the type. Looking at the grammar, `DefFunctionStatement` type (line 921) already includes `DefReturn | Statement`. For the `body` property of `MethodDecl`, we need it to accept `DefFunction` too. The solution: update the MethodDecl interface body type.

Since Langium generates the AST types from the grammar rules, the `body` property type needs to include `DefFunction`. Add a type declaration:

At the type declaration section (around line 921), add or update:
```langium
type MethodBodyElement = Statement | DefFunction;
```

And update the MethodDecl interface (around line 941) to use it:
```langium
interface MethodDecl extends NamedElement {
    ...
    body: MethodBodyElement[];
    ...
}
```

Actually, the simplest approach: since `body` in the grammar rule `body+=(Statement | DefFunction)` will generate a union type automatically, just change the grammar rule. Langium will infer the type. But the explicit interface override on line 941 sets `body: Statement[]` -- this needs to change to `body: (Statement | DefFunction)[]` or you can use the existing `DefFunctionStatement` type.

Wait -- looking more carefully: the `interface MethodDecl` on line 941 explicitly declares `body: Statement[]`. This is a Langium declared type that overrides the inferred type. Change it to:
```langium
interface MethodDecl extends NamedElement {
    visibility?: string
    static?: boolean
    returnType?: QualifiedClass
    array?: boolean
    comments: CommentStatement[]
    params: VariableDecl[]
    body: (Statement | DefFunction)[];
    endTag?: string;
}
```

**4. After all grammar changes, regenerate:**
```bash
cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npx langium generate
```

This regenerates `src/language/generated/ast.ts`, `grammar.ts`, and `module.ts`.

**5. Check for TypeScript compilation errors after regeneration:**
```bash
cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npx tsc --noEmit
```

If there are type errors from the `body` type change (e.g., code that iterates over `body` and expects only `Statement`), fix them. The main consumers are:
- `bbj-scope-local.ts` -- scope computation iterates over body
- `bbj-validator.ts` -- validation checks
- Any code that does `method.body.forEach(stmt => ...)` needs to handle `DefFunction` too

For any such code, add a type guard check: `if (isStatement(element))` before treating it as Statement. This is defensive and minimal.
  </action>
  <verify>
Run generation and tests:
```bash
cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npx langium generate && npx tsc --noEmit && npm test
```

All existing tests must pass. Generated files must compile. No TypeScript errors.
  </verify>
  <done>
Grammar updated with COMMENT terminal fix, DreadStatement, DataStatement rules, and DefFunction allowed in MethodDecl body. Generated AST types include new statement types. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for GRAM-01, GRAM-03, GRAM-04, GRAM-05</name>
  <files>bbj-vscode/test/parser.test.ts</files>
  <action>
Add test cases to `parser.test.ts` in the existing describe block. Use the existing `expectNoParserLexerErrors()` and `expectNoValidationErrors()` helpers.

**1. GRAM-01: endif/swend followed by ;rem comment**
```typescript
test('GRAM-01: endif followed by ;rem comment (#318)', async () => {
    const result = await parse(`
        if 1 > 0 then
            PRINT "yes"
        endif;rem this is a comment
    `, { validation: true });
    expectNoParserLexerErrors(result);
    expectNoValidationErrors(result);
});

test('GRAM-01: swend followed by ;rem comment (#318)', async () => {
    const result = await parse(`
        LVL = 3
        SWITCH LVL
            CASE 1; PRINT "one"; BREAK
            CASE DEFAULT; PRINT "other"; BREAK
        SWEND;rem end of switch
    `, { validation: true });
    expectNoParserLexerErrors(result);
    expectNoValidationErrors(result);
});

test('GRAM-01: endif with space before ;rem', async () => {
    const result = await parse(`
        if 1 > 0 then
            PRINT "yes"
        endif ; rem spaced comment
    `, { validation: true });
    expectNoParserLexerErrors(result);
    expectNoValidationErrors(result);
});
```

**2. GRAM-03: DREAD and DATA statements**
```typescript
test('GRAM-03: DREAD statement (#247)', async () => {
    const result = await parse(`
        DREAD A$, B$, C
    `);
    expectNoParserLexerErrors(result);
});

test('GRAM-03: DREAD with ERR option (#247)', async () => {
    const result = await parse(`
        DREAD A$, B$, ERR=errLabel
        errLabel: STOP
    `);
    expectNoParserLexerErrors(result);
});

test('GRAM-03: DATA statement (#247)', async () => {
    const result = await parse(`
        DATA "hello", "world", 42
    `);
    expectNoParserLexerErrors(result);
});

test('GRAM-03: DATA with expressions (#247)', async () => {
    const result = await parse(`
        DATA 1, 2, 3
        DATA "Alice", "Bob", "Charlie"
    `);
    expectNoParserLexerErrors(result);
});

test('GRAM-03: DREAD and DATA together (#247)', async () => {
    const result = await parse(`
        DATA "John", 25, "Engineer"
        RESTORE dataLabel
        DREAD name$, age, job$
        PRINT name$, age, job$
        dataLabel:
    `);
    expectNoParserLexerErrors(result);
});
```

**3. GRAM-04: DEF FN inside class methods**
```typescript
test('GRAM-04: DEF FN inside class method (#226)', async () => {
    const result = await parse(`
        class public MathHelper
            method public void doMath()
                DEF FNSquare(X)=X*X
                LET Y=FNSquare(5)
                PRINT Y
            methodend
        classend
    `);
    expectNoParserLexerErrors(result);
});

test('GRAM-04: Multi-line DEF FN inside class method (#226)', async () => {
    const result = await parse(`
        class public MathHelper
            method public void calculate()
                DEF FNGCF(X,Y)
                    IF FPT(X)<>0 OR FPT(Y)<>0 THEN FNERR 41
                    WHILE X<>0
                        LET TEMP=X, X=MOD(Y,X), Y=TEMP
                    WEND
                    RETURN Y
                FNEND
                PRINT FNGCF(12,8)
            methodend
        classend
    `);
    expectNoParserLexerErrors(result);
});
```

**4. GRAM-05: Comment after colon line-continuation**
```typescript
test('GRAM-05: REM after colon line-continuation (#118)', async () => {
    const result = await parse(`
        if 1 > 0 then
: REM this is a continuation comment
            PRINT "yes"
        endif
    `);
    expectNoParserLexerErrors(result);
});

test('GRAM-05: Multiple colon continuations with REM (#118)', async () => {
    const result = await parse(`
        PRINT "hello"
: REM continued comment
: PRINT "world"
    `);
    expectNoParserLexerErrors(result);
});
```

Note: GRAM-05 (colon continuation + REM) may already work once the COMMENT terminal is fixed, because the lexer's `prepareLineSplitter` joins `: REM ...` into the previous line, making it `... REM ...` which the updated COMMENT terminal handles. The test confirms this.
  </action>
  <verify>
Run: `cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npm test`

All new tests pass. All existing tests still pass.
  </verify>
  <done>
12+ new test cases prove GRAM-01, GRAM-03, GRAM-04, GRAM-05 are fixed:
- endif;rem and swend;rem parse without error
- DREAD and DATA statements parse without error
- DEF FN / FNEND inside class methods parse without error
- Colon-continuation + REM comment parses without error
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npx langium generate` completes without errors
2. `cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npx tsc --noEmit` compiles without errors
3. `cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npm test` -- all tests pass (new and existing)
4. Generated AST includes `DreadStatement` and `DataStatement` types
5. Existing tests for REM in compound statements (line 253-266) still pass
6. Existing DEF FN tests (line 881-896) still pass
</verification>

<success_criteria>
- GRAM-01: `endif;rem` and `swend;rem` parse without error
- GRAM-03: DREAD and DATA statements recognized by grammar
- GRAM-04: DEF FN / FNEND inside class methods parse without error
- GRAM-05: `: REM ...` after colon line-continuation parses without error
- Zero test regressions
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/24-grammar-parsing-fixes/24-02-SUMMARY.md`
</output>
