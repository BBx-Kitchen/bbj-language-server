---
phase: 52-bbjcpl-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 52-01
files_modified:
  - bbj-vscode/src/language/bbj-cpl-service.ts
  - bbj-vscode/src/language/bbj-module.ts
  - bbj-vscode/test/cpl-service.test.ts
autonomous: true
requirements:
  - CPL-02
  - CPL-04

must_haves:
  truths:
    - "BBjCPLService derives bbjcpl binary path from bbj.home setting with correct platform suffix (.exe on Windows)"
    - "A second compile request on the same file aborts the in-flight process before starting a new one"
    - "When bbjcpl does not complete within the timeout, the process is killed and an empty diagnostic array is returned"
    - "When bbjcpl is not installed (ENOENT), compile returns empty diagnostics without errors"
    - "BBjCPLService is registered in BBjModule and accessible as services.compiler.BBjCPLService"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-cpl-service.ts"
      provides: "BBjCPLService class with compile(), setTimeout(), getBbjcplPath() methods"
      exports: ["BBjCPLService"]
    - path: "bbj-vscode/src/language/bbj-module.ts"
      provides: "BBjCPLService registration in BBjAddedServices and BBjModule"
      contains: "BBjCPLService"
    - path: "bbj-vscode/test/cpl-service.test.ts"
      provides: "Lifecycle tests for abort-on-resave and timeout behavior"
      min_lines: 40
  key_links:
    - from: "bbj-vscode/src/language/bbj-cpl-service.ts"
      to: "bbj-vscode/src/language/bbj-cpl-parser.ts"
      via: "import { parseBbjcplOutput }"
      pattern: "parseBbjcplOutput"
    - from: "bbj-vscode/src/language/bbj-cpl-service.ts"
      to: "bbj-vscode/src/language/bbj-ws-manager.ts"
      via: "services.workspace.WorkspaceManager (BBjWorkspaceManager)"
      pattern: "getBBjDir"
    - from: "bbj-vscode/src/language/bbj-module.ts"
      to: "bbj-vscode/src/language/bbj-cpl-service.ts"
      via: "import { BBjCPLService }"
      pattern: "BBjCPLService"
---

<objective>
Build the BBjCPLService class that spawns the bbjcpl binary with safe process lifecycle management, and register it in the Langium DI module.

Purpose: Provide a complete, tested compiler service that Phase 53 can wire into `buildDocuments()` with a single method call (`services.compiler.BBjCPLService.compile(filePath)`). The service handles all process complexity: path derivation, abort-on-resave, timeout, ENOENT graceful degradation.

Output: `BBjCPLService` class registered in `BBjModule`, with unit tests covering abort and timeout lifecycle scenarios.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-bbjcpl-foundation/52-CONTEXT.md
@.planning/phases/52-bbjcpl-foundation/52-RESEARCH.md
@.planning/phases/52-bbjcpl-foundation/52-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BBjCPLService with process lifecycle management</name>
  <files>
    bbj-vscode/src/language/bbj-cpl-service.ts
  </files>
  <action>
Create `bbj-vscode/src/language/bbj-cpl-service.ts` as a standalone service class.

**Constructor:** Accept `BBjServices` (following existing pattern from BBjValidator, JavaInteropService). Extract `BBjWorkspaceManager` reference from `services.shared.workspace.WorkspaceManager` for later `getBBjDir()` calls.

**Private state:**
- `inFlight: Map<string, AbortController>` — tracks active compilations per file path
- `timeoutMs: number` — default 30000 (30 seconds), configurable via `setTimeout(ms: number)` public method (Phase 53 will wire this from VS Code settings)

**Public method `compile(filePath: string): Promise<Diagnostic[]>`:**

1. Get bbjcpl binary path via `getBbjcplPath()` private method:
   - Call `(this.wsManager as BBjWorkspaceManager).getBBjDir()` to get bbj.home
   - If empty/undefined, return empty array (BBj not configured)
   - Construct: `path.join(bbjHome, 'bin', process.platform === 'win32' ? 'bbjcpl.exe' : 'bbjcpl')`

2. Abort any existing in-flight compilation for this file:
   - Check `this.inFlight.get(filePath)`
   - If exists, call `.abort()` on it
   - **Critical race-safety (Pitfall 2 from RESEARCH.md):** Capture `controller` reference at creation time. In the `close`/`error` handlers, only delete from `inFlight` if `inFlight.get(filePath) === controller` (the current controller, not a newer one).

3. Create new `AbortController`, store in `inFlight.set(filePath, controller)`.

4. Set up timeout: `const timeoutId = setTimeout(() => controller.abort(), this.timeoutMs)`.

5. Spawn process:
   ```typescript
   const proc = spawn(bbjcplBin, ['-N', filePath], { signal: controller.signal });
   ```

6. Accumulate stderr in a string variable. Also accumulate stdout (for debugging — log if non-empty).

7. On `close` event:
   - `clearTimeout(timeoutId)`
   - Only `inFlight.delete(filePath)` if `inFlight.get(filePath) === controller`
   - Call `parseBbjcplOutput(stderr)` and resolve with the result
   - If stdout is non-empty, log with `logger.debug(() => \`bbjcpl stdout: ${stdout}\`)`

8. On `error` event:
   - `clearTimeout(timeoutId)`
   - Only `inFlight.delete(filePath)` if `inFlight.get(filePath) === controller`
   - If `err.name === 'AbortError' || controller.signal.aborted`: resolve with `[]` (aborted — expected)
   - If `err.code === 'ENOENT'`: resolve with `[]` (bbjcpl not installed — degrade gracefully). Log once: `logger.info('bbjcpl not found — BBj compiler diagnostics unavailable')`
   - Otherwise: log `logger.warn(\`bbjcpl error: ${err.message}\`)` and resolve with `[]` (don't reject — the language server must not crash from compiler errors)

**Public method `setTimeout(ms: number): void`:** Sets `this.timeoutMs`. Called by Phase 53 from settings wiring.

**Public method `isCompiling(filePath: string): boolean`:** Returns `this.inFlight.has(filePath)`. Utility for Phase 53.

**Imports:**
- `{ spawn } from 'child_process'`
- `* as path from 'path'`
- `{ Diagnostic } from 'vscode-languageserver'`
- `{ parseBbjcplOutput } from './bbj-cpl-parser.js'`
- `{ BBjWorkspaceManager } from './bbj-ws-manager.js'`
- `{ logger } from './logger.js'`
- `{ BBjServices } from './bbj-module.js'` — but to avoid circular dependency, type the constructor parameter as the minimal interface needed:
  ```typescript
  interface BBjCPLServiceContext {
      shared: { workspace: { WorkspaceManager: unknown } };
  }
  ```
  Or use the established pattern from other services (check how JavaInteropService receives services). Follow whatever pattern exists.

**IMPORTANT anti-patterns to avoid (from RESEARCH.md and STATE.md):**
- Do NOT wire into any document lifecycle (onBuildPhase, buildDocuments). That is Phase 53.
- Do NOT use `child_process.exec()` — use `spawn()` for streaming.
- Do NOT accumulate stderr inside the `data` handler and parse it there — accumulate fully, parse only on `close`.
- Do NOT hard-code the binary name without platform suffix check.
  </action>
  <verify>
Run `npx tsc --noEmit` — zero errors. The service file compiles cleanly. Verify import paths resolve correctly.
  </verify>
  <done>
BBjCPLService class exists with compile(), setTimeout(), isCompiling() methods. Process lifecycle handles abort-on-resave (with race-safe inFlight map), timeout via AbortController, and ENOENT graceful degradation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register BBjCPLService in DI module and add lifecycle tests</name>
  <files>
    bbj-vscode/src/language/bbj-module.ts
    bbj-vscode/test/cpl-service.test.ts
  </files>
  <action>
**Part A: Register in bbj-module.ts**

1. Add import: `import { BBjCPLService } from './bbj-cpl-service.js';`

2. Add to `BBjAddedServices` type:
   ```typescript
   compiler: {
       BBjCPLService: BBjCPLService
   }
   ```

3. Add to `BBjModule` object:
   ```typescript
   compiler: {
       BBjCPLService: (services) => new BBjCPLService(services),
   }
   ```

This follows the exact pattern of `java: { JavaInteropService: ... }` and `types: { Inferer: ... }`.

**Part B: Add lifecycle tests**

Create `bbj-vscode/test/cpl-service.test.ts` with tests covering the process lifecycle logic.

Since we cannot spawn real bbjcpl in CI, test the service's internal logic:

1. **inFlight map abort-on-resave test:**
   - Create a BBjCPLService instance (will need a mock services object with a mock WorkspaceManager that returns a fake bbjHome)
   - Call `compile('/fake/path.bbj')` — it will fail with ENOENT (expected)
   - Verify the inFlight map is cleaned up after the error
   - This validates the ENOENT graceful degradation path (CPL-04)

2. **getBbjcplPath derives correct path test:**
   - Create service with mock that returns `/opt/bbj` as bbjHome
   - On non-win32 platform, the binary path should be `/opt/bbj/bin/bbjcpl`
   - Test by calling compile and checking the ENOENT error includes the expected path (or expose getBbjcplPath as package-private for testing)

3. **Empty bbjHome returns empty diagnostics test:**
   - Create service with mock that returns `''` as bbjHome
   - Call `compile('/some/file.bbj')` — should return `[]` immediately without spawning

4. **setTimeout updates timeout value test:**
   - Create service, call `setTimeout(5000)`
   - Verify internal state (if accessible) or verify through behavior

For the mock services object, create a minimal mock:
```typescript
function createMockServices(bbjHome: string) {
    return {
        shared: {
            workspace: {
                WorkspaceManager: {
                    getBBjDir: () => bbjHome
                }
            }
        }
    };
}
```

Match existing test patterns — look at how `bbj-vscode/test/document-symbol.test.ts` or other tests set up services. If BBjCPLService requires the full BBjServices type, adjust the mock or use type assertions.

Import pattern:
```typescript
import { describe, test, expect } from 'vitest';
import { BBjCPLService } from '../src/language/bbj-cpl-service.js';
```
  </action>
  <verify>
Run `npm test -- --run bbj-vscode/test/cpl-service.test.ts` — all tests pass. Run `npm test` — no regressions (6 pre-existing failures unchanged). Run `npx tsc --noEmit` — zero type errors.
  </verify>
  <done>
BBjCPLService is registered in BBjModule as `services.compiler.BBjCPLService`. Lifecycle tests confirm ENOENT graceful degradation, empty bbjHome early return, and inFlight map cleanup. Phase 53 can call `services.compiler.BBjCPLService.compile(filePath)` from buildDocuments().
  </done>
</task>

</tasks>

<verification>
1. `BBjCPLService` exported from `bbj-cpl-service.ts` and registered in `bbj-module.ts`
2. `BBjAddedServices` type includes `compiler: { BBjCPLService: BBjCPLService }`
3. `BBjServices` type (union) includes BBjCPLService via BBjAddedServices
4. All lifecycle tests pass
5. TypeScript compiles with zero errors
6. No regressions in existing test suite
7. Process abort race condition handled (Pitfall 2 from RESEARCH.md)
</verification>

<success_criteria>
- BBjCPLService invokes bbjcpl at `{bbj.home}/bin/bbjcpl` with `-N` flag (CPL-02)
- Abort-on-resave correctly cancels in-flight process with race-safe inFlight map cleanup (CPL-04)
- Timeout kills process and returns empty diagnostics (CPL-04)
- ENOENT graceful degradation returns empty diagnostics (CPL-04)
- Service registered in Langium DI, callable as `services.compiler.BBjCPLService`
</success_criteria>

<output>
After completion, create `.planning/phases/52-bbjcpl-foundation/52-02-SUMMARY.md`
</output>
