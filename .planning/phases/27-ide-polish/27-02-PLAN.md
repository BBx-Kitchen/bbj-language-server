---
phase: 27-ide-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/bbj-completion-provider.ts
autonomous: true

must_haves:
  truths:
    - "Typing # inside a class method body immediately opens a completion popup showing fields"
    - "Completion shows fields from the current class (all visibilities) and inherited fields (public and protected only)"
    - "Static fields are included in the completion list"
    - "The # character stays as typed; completion inserts only the field name after it (result: #fieldName)"
    - "Typing # outside a class method body does NOT trigger field completion"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-completion-provider.ts"
      provides: "Trigger character registration and field-filtered completion"
      contains: "triggerCharacters"
  key_links:
    - from: "bbj-vscode/src/language/bbj-completion-provider.ts"
      to: "LSP server capabilities"
      via: "completionOptions property read by Langium during initialization"
      pattern: "completionOptions.*triggerCharacters"
    - from: "bbj-vscode/src/language/bbj-completion-provider.ts"
      to: "AST class/field traversal"
      via: "AstUtils.getContainerOfType for context detection"
      pattern: "getContainerOfType.*isMethodDecl|isBbjClass"
---

<objective>
Add `#` as a completion trigger character that shows class field completions inside method bodies.

Purpose: BBj class fields are prefixed with `#` (e.g., `#name$`, `#count`). Typing `#` should immediately suggest available fields, saving keystrokes and reducing errors. This is a major quality-of-life improvement for BBj OOP development.
Output: Enhanced `BBjCompletionProvider` with trigger character registration and context-aware field filtering.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-ide-polish/27-RESEARCH.md
@bbj-vscode/src/language/bbj-completion-provider.ts
@bbj-vscode/src/language/bbj-module.ts
@bbj-vscode/src/language/bbj-signature-help-provider.ts
@bbj-vscode/src/language/bbj-scope.ts
@bbj-vscode/src/language/generated/ast.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register # trigger character and implement field completion filtering</name>
  <files>bbj-vscode/src/language/bbj-completion-provider.ts</files>
  <action>
Enhance `BBjCompletionProvider` with two additions:

**1. Register `#` as a completion trigger character**

Add a `completionOptions` property to `BBjCompletionProvider`. Langium reads this property during server initialization (via `mergeCompletionProviderOptions`) to register trigger characters in server capabilities. Follow the same pattern as `BBjSignatureHelpProvider.signatureHelpOptions`.

```typescript
readonly completionOptions = {
    triggerCharacters: ['#']
};
```

This is a public readonly property on the class (NOT a getter override like signature help uses).

**2. Override `getCompletion` to filter on `#` trigger**

Override `getCompletion(document, params, cancelToken)` to intercept `#`-triggered completions:

```typescript
override async getCompletion(document: LangiumDocument, params: CompletionParams, cancelToken?: CancellationToken): Promise<CompletionList | undefined> {
    if (params.context?.triggerCharacter === '#') {
        return this.getFieldCompletion(document, params);
    }
    return super.getCompletion(document, params, cancelToken);
}
```

**3. Implement `getFieldCompletion` method**

Create a protected method that:

a) Determines cursor position from `params.position`, converts to offset using `document.textDocument.offsetAt(params.position)`

b) Finds the AST node at cursor using the existing `findLeafNodeAtOffset` function from `bbj-validator.ts`. Import it. Alternatively, use `CstUtils.findLeafNodeBeforeOffset` from Langium if available. The cursor is AFTER the `#`, so find the leaf node at `offset - 1` (the `#` character position).

c) Checks if cursor is inside a class method body:
   - Use `AstUtils.getContainerOfType(astNode, isMethodDecl)` to find enclosing method
   - Use `AstUtils.getContainerOfType(astNode, isBbjClass)` to find enclosing class
   - If EITHER is missing, return `{ items: [], isIncomplete: false }` -- not inside a class method

d) Collects fields from the class and its inheritance hierarchy:
   - **Current class fields:** Get all `FieldDecl` members from the class (all visibilities -- private, protected, public)
   - **Inherited fields:** Walk the superclass chain using `klass.extends` array. For each `extends` entry, resolve via `.ref` to get the referenced class. From superclasses, include only `public` and `protected` fields (not `private`). Use a `Set<string>` to track visited class names for cycle protection (same pattern as `bbj-scope.ts` line 336).
   - **Static fields:** Include static fields from the class and superclasses (per user decision)

e) Maps fields to `CompletionItem[]`:
   - `label`: field name (WITHOUT the `#` prefix -- the `#` is already typed)
   - `kind`: `CompletionItemKind.Variable` (matching the node kind provider)
   - `insertText`: field name only (NOT `#fieldName` -- `#` is already in the document)
   - `detail`: field type if available (e.g., `BBjString`, `BBjNumber`), otherwise `field`
   - `sortText`: field name (for alphabetical sorting)

f) Returns `{ items, isIncomplete: false }`

**Required imports to add:**
- `AstUtils` from `langium`
- `LangiumDocument` from `langium`
- `CompletionList`, `CompletionParams`, `CompletionItem` from `vscode-languageserver`
- `CancellationToken` from `vscode-languageserver`
- `isBbjClass`, `isMethodDecl`, `isFieldDecl`, `FieldDecl`, `BbjClass` from `./generated/ast.js`
- Check if `findLeafNodeAtOffset` needs to be imported from `bbj-validator.ts` or if `CstUtils` from Langium provides equivalent

**Important considerations:**
- The `#` trigger fires at the position AFTER the `#` character. The document already contains `#` at cursor-1.
- Field names in BBj typically include the type suffix (e.g., `name$`, `count`), so the label should be the full field name.
- If the AST is in a broken state (user just typed `#` and parse tree is incomplete), use `document.parseResult.value` to find the root, then walk up from the CST node to find the containing method/class. The CST tree is more reliable than AST when the document has parse errors.
- For finding the class context when AST is broken at the cursor, consider walking CST parent nodes to find the nearest class or method container.
  </action>
  <verify>
Run `npm run build` in bbj-vscode directory to verify TypeScript compilation succeeds.
Run `npm test` in bbj-vscode directory to verify existing tests still pass.
  </verify>
  <done>
- `BBjCompletionProvider` has `completionOptions` with `triggerCharacters: ['#']`
- `getCompletion` intercepts `#` trigger and delegates to `getFieldCompletion`
- `getFieldCompletion` checks for class method context before returning fields
- Fields from current class include all visibilities; inherited fields exclude private
- Completion items use field name without `#` prefix as insertText
- Existing completion behavior unchanged for non-`#` triggers
- Build succeeds, existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Handle edge cases for broken AST context detection</name>
  <files>bbj-vscode/src/language/bbj-completion-provider.ts</files>
  <action>
After implementing the basic field completion, verify and handle these edge cases in the `getFieldCompletion` method:

**Edge case 1: Broken parse tree when user just typed `#`**
When the user types `#` mid-line, the parser may fail to build a clean AST. The CST tree (concrete syntax tree) is still intact. If `findLeafNodeAtOffset` returns a CST node whose `.astNode` is the root `Program` (parse failed), fall back to finding the class context by:
- Getting the text before the cursor position
- Walking the CST tree backward from the cursor to find the nearest `MethodDecl` or `BbjClass` container

If CST fallback also fails to find class context, return empty completion (graceful degradation).

**Edge case 2: `#` typed at top level (outside any class)**
Already handled by the isMethodDecl/isBbjClass check -- return empty list. But verify this works by ensuring the early return fires before any field collection.

**Edge case 3: Classes with no fields**
If the class and its superclass chain have zero fields, return `{ items: [], isIncomplete: false }`. Don't crash or return undefined.

**Edge case 4: Superclass cycle protection**
The visited set from Task 1 prevents infinite loops, but also add a depth limit of 20 levels to prevent excessive traversal in pathological cases.

**Edge case 5: Unresolved superclass reference**
If `klass.extends[i].ref` is undefined (unresolvable super), skip that branch and continue with other superclasses. Do not throw or return empty -- partial results are better than none.

These are refinements to the Task 1 implementation, not a separate method. Verify each edge case is covered in the Task 1 code and add guards as needed.
  </action>
  <verify>
Run `npm run build` in bbj-vscode directory.
Run `npm test` in bbj-vscode directory.
Manually inspect the getFieldCompletion method to verify: empty class returns empty list, unresolved super is skipped, cycle protection via visited Set exists, depth limit is present.
  </verify>
  <done>
- Broken parse tree at cursor gracefully returns empty or partial completion
- Top-level `#` returns empty completion
- Empty class returns empty completion list (not crash)
- Superclass cycle protection prevents infinite loops
- Unresolved superclass references are silently skipped
- Depth limit prevents excessive inheritance traversal
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds in bbj-vscode directory
2. `npm test` passes -- no regressions
3. `BBjCompletionProvider` has `completionOptions` property with `triggerCharacters: ['#']`
4. `getCompletion` override checks `triggerCharacter === '#'`
5. `getFieldCompletion` checks for class method context
6. Field collection includes current class (all visibilities) + inherited (public/protected only)
7. Edge cases handled: broken AST, top-level #, empty class, super cycle, unresolved super
</verification>

<success_criteria>
- Typing `#` inside a class method body triggers field completion
- Completion shows current class fields and inherited public/protected fields
- Typing `#` outside class methods shows no field suggestions
- Build and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/27-ide-polish/27-02-SUMMARY.md`
</output>
