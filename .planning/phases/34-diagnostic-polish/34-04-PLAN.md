---
phase: 34-diagnostic-polish
plan: 04
type: execute
wave: 1
depends_on: [34-03]
files_modified:
  - bbj-vscode/src/language/bbj-document-builder.ts
  - bbj-vscode/test/imports.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Binary/tokenized BBj files (<<bbj>> header) loaded via PREFIX are skipped without crashing the parser"
    - "When a PREFIX file is loaded and parsed, runtime log shows class count and any parse errors"
    - "After PREFIX docs are indexed, reconciliation verifies BbjClass presence and logs results"
    - "USE statements referencing files that resolve via PREFIX directories show no false error after language server finishes loading (when file is source, not binary)"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-document-builder.ts"
      provides: "Binary file detection, runtime logging, post-index verification"
      contains: "<<bbj>>"
    - path: "bbj-vscode/test/imports.test.ts"
      provides: "Test that binary files are skipped during PREFIX loading"
      contains: "binary"
  key_links:
    - from: "bbj-document-builder.ts addImportedBBjDocuments"
      to: "documentFactory.fromString"
      via: "binary header check gates parsing"
      pattern: "<<bbj>>"
    - from: "bbj-document-builder.ts addImportedBBjDocuments"
      to: "console.warn"
      via: "logging after parse shows class count"
      pattern: "BbjClass"
---

<objective>
Fix the remaining PREFIX diagnostic reconciliation gap: binary/tokenized BBj files loaded via PREFIX directories crash the parser silently (no BbjClass nodes exported), so the class never enters the index and the "could not be resolved" error persists even though the file exists on disk.

Purpose: The user reported that `use ::BBjGridExWidget/BBjGridExWidget.bbj::BBjGridExWidget` shows a persistent error despite the file existing in a PREFIX directory. The exhaustive debug session (prefix-reconciliation-final.md) eliminated all code-flow issues (URI comparison, reconciliation timing, notification ordering) and concluded the most likely practical cause is that the file content is a tokenized/binary BBj file (starts with `<<bbj>>` header) that cannot be parsed by the Langium parser, producing zero BbjClass nodes in the index.

Output: Updated bbj-document-builder.ts with binary file detection, runtime logging, and post-index verification. Updated test file with binary file skip test.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-diagnostic-polish/34-03-SUMMARY.md
@.planning/phases/34-diagnostic-polish/34-final-UAT.md
@.planning/debug/prefix-reconciliation-final.md
@bbj-vscode/src/language/bbj-document-builder.ts
@bbj-vscode/src/language/bbj-validator.ts
@bbj-vscode/test/imports.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add binary file detection, runtime logging, and post-index verification to addImportedBBjDocuments</name>
  <files>bbj-vscode/src/language/bbj-document-builder.ts</files>
  <action>
Modify `addImportedBBjDocuments` in bbj-document-builder.ts to handle binary/tokenized BBj files and add runtime observability:

**1. Binary file detection (before `documentFactory.fromString` at line 144):**
After `readFile` succeeds and before calling `fromString`, check if the file content starts with `<<bbj>>` (the tokenized/binary BBj file header). If it does, log a warning and skip parsing:
```typescript
if (docFileData) {
    // Skip binary/tokenized BBj files that can't be parsed
    if (docFileData.text.startsWith('<<bbj>>')) {
        console.warn(`[PREFIX] Skipping binary/tokenized file: ${docFileData.uri.fsPath}`);
        continue;
    }
    const document = documentFactory.fromString(docFileData.text, docFileData.uri);
    // ... rest
}
```

**2. Post-parse class count logging (after `fromString`):**
After creating the document and adding it to langiumDocuments, log the import path and whether it was newly added or already present:
```typescript
if (!langiumDocuments.hasDocument(document.uri)) {
    langiumDocuments.addDocument(document);
    addedDocuments.push(document.uri);
    console.debug(`[PREFIX] Loaded: ${importPath} -> ${document.uri.fsPath} (new document)`);
} else {
    console.debug(`[PREFIX] Already loaded: ${importPath} -> ${document.uri.fsPath}`);
}
```

**3. Post-index verification in revalidateUseFilePathDiagnostics:**
Add logging in `revalidateUseFilePathDiagnostics` to help diagnose when reconciliation runs but doesn't clear a diagnostic. Inside the filter callback, after computing `nowResolved`, if NOT resolved, log what was searched and how many BbjClass entries exist at those URIs:
```typescript
if (!nowResolved) {
    // Log diagnostic details for debugging PREFIX resolution failures
    const indexEntries = this.indexManager.allElements(BbjClass.$type).filter(bbjClass => {
        return adjustedFileUris.some(adjustedFileUri =>
            normalize(bbjClass.documentUri.fsPath).toLowerCase() === normalize(adjustedFileUri.fsPath).toLowerCase()
        );
    });
    console.warn(`[PREFIX] Reconciliation: '${cleanPath}' NOT resolved. ${indexEntries.length} BbjClass entries found at searched URIs. Searched: ${adjustedFileUris.map(u => u.fsPath).join(', ')}`);
}
```

**4. Also in revalidateUseFilePathDiagnostics**, when diagnostics ARE removed, log that too:
After the `if (document.diagnostics.length !== originalLength)` check:
```typescript
if (document.diagnostics.length !== originalLength) {
    console.debug(`[PREFIX] Reconciliation: cleared ${originalLength - document.diagnostics.length} USE file-path diagnostic(s) for ${document.uri.fsPath}`);
    await this.notifyDocumentPhase(document, DocumentState.Validated, cancelToken);
}
```

Do NOT change the URI comparison logic (already fixed in 34-03). Do NOT change the error message format (already includes searched paths from 34-03). Focus purely on binary detection, logging, and post-index verification.
  </action>
  <verify>
Run `npm test` from `bbj-vscode/` directory. All 433 previously passing tests must still pass. TypeScript compilation must succeed with `npm run build` (or equivalent).
  </verify>
  <done>
Binary/tokenized BBj files starting with `<<bbj>>` are skipped during PREFIX loading with a warning log. Runtime logging shows PREFIX file loading status (new/already loaded/binary skipped). Post-index verification in reconciliation logs when a diagnostic could NOT be cleared, showing the number of BbjClass entries found and URIs searched.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add test for binary file skipping during PREFIX loading</name>
  <files>bbj-vscode/test/imports.test.ts</files>
  <action>
Add a test to the existing `Prefix tests` describe block in `imports.test.ts` that verifies binary/tokenized files are handled gracefully.

**Test: "USE referencing a binary BBj file does not crash and shows appropriate error"**

In the `Prefix tests` beforeAll, add a second pre-parsed document that simulates a binary file. Since EmptyFileSystem is used (no real readFile), test the binary detection logic by verifying the document builder's behavior. The test approach:

1. Pre-parse a document with `<<bbj>>` as its content at a PREFIX-like URI. Since `parseHelper` calls `fromString` directly (bypassing the binary check in `addImportedBBjDocuments`), the parser will produce an empty parse tree. This simulates what happens when a binary file is parsed -- zero BbjClass nodes exported.

2. Create a test document with a USE statement referencing a file at that URI path. The USE should produce a file-path error because no BbjClass exists in the index at that URI (the binary file has no class declarations).

```typescript
test('USE referencing file with no classes (e.g., binary) shows file-path error', async () => {
    // Pre-parse binary-like content at a PREFIX URI - produces no BbjClass nodes
    await parse('<<bbj>>', { documentUri: 'file:///prefix/BinaryFile/BinaryFile.bbj' });

    const document = await parse(`
        use ::BinaryFile/BinaryFile.bbj::SomeClass
    `, { documentUri: 'file:///prefix/test-binary.bbj', validation: true });
    expectNoParserLexerErrors(document);
    // Should have a file-path error because the "binary" file has no BbjClass in the index
    const filePathErrors = document.diagnostics?.filter(d =>
        d.severity === 1 && d.message.startsWith("File '")
    ) ?? [];
    expect(filePathErrors).toHaveLength(1);
    expect(filePathErrors[0].message).toContain("could not be resolved");
});
```

This test documents the expected behavior: when a PREFIX file is binary/tokenized and has no parseable class declarations, the USE statement correctly shows an error. The binary check in `addImportedBBjDocuments` prevents even loading such files (tested via the source code change in Task 1, exercised in real-world PREFIX scenarios).
  </action>
  <verify>
Run `npm test` from `bbj-vscode/` directory. The new test must pass. All 433+ previously passing tests must still pass.
  </verify>
  <done>
Test exists in `Prefix tests` block verifying that files without BbjClass nodes (simulating binary/tokenized files) produce a file-path error on the USE statement. Test passes alongside all existing tests.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` (or TypeScript compilation) succeeds with no errors in bbj-document-builder.ts
2. `npm test` passes: all previously passing tests plus the new binary file test
3. Code review: `addImportedBBjDocuments` checks for `<<bbj>>` before calling `fromString`
4. Code review: runtime logging covers all three scenarios (binary skipped, new doc loaded, already loaded)
5. Code review: reconciliation logs when a diagnostic is NOT cleared (with BbjClass count and searched URIs)
</verification>

<success_criteria>
- Binary/tokenized BBj files (starting with `<<bbj>>`) are detected and skipped during PREFIX loading
- Runtime logging at `console.debug` and `console.warn` levels provides visibility into PREFIX resolution
- Post-index verification in reconciliation logs explain WHY a diagnostic was not cleared
- All existing tests pass with zero regressions
- New test covers the binary file scenario
</success_criteria>

<output>
After completion, create `.planning/phases/34-diagnostic-polish/34-04-SUMMARY.md`
</output>
