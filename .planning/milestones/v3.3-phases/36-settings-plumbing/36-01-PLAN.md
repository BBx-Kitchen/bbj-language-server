---
phase: 36-settings-plumbing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/package.json
  - bbj-vscode/src/language/main.ts
  - bbj-vscode/test/logger.test.ts
autonomous: true

must_haves:
  truths:
    - "User can toggle bbj.debug in VS Code settings UI and see it described correctly"
    - "Changing bbj.debug from false to true switches logger to DEBUG level without LS restart"
    - "Changing bbj.debug from true to false switches logger to WARN level without LS restart"
    - "Startup output is quiet (ERROR level only) until first document validation completes"
    - "After workspace init, logger applies WARN (default) or DEBUG (if user enabled)"
    - "Logger level persists correctly across multiple setting changes (no state desync)"
  artifacts:
    - path: "bbj-vscode/package.json"
      provides: "bbj.debug boolean setting schema"
      contains: "bbj.debug"
    - path: "bbj-vscode/src/language/main.ts"
      provides: "onDidChangeConfiguration handler with logger integration and quiet startup"
      contains: "logger.setLevel"
    - path: "bbj-vscode/test/logger.test.ts"
      provides: "Tests for settings-to-logger integration"
      contains: "setLevel"
  key_links:
    - from: "bbj-vscode/src/language/main.ts"
      to: "bbj-vscode/src/language/logger.ts"
      via: "import logger and LogLevel, call logger.setLevel()"
      pattern: "import.*logger.*LogLevel.*from.*logger"
    - from: "bbj-vscode/src/language/main.ts"
      to: "onDidChangeConfiguration handler"
      via: "config.debug === true maps to LogLevel.DEBUG vs LogLevel.WARN"
      pattern: "config\\.debug.*LogLevel"
    - from: "bbj-vscode/src/language/main.ts"
      to: "onBuildPhase(DocumentState.Validated)"
      via: "quiet startup applies user's level after workspace init"
      pattern: "workspaceInitialized.*logger\\.setLevel"
---

<objective>
Wire the bbj.debug boolean setting from VS Code settings UI through the LSP configuration protocol to the logger singleton, enabling hot-reloadable debug output control.

Purpose: Completes the settings plumbing so users can toggle verbose logging on/off without restarting the language server, with a quiet startup experience by default.
Output: Extended main.ts with logger-aware configuration handler, bbj.debug schema in package.json, integration tests.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-logger-infrastructure/35-01-SUMMARY.md
@.planning/phases/36-settings-plumbing/36-RESEARCH.md
@bbj-vscode/src/language/logger.ts
@bbj-vscode/src/language/main.ts
@bbj-vscode/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bbj.debug setting schema and wire logger into onDidChangeConfiguration handler</name>
  <files>bbj-vscode/package.json, bbj-vscode/src/language/main.ts</files>
  <action>
**package.json changes:**

Add `bbj.debug` boolean setting to `contributes.configuration.properties` (insert BEFORE the existing `bbj.home` entry so it appears first in settings UI as the most commonly toggled setting):

```json
"bbj.debug": {
  "type": "boolean",
  "default": false,
  "description": "Enable debug logging in the BBj language server. Shows detailed diagnostics, class loading, and validation messages.",
  "scope": "window"
}
```

**main.ts changes:**

1. Add import at top of file:
```typescript
import { logger, LogLevel } from './logger.js';
```

2. Modify the existing `onBuildPhase(DocumentState.Validated)` callback (line 67-69) to also apply the user's debug level after quiet startup period ends. Store a reference to the initial debug preference that may arrive via `onDidChangeConfiguration` before workspace init:

```typescript
// Track pending debug setting received before workspace init
let pendingDebugLevel: LogLevel = LogLevel.WARN; // Default when debug=false

// Guard: skip Java class reload until initial workspace build is complete
let workspaceInitialized = false;
shared.workspace.DocumentBuilder.onBuildPhase(DocumentState.Validated, () => {
    if (!workspaceInitialized) {
        workspaceInitialized = true;
        // Quiet startup complete: apply user's debug preference
        logger.setLevel(pendingDebugLevel);
    }
});
```

3. Extend the existing `onDidChangeConfiguration` handler. Add debug setting handling AFTER the `ConfigurationProvider.updateConfiguration(change)` call and BEFORE the `workspaceInitialized` check. The debug flag applies immediately at any time (not gated by workspaceInitialized), but during startup it stores the value for deferred application:

```typescript
connection.onDidChangeConfiguration(async (change) => {
    // Forward to Langium's ConfigurationProvider so its internals stay in sync
    shared.workspace.ConfigurationProvider.updateConfiguration(change);

    // Only process BBj-specific setting changes
    const config = change.settings?.bbj;
    if (!config) {
        return;
    }

    // Apply debug setting to logger
    if (config.debug !== undefined) {
        const newLevel = config.debug === true ? LogLevel.DEBUG : LogLevel.WARN;
        if (workspaceInitialized) {
            // Post-startup: apply immediately
            logger.setLevel(newLevel);
        } else {
            // Pre-startup: store for deferred application (quiet startup mode)
            pendingDebugLevel = newLevel;
        }
    }

    // Skip Java class reload during initial startup -- initializeWorkspace handles it
    if (!workspaceInitialized) {
        // Still apply non-reload settings
        const wsManager = shared.workspace.WorkspaceManager as BBjWorkspaceManager;
        wsManager.setConfigPath(config.configPath || '');
        return;
    }

    // ... rest of existing Java interop reload logic stays unchanged ...
});
```

Key implementation notes:
- Use `config.debug === true` for explicit boolean check (handles undefined/null safely)
- Debug off maps to LogLevel.WARN (not ERROR) so warnings are still visible post-startup
- During startup (ERROR level), debug setting is stored in `pendingDebugLevel` for deferred application
- After startup, `onBuildPhase` applies `pendingDebugLevel` once
- After that, all `onDidChangeConfiguration` calls apply immediately via `logger.setLevel()`
- The existing Java interop logic in the handler MUST remain unchanged -- only add the debug handling above it
- Do NOT add `debug` to `initializationOptions` in extension.ts (it flows via `didChangeConfiguration` per research recommendation)
  </action>
  <verify>
Run `cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npx tsc -b tsconfig.json --noEmit` to verify TypeScript compilation succeeds with zero errors. Verify that `bbj.debug` appears in package.json under `contributes.configuration.properties`. Verify main.ts imports logger and LogLevel from './logger.js'. Verify the onDidChangeConfiguration handler calls `logger.setLevel()` with level derived from `config.debug === true`.
  </verify>
  <done>
- package.json contains `bbj.debug` boolean setting with default false and descriptive text
- main.ts imports `logger` and `LogLevel` from `./logger.js`
- onDidChangeConfiguration handler maps `config.debug === true` to LogLevel.DEBUG, false/undefined to LogLevel.WARN
- Quiet startup: logger stays at ERROR until onBuildPhase(Validated) fires, then applies pendingDebugLevel
- Post-startup: logger.setLevel() called immediately on each config change
- TypeScript compiles with zero errors
- All existing handler logic (Java interop, configPath) unchanged
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for settings-to-logger wiring</name>
  <files>bbj-vscode/test/logger.test.ts</files>
  <action>
Extend the existing `bbj-vscode/test/logger.test.ts` file with a new `describe('settings integration')` block. These tests verify the mapping logic that Phase 36 introduces (debug boolean to LogLevel conversion) without requiring a running LSP server.

Add the following test cases to the existing test file:

```typescript
describe('settings integration', () => {
    // Test the debug-to-level mapping logic
    it('maps debug=true to LogLevel.DEBUG', () => {
        const debugEnabled = true;
        const level = debugEnabled === true ? LogLevel.DEBUG : LogLevel.WARN;
        expect(level).toBe(LogLevel.DEBUG);
    });

    it('maps debug=false to LogLevel.WARN', () => {
        const debugEnabled = false;
        const level = debugEnabled === true ? LogLevel.DEBUG : LogLevel.WARN;
        expect(level).toBe(LogLevel.WARN);
    });

    it('maps debug=undefined to LogLevel.WARN', () => {
        const debugEnabled = undefined;
        const level = debugEnabled === true ? LogLevel.DEBUG : LogLevel.WARN;
        expect(level).toBe(LogLevel.WARN);
    });

    it('maps debug=null to LogLevel.WARN', () => {
        const debugEnabled = null;
        const level = (debugEnabled as unknown) === true ? LogLevel.DEBUG : LogLevel.WARN;
        expect(level).toBe(LogLevel.WARN);
    });

    // Test that setLevel correctly applies new levels
    it('setLevel updates logger behavior for hot-reload', () => {
        logger.setLevel(LogLevel.WARN);
        // debug should be suppressed
        const debugSpy = vi.spyOn(console, 'log');
        logger.debug('should not appear');
        // Only the setLevel log should have appeared, not the debug message
        const debugCalls = debugSpy.mock.calls.filter(c =>
            typeof c[0] === 'string' && !c[0].startsWith('Log level')
        );
        expect(debugCalls).toHaveLength(0);
        debugSpy.mockRestore();

        // Now switch to DEBUG
        logger.setLevel(LogLevel.DEBUG);
        const debugSpy2 = vi.spyOn(console, 'log');
        logger.debug('should appear now');
        const debugCalls2 = debugSpy2.mock.calls.filter(c =>
            typeof c[0] === 'string' && c[0].includes('should appear now')
        );
        expect(debugCalls2).toHaveLength(1);
        debugSpy2.mockRestore();
    });

    // Test quiet startup -> post-startup transition
    it('quiet startup: ERROR level suppresses warn and info', () => {
        logger.setLevel(LogLevel.ERROR);
        const warnSpy = vi.spyOn(console, 'warn');
        const logSpy = vi.spyOn(console, 'log');

        logger.warn('startup warn');
        logger.info('startup info');
        logger.debug('startup debug');

        // warn should be suppressed at ERROR level
        const warnCalls = warnSpy.mock.calls.filter(c =>
            typeof c[0] === 'string' && c[0].includes('startup')
        );
        expect(warnCalls).toHaveLength(0);

        // info and debug should be suppressed at ERROR level
        const infoCalls = logSpy.mock.calls.filter(c =>
            typeof c[0] === 'string' && c[0].includes('startup')
        );
        expect(infoCalls).toHaveLength(0);

        warnSpy.mockRestore();
        logSpy.mockRestore();
    });

    it('error always emits regardless of level', () => {
        logger.setLevel(LogLevel.ERROR);
        const errorSpy = vi.spyOn(console, 'error');
        logger.error('critical failure');
        expect(errorSpy).toHaveBeenCalledWith('critical failure');
        errorSpy.mockRestore();
    });

    // Test level persistence across multiple changes (no desync)
    it('multiple setLevel calls persist correctly', () => {
        logger.setLevel(LogLevel.DEBUG);
        expect(logger.isDebug()).toBe(true);
        logger.setLevel(LogLevel.WARN);
        expect(logger.isDebug()).toBe(false);
        logger.setLevel(LogLevel.DEBUG);
        expect(logger.isDebug()).toBe(true);
        logger.setLevel(LogLevel.ERROR);
        expect(logger.isDebug()).toBe(false);
    });
});
```

Use `vi` (vitest's built-in mock API) for console spying, consistent with the existing test file patterns. Reset logger level in each test to avoid cross-test pollution (or use `beforeEach`/`afterEach` if the existing file has that pattern -- check and match).

Run all tests after adding to ensure zero regressions.
  </action>
  <verify>
Run `cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npx vitest run test/logger.test.ts` to verify all tests pass (both existing 17 tests and new integration tests). Verify zero test failures.
  </verify>
  <done>
- logger.test.ts contains new `settings integration` describe block with 7+ test cases
- Tests verify: debug-to-level mapping (true/false/undefined/null), hot-reload via setLevel, quiet startup suppression, error always emits, level persistence across multiple changes
- All existing tests continue to pass (zero regressions)
- All new tests pass
  </done>
</task>

</tasks>

<verification>
Phase 36 success criteria verification:

1. **User can toggle `bbj.debug` setting in VS Code without LS restart:**
   - Verify `bbj.debug` exists in package.json with `"type": "boolean"` and `"default": false`
   - Verify `configurationSection: 'bbj'` in extension.ts synchronize options (already exists)
   - Verify onDidChangeConfiguration handler reads `config.debug` and calls `logger.setLevel()`

2. **Setting change triggers onDidChangeConfiguration that updates logger level immediately:**
   - Verify handler has `config.debug !== undefined` guard
   - Verify `config.debug === true` maps to `LogLevel.DEBUG`
   - Verify `config.debug !== true` maps to `LogLevel.WARN`
   - Verify `logger.setLevel(newLevel)` is called when `workspaceInitialized === true`

3. **Quiet startup mode gates verbose output until first document validation:**
   - Verify logger defaults to `LogLevel.ERROR` (from logger.ts)
   - Verify `pendingDebugLevel` stores user's preference before workspace init
   - Verify `onBuildPhase(DocumentState.Validated)` callback calls `logger.setLevel(pendingDebugLevel)`

4. **Logger level persists correctly across setting changes (no state desync):**
   - Verify `ConfigurationProvider.updateConfiguration(change)` is always called first
   - Verify tests demonstrate multiple setLevel transitions without desync
   - Verify no caching of debug flag outside of logger singleton

Run: `cd /Users/beff/_workspace/bbj-language-server/bbj-vscode && npx tsc -b tsconfig.json --noEmit && npx vitest run test/logger.test.ts`
</verification>

<success_criteria>
- TypeScript compilation succeeds with zero errors
- All logger tests pass (existing 17 + new 7+ integration tests)
- bbj.debug setting registered in VS Code configuration schema
- main.ts imports and uses logger.setLevel() in onDidChangeConfiguration handler
- Quiet startup: ERROR level until workspace init, then WARN or DEBUG
- Hot-reload: subsequent config changes apply immediately
</success_criteria>

<output>
After completion, create `.planning/phases/36-settings-plumbing/36-01-SUMMARY.md`
</output>
