---
phase: 35-logger-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/logger.ts
  - bbj-vscode/test/logger.test.ts
autonomous: true

must_haves:
  truths:
    - "Developer can import logger singleton and call debug(), info(), warn(), error() methods"
    - "Messages below current log level are silently dropped with no output"
    - "Lazy callbacks are never invoked when their log level is disabled"
    - "Scoped loggers prepend component tag on debug messages only"
    - "setLevel() announces level changes via console output"
    - "Default level is ERROR (quietest startup before settings load)"
  artifacts:
    - path: "bbj-vscode/src/language/logger.ts"
      provides: "Logger singleton with LogLevel enum, lazy evaluation, scoped factory"
      exports: ["logger", "LogLevel"]
    - path: "bbj-vscode/test/logger.test.ts"
      provides: "Unit tests verifying level filtering, lazy evaluation, scoped loggers"
      contains: "describe.*logger"
  key_links:
    - from: "logger.ts LogLevel enum"
      to: "currentLevel comparison"
      via: "numeric >= operator"
      pattern: "currentLevel >= LogLevel"
    - from: "logger.scoped()"
      to: "currentLevel module variable"
      via: "closure over module-scoped state"
      pattern: "currentLevel >= LogLevel\\.DEBUG"
---

<objective>
Create the logger singleton module and unit tests for level-based logging with zero overhead when disabled.

Purpose: Foundation layer that all subsequent phases (settings plumbing, console migration) build upon. The logger must work immediately at module import time, before DI containers or LSP connections initialize.

Output: `logger.ts` (~60 lines) exporting `logger` singleton and `LogLevel` enum, plus `logger.test.ts` verifying all success criteria.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/35-logger-infrastructure/35-CONTEXT.md
@.planning/phases/35-logger-infrastructure/35-RESEARCH.md

@bbj-vscode/tsconfig.json
@bbj-vscode/test/utils.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create logger singleton module</name>
  <files>bbj-vscode/src/language/logger.ts</files>
  <action>
Create `bbj-vscode/src/language/logger.ts` implementing the logger singleton per all locked CONTEXT.md decisions. Target ~60 lines.

**LogLevel enum** (regular numeric enum, NOT const enum):
- ERROR = 0, WARN = 1, INFO = 2, DEBUG = 3
- Numeric values enable O(1) `>=` comparison for level filtering

**LogMessage type:**
- `string | (() => string)` union type for lazy evaluation
- Helper function `evaluateMessage()` that calls function only if it's a callback

**Singleton logger object** with these methods:
- `setLevel(level: LogLevel)`: Updates module-scoped `currentLevel`, announces change via `console.log(`Log level changed to ${LogLevel[level]}`)` — uses reverse enum mapping for human-readable name
- `isDebug()`: Returns `currentLevel >= LogLevel.DEBUG` for conditional blocks
- `debug(message: LogMessage)`: If `currentLevel >= LogLevel.DEBUG`, evaluates message and outputs with ISO 8601 timestamp prefix: `console.log(`[${new Date().toISOString()}] ${msg}`)`. No output if level insufficient.
- `info(message: LogMessage)`: If `currentLevel >= LogLevel.INFO`, outputs plain text via `console.log()`. No level prefix, no timestamp, no tags.
- `warn(message: LogMessage)`: If `currentLevel >= LogLevel.WARN`, outputs plain text via `console.warn()`. No level prefix.
- `error(message: LogMessage)`: ALWAYS outputs regardless of level via `console.error()`. No level prefix.
- `scoped(component: string)`: Returns object with single `debug(message: LogMessage)` method that prepends component tag AND timestamp: `console.log(`[${timestamp}] [${component}] ${msg}`)`. Uses closure over module-scoped `currentLevel` — no parent reference needed.

**Module-scoped state:**
- `let currentLevel: LogLevel = LogLevel.ERROR` — default quietest possible startup (per locked decision)

**Exports:**
- Named exports: `export { logger, LogLevel }`
- Also export `LogMessage` type for consumers that need the union type

**What NOT to do:**
- Do NOT use const enum (compatibility issues with isolatedModules)
- Do NOT use class-based getInstance() pattern (ES6 modules are natural singletons)
- Do NOT add level prefixes like `[INFO]` or `[WARN]` to output (locked decision: no level prefix)
- Do NOT add timestamps to info/warn/error output (locked decision: timestamps on debug only)
- Do NOT abstract console.error() — raw console.error() calls in codebase stay raw (Phase 37 scope)
  </action>
  <verify>
Run `npx tsc --noEmit` from bbj-vscode directory — zero type errors. Manually verify:
1. File exports logger, LogLevel, and LogMessage
2. LogLevel uses regular enum (not const enum)
3. Default level is ERROR
4. debug() includes timestamp, info/warn/error do not
5. scoped() returns object with debug method only
6. File is approximately 60 lines
  </verify>
  <done>
logger.ts exists at bbj-vscode/src/language/logger.ts, exports logger singleton with debug/info/warn/error/setLevel/isDebug/scoped methods and LogLevel enum. TypeScript compilation succeeds with zero errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create logger unit tests</name>
  <files>bbj-vscode/test/logger.test.ts</files>
  <action>
Create `bbj-vscode/test/logger.test.ts` using vitest (import from 'vitest') to verify all 4 phase success criteria.

**Test structure:**

```
describe('Logger', () => {
  // Reset logger level before each test
  beforeEach(() => logger.setLevel(LogLevel.ERROR))

  describe('level filtering', () => {
    // Test: at ERROR level, only error() produces output
    // Test: at WARN level, warn() and error() produce output, info/debug silent
    // Test: at INFO level, info/warn/error produce output, debug silent
    // Test: at DEBUG level, all methods produce output
  })

  describe('lazy evaluation', () => {
    // Test: callback NOT called when level is below threshold
    // Test: callback IS called when level meets threshold
    // Use vi.fn() mock to track callback invocation
  })

  describe('zero overhead', () => {
    // Test: at ERROR level, debug callback never invoked
    // This proves zero overhead — enum comparison short-circuits before callback evaluation
  })

  describe('scoped logger', () => {
    // Test: scoped debug prepends [component] tag
    // Test: scoped debug respects level filtering
    // Test: scoped logger only has debug method
  })

  describe('setLevel', () => {
    // Test: setLevel changes effective level
    // Test: setLevel announces change (check console.log output)
  })

  describe('isDebug', () => {
    // Test: returns false at ERROR/WARN/INFO
    // Test: returns true at DEBUG
  })

  describe('output format', () => {
    // Test: debug messages include ISO timestamp
    // Test: info/warn/error messages are plain text (no timestamp, no prefix)
    // Test: scoped debug includes both timestamp and component tag
  })
})
```

**Console mocking strategy:**
- Use `vi.spyOn(console, 'log')` / `vi.spyOn(console, 'warn')` / `vi.spyOn(console, 'error')` to capture output
- Reset spies in afterEach with `vi.restoreAllMocks()`
- For the setLevel announcement test, account for the console.log call from setLevel itself

**Import:**
```typescript
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { logger, LogLevel } from '../src/language/logger.js';
```

Note the `.js` extension on the import — project uses Node16 module resolution (per tsconfig.json).
  </action>
  <verify>
Run `cd bbj-vscode && npm test` (which runs `vitest run`) — all logger tests pass. Verify test count covers:
- Level filtering (4 tests, one per level)
- Lazy evaluation (2 tests: called/not-called)
- Scoped logger (3 tests: tag format, level filter, API surface)
- setLevel (2 tests: changes level, announces)
- isDebug (2 tests: true/false)
- Output format (3 tests: debug timestamp, plain info/warn/error, scoped format)
Total: ~16 tests, all green.
  </verify>
  <done>
logger.test.ts passes all tests. Level filtering verified across all 4 levels, lazy evaluation confirmed via mock callback tracking, scoped loggers verified to prepend component tags on debug only, output format confirmed (timestamps on debug, plain text on info/warn/error).
  </done>
</task>

</tasks>

<verification>
1. `cd bbj-vscode && npx tsc --noEmit` — zero type errors (success criterion 4)
2. `cd bbj-vscode && npm test` — all tests pass including new logger tests
3. Manual check: `logger.ts` exports are importable with `import { logger, LogLevel } from './logger.js'` (success criterion 1)
4. Test coverage confirms level filtering behavior (success criterion 2)
5. Lazy callback test confirms zero overhead when disabled (success criterion 3)
</verification>

<success_criteria>
1. Developer can import logger singleton and call logger.info(), logger.warn(), logger.error(), logger.debug() methods
2. Logger respects LogLevel enum (DEBUG, INFO, WARN, ERROR) and silently drops messages below current level
3. Logger calls have zero overhead when disabled (enum comparison only, no string formatting) — verified by mock callback never invoked
4. Logger builds and type-checks with existing TypeScript configuration — tsc --noEmit succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/35-logger-infrastructure/35-01-SUMMARY.md`
</output>
