---
phase: 56-production-fixme-todo-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/bbj-linker.ts
  - bbj-vscode/src/language/bbj-scope.ts
  - bbj-vscode/src/language/java-javadoc.ts
  - java-interop/src/main/java/bbj/interop/InteropService.java
autonomous: true
requirements:
  - FIX-01
  - FIX-02
  - FIX-03
  - FIX-04

must_haves:
  truths:
    - "No FIXME comments remain in the four target production files"
    - "Each former FIXME location has either a working fix or a clear explanatory comment documenting why the current behavior is correct"
    - "npm test passes with zero regressions after all changes"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-linker.ts"
      provides: "Receiver ref FIXME resolved or documented"
      contains: "no FIXME on line 74"
    - path: "bbj-vscode/src/language/bbj-scope.ts"
      provides: "Orphaned AST hack documented as intentional"
      contains: "no FIXME HACK on line 209"
    - path: "bbj-vscode/src/language/java-javadoc.ts"
      provides: "Cancellation FIXME documented as acceptable"
      contains: "no FIXME on line 54"
    - path: "java-interop/src/main/java/bbj/interop/InteropService.java"
      provides: "Inner class name FIXME resolved or documented"
      contains: "no FIXME on line 166"
  key_links:
    - from: "bbj-vscode/src/language/bbj-linker.ts"
      to: "test suite"
      via: "npm test"
      pattern: "npm test.*exit 0"
---

<objective>
Resolve all 4 production FIXME comments by investigating each one and either fixing the underlying issue or replacing the FIXME with a clear explanatory comment documenting why the current behavior is intentional.

Purpose: Eliminate ambiguous technical debt markers from production code so every deferred decision is either resolved or explicitly documented with rationale.
Output: 4 files updated with FIXME comments removed; each replaced by fix or documentation.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/56-production-fixme-todo-resolution/56-CONTEXT.md
@bbj-vscode/src/language/bbj-linker.ts
@bbj-vscode/src/language/bbj-scope.ts
@bbj-vscode/src/language/java-javadoc.ts
@java-interop/src/main/java/bbj/interop/InteropService.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Resolve FIX-01 and FIX-02 in linker and scope provider</name>
  <files>bbj-vscode/src/language/bbj-linker.ts, bbj-vscode/src/language/bbj-scope.ts</files>
  <action>
**FIX-01 (`bbj-linker.ts:74` — receiver ref FIXME):**

Investigate `doLink()` at line 71-85. The FIXME says "try to not resolve receiver ref". The code checks if the receiver is a SymbolRef pointing to a template string array declaration (DIM key$:"MY_COL:K(10)") and skips linking member calls to those. This is intentional behavior — resolving the receiver ref eagerly is necessary to detect template string arrays and avoid false member-call linking on structured record fields.

**Claude's discretion decision:** If investigation confirms the eager resolution is necessary for the template string guard (which it appears to be — the `isArrayDecl(receiver.symbol.ref)` check requires the receiver to already be resolved), replace the FIXME with a 1-3 line explanatory comment explaining WHY receiver resolution is intentional here. Example:

```typescript
// Receiver ref must be resolved here to detect template string arrays.
// Template string fields (e.g. key.my_col from DIM key$:"MY_COL:K(10)")
// are not real member calls and must skip linking.
```

If investigation reveals the resolution CAN be deferred safely, implement the deferral and remove the FIXME.

**FIX-02 (`bbj-scope.ts:209` — orphaned AST HACK):**

Per user decision: Document as intentional. Replace `// FIXME HACK for orphaned AST Instances` with a 1-3 line comment explaining the Langium AST lifecycle constraint. The issue is that AST nodes can lose their `$container` chain during re-parsing, but `$cstNode.astNode` still points to a valid container. This fallback is a necessary workaround for Langium's AST lifecycle.

Replace with something like:
```typescript
// Langium AST lifecycle: nodes may lose their $container chain during
// re-parsing, but $cstNode.astNode retains a valid container reference.
// Fall back to the CST-based container to maintain scope resolution.
```
  </action>
  <verify>Run `npm test` from the project root — all tests pass. Grep for `FIXME` in both files — zero matches.</verify>
  <done>bbj-linker.ts line 74 FIXME replaced with explanatory comment (or fixed). bbj-scope.ts line 209 FIXME HACK replaced with documentation comment. No test regressions.</done>
</task>

<task type="auto">
  <name>Task 2: Resolve FIX-03 and FIX-04 in javadoc provider and InteropService</name>
  <files>bbj-vscode/src/language/java-javadoc.ts, java-interop/src/main/java/bbj/interop/InteropService.java</files>
  <action>
**FIX-03 (`java-javadoc.ts:54` — cancellation FIXME):**

Per user decision: Document as acceptable. The javadoc provider's `initialize()` method checks `cancelToken.isCancellationRequested` in its loop over roots. The FIXME notes that initialization "will not be re-triggered" after cancellation. However, this is harmless — javadoc loading completing is fine, and cancellation during initialization only means some roots may be skipped. The provider still marks itself as initialized.

Replace `// FIXME will not be re-triggered return;` with:
```typescript
// Cancellation during javadoc initialization is harmless — any roots
// already processed remain available. Skipping remaining roots is
// acceptable since javadoc is a best-effort enhancement.
```

Keep the existing `logger.warn` and the early return flow as-is (the code after the comment already returns).

**FIX-04 (`InteropService.java:166` — inner class names):**

Investigate `loadClassInfo()` at line 165. The FIXME says "handle inner class names". Looking at `loadClassByName()` at line 217, there is ALREADY a fallback that handles nested class FQNs by converting `Outer.Inner` to `Outer$Inner` when `Class.forName()` fails. This was fixed as part of issue #314 (jSoup inner class crash).

**Claude's discretion decision:** Since the `loadClassByName()` method already handles `Outer.Inner` → `Outer$Inner` conversion (lines 221-244), the FIXME in `loadClassInfo()` is stale. The inner class name handling IS implemented in the downstream call.

Replace `// FIXME handle inner class names` with:
```java
// Inner class names (Outer.Inner) are handled by loadClassByName(),
// which converts dot-separated names to $-separated JVM names when
// Class.forName() fails. See #314 for context.
```
  </action>
  <verify>Run `npm test` from the project root — all tests pass. Grep for `FIXME` in both files — zero matches. For Java file, verify the project still compiles: `cd java-interop && ./gradlew compileJava` (or confirm no compilation issues).</verify>
  <done>java-javadoc.ts line 54 FIXME replaced with documentation comment. InteropService.java line 166 FIXME replaced with documentation comment referencing #314. No test regressions.</done>
</task>

</tasks>

<verification>
1. `npm test` passes with zero failures
2. `grep -r "FIXME" bbj-vscode/src/language/bbj-linker.ts bbj-vscode/src/language/bbj-scope.ts bbj-vscode/src/language/java-javadoc.ts java-interop/src/main/java/bbj/interop/InteropService.java` returns zero matches
3. Each former FIXME location has a clear explanatory comment
</verification>

<success_criteria>
All 4 production FIXMEs (FIX-01 through FIX-04) are either fixed with a working implementation or replaced with explanatory documentation comments. No test regressions. No ambiguous FIXME markers remain in the four target files.
</success_criteria>

<output>
After completion, create `.planning/phases/56-production-fixme-todo-resolution/56-01-SUMMARY.md`
</output>
