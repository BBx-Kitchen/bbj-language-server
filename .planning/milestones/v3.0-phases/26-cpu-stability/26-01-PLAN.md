---
phase: 26-cpu-stability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/phases/26-cpu-stability/FINDINGS.md
autonomous: true

must_haves:
  truths:
    - "Each of the 5 research hypotheses is analyzed with evidence from actual code paths"
    - "Root cause candidates are ranked by likelihood with supporting code references"
    - "Concrete mitigations are proposed with effort estimates for a follow-up implementation phase"
    - "The document rebuild cycle (buildDocuments -> addImportedBBjDocuments -> update) is traced for loop potential"
    - "The isAffected logic is evaluated for over-invalidation in multi-project scenarios"
  artifacts:
    - path: ".planning/phases/26-cpu-stability/FINDINGS.md"
      provides: "Root cause analysis and mitigation options for CPU stability issue #232"
      contains: "## Root Cause Analysis"
  key_links:
    - from: "FINDINGS.md"
      to: "bbj-document-builder.ts"
      via: "Code path analysis of buildDocuments -> addImportedBBjDocuments -> update cycle"
      pattern: "addImportedBBjDocuments|buildDocuments|this\\.update"
    - from: "FINDINGS.md"
      to: "bbj-index-manager.ts"
      via: "Analysis of isAffected over-invalidation logic"
      pattern: "isAffected|isExternal"
---

<objective>
Investigate why multi-project workspaces cause 100% CPU usage in the BBj language server. Analyze the 5 hypothesized code paths from research, trace the document rebuild lifecycle for loop potential, evaluate the IndexManager invalidation logic, and produce a findings document with ranked root causes and concrete mitigations.

Purpose: This investigation produces the evidence needed for a follow-up implementation phase to fix CPU stability issue #232. Without documented root causes and ranked mitigations, any fix would be speculative.
Output: FINDINGS.md with root cause analysis, evidence from code, and prioritized mitigation options.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-cpu-stability/26-RESEARCH.md
@.planning/phases/26-cpu-stability/26-CONTEXT.md

# Key source files to investigate
@bbj-vscode/src/language/bbj-document-builder.ts
@bbj-vscode/src/language/bbj-index-manager.ts
@bbj-vscode/src/language/bbj-ws-manager.ts
@bbj-vscode/src/language/bbj-linker.ts
@bbj-vscode/src/language/java-interop.ts
@bbj-vscode/src/language/bbj-module.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Analyze document rebuild pipeline and index manager for CPU loop potential</name>
  <files>.planning/phases/26-cpu-stability/FINDINGS.md</files>
  <action>
Perform deep static analysis of the document rebuild pipeline and index manager. This is the core investigation -- these are the two highest-likelihood hypotheses from the research.

**Rebuild Pipeline Analysis (Hypothesis 1 -- highest priority):**

1. Read `bbj-document-builder.ts` and trace the full call chain:
   - `buildDocuments(documents, options, cancelToken)` calls `super.buildDocuments()` then `addImportedBBjDocuments()`
   - `addImportedBBjDocuments()` collects USE statement paths, resolves files via prefix paths, creates new LangiumDocuments
   - If new documents are found, calls `this.update(addedDocuments, [], cancelToken)` on line 90
   - **Critical question:** Does `this.update()` trigger another `buildDocuments()` call? If so, the newly imported documents will ALSO have their USE statements resolved, potentially importing MORE documents, each of which triggers another `update()` -> `buildDocuments()` cycle

2. Determine whether there is any guard against processing the same document twice in a single build cycle:
   - `langiumDocuments.hasDocument(document.uri)` on line 82 prevents re-adding the same document
   - But does `this.update()` on line 90 cause `buildDocuments()` to be called again for the newly added documents? If those documents have USE statements pointing to yet more files, the cycle continues
   - In a multi-project workspace where Project A USEs files from Project B and vice versa, could this create an expanding frontier of transitive imports?

3. Read the Langium `DefaultDocumentBuilder` source to understand what `this.update()` does:
   - Check if `update()` calls `buildDocuments()` internally
   - Check if there is a maximum recursion depth or processing set
   - Determine the document state transitions that occur

4. Analyze the `shouldValidate()` override -- it skips validation for external documents, but does it skip linking? External documents still go through the full build pipeline (parse, link) even if validation is skipped.

**Index Manager Analysis (Hypothesis 2):**

5. Read `bbj-index-manager.ts` and analyze the `isAffected()` logic:
   - Line 22-24: If document has reference errors, return `!isExternal` -- meaning ALL workspace documents with errors are marked as affected by ANY change
   - Line 26-28: Complex boolean logic -- `![...changedUris].every(changed => bbjWsManager.isExternalDocument(URI.parse(changed))) && isExternal` means "if NOT all changed URIs are external AND this document IS external, return false"
   - **Critical question:** In multi-project workspace, when workspace document changes, does this cause ALL workspace documents with reference errors to rebuild? Could this cascade?

6. Read Langium's `DefaultIndexManager.isAffected()` to understand the base behavior:
   - What criteria does the default implementation use?
   - How does it interact with the BBj override?

**Write initial findings sections:**

Begin writing FINDINGS.md with:
- Executive summary (placeholder, will be finalized in Task 2)
- Hypothesis 1 analysis: Document rebuild loops -- evidence, code paths, verdict (confirmed/unlikely/needs-runtime-verification)
- Hypothesis 2 analysis: Index manager over-invalidation -- evidence, code paths, verdict
- Include specific line references and code snippets as evidence

**Important:** This is investigation only. Do NOT modify any source files. The output is analysis documentation.
  </action>
  <verify>
FINDINGS.md exists at `.planning/phases/26-cpu-stability/FINDINGS.md` and contains:
- Hypothesis 1 section with rebuild pipeline trace and verdict
- Hypothesis 2 section with isAffected logic analysis and verdict
- Code path references with line numbers
- At least one "Critical Finding" or "Key Observation" per hypothesis
  </verify>
  <done>
The two highest-priority hypotheses (rebuild loops, index over-invalidation) are analyzed with specific code path evidence and verdicts indicating likelihood of being the root cause.
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete remaining hypotheses analysis and produce ranked findings with mitigations</name>
  <files>.planning/phases/26-cpu-stability/FINDINGS.md</files>
  <action>
Complete the investigation by analyzing the remaining three hypotheses and synthesizing all findings into a ranked deliverable.

**File System Watcher Analysis (Hypothesis 3):**

1. Read `bbj-ws-manager.ts` `shouldIncludeEntry()` (lines 129-141):
   - Only includes .bbj, .bbl, .bbjt files -- good filtering
   - But check: does the workspace manager's `initializeWorkspace()` process ALL folders from the workspace? In multi-root workspace, `folders` array has multiple entries
   - Does `super.initializeWorkspace(folders, cancelToken)` on line 126 trigger file traversal for ALL workspace roots simultaneously?
   - Could parallel processing of multiple workspace roots cause document registration races?

2. Check how Langium handles `didChangeWatchedFiles` notifications:
   - Search for `didChangeWatchedFiles` or file watcher registration in the codebase
   - Determine if file changes during initialization could re-trigger initialization

**Java Interop Blocking Analysis (Hypothesis 4):**

3. Read `java-interop.ts`:
   - Is `loadClasspath()` truly async or does it block the event loop?
   - Is there a timeout on the socket connection?
   - In multi-project workspace, is `loadClasspath()` called once per workspace or once per project?
   - Check `initializeWorkspace()` in ws-manager -- classpath loading happens before `super.initializeWorkspace()` on line 126. If Java service is slow/hung, does the entire workspace initialization block?

4. Check if Java interop retry logic exists:
   - Search for retry patterns, reconnection loops
   - Determine if connection failure could cause a busy-wait loop

**AST Traversal Analysis (Hypothesis 5):**

5. Analyze `AstUtils.streamAllContents()` usage:
   - In `addImportedBBjDocuments()` (line 55): traverses each document's full AST to find USE statements
   - In `BbjLinker.link()` (line 41): traverses full AST for linking
   - Are these results cached? Or re-computed on every build cycle?
   - In a workspace with 100+ files, how many total AST nodes are traversed per cycle?

6. Check for DocumentCache usage:
   - Search for `DocumentCache` or `WorkspaceCache` in the codebase
   - Determine if any expensive computations are cached vs. recomputed

**Synthesize and Rank Findings:**

7. Update FINDINGS.md with complete analysis:

Structure the document as:
```
# CPU Stability Investigation Findings

## Executive Summary
[2-3 sentence overview of most likely root cause(s)]

## Issue Context
- GitHub Issue: #232
- Symptom: 100% CPU in multi-project workspaces
- Environment: VS Code, macOS

## Root Cause Analysis

### [Rank 1] [Most likely cause] -- LIKELIHOOD: HIGH/MEDIUM/LOW
- Evidence: [code paths, line numbers]
- Mechanism: [how it causes CPU spike]
- Verdict: [confirmed / likely / needs runtime verification]

### [Rank 2] [Second most likely] -- LIKELIHOOD: ...
...

### [Rank 3-5] [Remaining hypotheses] -- LIKELIHOOD: ...
...

## Proposed Mitigations

### Mitigation 1: [Name] (addresses Rank N cause)
- What: [specific code change]
- Where: [file(s) and line(s)]
- Effort: Small / Medium / Large
- Risk: Low / Medium / High

### Mitigation 2: ...
...

## Recommended Investigation Next Steps
[If any hypotheses need runtime verification, describe the profiling/instrumentation steps]

## Code Locations Reference
[Table of all files and line numbers referenced in the analysis]
```

8. Ensure mitigations are concrete enough for a follow-up phase to plan tasks directly from them. Each mitigation should specify:
   - The exact file(s) to modify
   - The nature of the change (add guard, add cache, restructure loop, etc.)
   - Why it addresses the root cause
   - Any risks or side effects

**Important:** This is investigation only. Do NOT modify any source files. The output is analysis documentation only.
  </action>
  <verify>
FINDINGS.md is complete with:
- All 5 hypotheses analyzed with verdicts
- Root causes ranked by likelihood
- At least 3 concrete mitigations with file locations and effort estimates
- Executive summary reflecting the ranked analysis
- Code locations reference table

Run: Verify the file is well-formed and contains all required sections.
  </verify>
  <done>
A complete FINDINGS.md exists that covers all 5 hypotheses with evidence, ranks root causes by likelihood, and proposes concrete mitigations with enough specificity for a follow-up implementation phase to plan tasks directly.
  </done>
</task>

</tasks>

<verification>
1. FINDINGS.md exists at `.planning/phases/26-cpu-stability/FINDINGS.md`
2. All 5 hypotheses from research are addressed:
   - Transitive document rebuild loops
   - IndexManager over-invalidation
   - File system watcher notification storms
   - Java interop service blocking
   - Excessive AST traversal without caching
3. Each hypothesis has a verdict (confirmed / likely / unlikely / needs runtime verification)
4. Root causes are ranked by likelihood
5. At least 3 concrete mitigations are proposed
6. Each mitigation specifies exact files, nature of change, and effort level
7. No source code files were modified (investigation only)
</verification>

<success_criteria>
- FINDINGS.md is comprehensive enough that a follow-up phase can plan implementation tasks directly from it
- Each hypothesis analysis includes specific code path references (file, line numbers, function names)
- Mitigations are ranked by impact and effort, enabling prioritization in the follow-up phase
- The document distinguishes between confirmed causes (from static analysis) and hypotheses that need runtime profiling to verify
</success_criteria>

<output>
After completion, create `.planning/phases/26-cpu-stability/26-01-SUMMARY.md`
</output>
