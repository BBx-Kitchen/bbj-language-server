---
phase: 05-java-interop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjSettings.java
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjSettingsComponent.java
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjSettingsConfigurable.java
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/ui/BbjJavaInteropService.java
  - bbj-intellij/src/main/resources/META-INF/plugin.xml
autonomous: true

must_haves:
  truths:
    - "Settings page shows java-interop port field with localhost label and auto-detected or default 5008"
    - "Port auto-detects from BBjServices config when BBj home is set, falls back to 5008"
    - "Port value persists across IDE restarts"
    - "Changing port triggers debounced language server restart"
    - "Java-interop connection status is checked via TCP and broadcast on message bus"
  artifacts:
    - path: "bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjSettings.java"
      provides: "javaInteropPort field in State"
      contains: "javaInteropPort"
    - path: "bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjSettingsComponent.java"
      provides: "Port input field with static localhost label"
      contains: "javaInteropPort"
    - path: "bbj-intellij/src/main/java/com/basis/bbj/intellij/ui/BbjJavaInteropService.java"
      provides: "TCP health check and status broadcast"
      contains: "BbjJavaInteropStatusListener"
  key_links:
    - from: "BbjSettingsConfigurable"
      to: "BbjServerService.scheduleRestart()"
      via: "apply() method"
      pattern: "scheduleRestart"
    - from: "BbjSettingsConfigurable.reset()"
      to: "BbjSettings.detectJavaInteropPort()"
      via: "auto-detection in reset when port is default"
      pattern: "detectJavaInteropPort"
    - from: "BbjJavaInteropService"
      to: "message bus"
      via: "BbjJavaInteropStatusListener.TOPIC"
      pattern: "syncPublisher.*TOPIC"
---

<objective>
Add java-interop port configuration to settings (with auto-detection from BBjServices config) and create a project-level service that monitors java-interop availability via TCP health checks, broadcasting status changes on the message bus.

Purpose: Foundation for java-interop UI components (status widget, editor banner) that need to know whether BBjServices is running. The port setting feeds into initializationOptions for the language server.
Output: Settings page with java-interop section (auto-detecting port), BbjJavaInteropService with periodic health check.

Design note on TCP health checks: The language server already connects to java-interop internally
(java-interop.ts createSocket() on DEFAULT_PORT 5008) but does NOT expose java-interop connection
status via LSP protocol -- there are no custom notifications or status reports. Modifying the language
server is out of scope (see REQUIREMENTS.md). Therefore the plugin independently probes the TCP port
to determine whether BBjServices is reachable. This is for STATUS DISPLAY only -- the plugin does not
manage the LS-to-java-interop connection. The plugin passes config via initializationOptions and the
server connects on its own.

Design note on JAVA-02 (Java completions): The language server ALREADY implements java-interop
completions (see java-interop.ts, bbj-scope.ts, bbj-scope-local.ts). Java class names and method
signatures are provided by the existing Langium-based server when it successfully connects to
BBjServices java-interop on port 5008. The VS Code extension already uses this. The IntelliJ plugin
just needs to: (1) pass the port config via initializationOptions so LS knows where to connect,
and (2) show UI status so the user knows if java-interop is working. No new LS-side implementation
is needed for JAVA-02.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjSettings.java
@bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjSettingsComponent.java
@bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjSettingsConfigurable.java
@bbj-intellij/src/main/java/com/basis/bbj/intellij/ui/BbjServerService.java
@bbj-intellij/src/main/resources/META-INF/plugin.xml
@bbj-vscode/src/language/java-interop.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add java-interop port to settings state and UI with auto-detection</name>
  <files>
    bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjSettings.java
    bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjSettingsComponent.java
    bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjSettingsConfigurable.java
  </files>
  <action>
    **BbjSettings.java:**
    - Add `public int javaInteropPort = 5008;` to the State class (int, not String -- port is numeric)
    - 5008 is the default matching the language server's hardcoded DEFAULT_PORT (java-interop.ts line 18)
    - Add a static method `detectJavaInteropPort(String bbjHomePath)` that attempts to auto-detect
      the java-interop port from BBjServices configuration:
      1. If bbjHomePath is empty/null, return 5008
      2. Read `<bbjHomePath>/cfg/BBj.properties` (same file already read by getBBjClasspathEntries)
      3. Look for a property containing java-interop or bridge port configuration. Search for lines
         matching patterns like: `basis.java.interop.port=`, `java.interop.port=`, `basis.bridge.port=`
         (the exact property name is unknown -- BBjServices config is poorly documented)
      4. If found, parse the integer value and return it (validate 1-65535)
      5. If not found or any error, return 5008 (the known default)
      6. Wrap all file I/O in try-catch -- never throw. This is best-effort auto-detection.

    **BbjSettingsComponent.java:**
    - Add a new "Java Interop" TitledSeparator section to the form layout (after the "Language Server" section, before the fill component)
    - Add a static JBLabel showing "localhost" (not editable -- localhost-only per CONTEXT.md decisions)
    - Add a JBTextField for port input, defaulting to "5008"
    - Add a ComponentValidator on the port field:
      - Empty is valid (uses default 5008)
      - Must be numeric integer between 1 and 65535
      - Invalid values show ValidationInfo error
    - Add getter `getJavaInteropPort()` returning int (parse text field, default 5008 if empty/invalid)
    - Add setter `setJavaInteropPort(int port)` setting text field value
    - Layout: JBLabel "Host:" with static "localhost" text, then JBLabel "Port:" with the port text field, arranged horizontally or as separate labeled rows under the "Java Interop" separator

    **BbjSettingsConfigurable.java:**
    - Add javaInteropPort to `isModified()` comparison: `state.javaInteropPort != myComponent.getJavaInteropPort()`
    - Add javaInteropPort to `apply()`: `state.javaInteropPort = myComponent.getJavaInteropPort();`
    - Add javaInteropPort to `reset()` WITH AUTO-DETECTION (follow the existing pattern for bbjHomePath and nodeJsPath):
      ```java
      int javaInteropPort = state.javaInteropPort;
      if (javaInteropPort == 5008) {
          // Default value -- try auto-detection from BBjServices config
          String bbjHome = state.bbjHomePath;
          if (bbjHome.isEmpty()) {
              String detected = BbjHomeDetector.detectBbjHome();
              if (detected != null) {
                  bbjHome = detected;
              }
          }
          if (!bbjHome.isEmpty()) {
              int detected = BbjSettings.detectJavaInteropPort(bbjHome);
              if (detected != 5008) {
                  javaInteropPort = detected;
              }
          }
      }
      myComponent.setJavaInteropPort(javaInteropPort);
      ```
    - Auto-detection priority: BBjServices config > 5008 default > user override (per CONTEXT.md)
    - The existing `scheduleRestart()` call in apply() already handles debounced restart when any setting changes -- no additional restart logic needed
  </action>
  <verify>
    Run `./gradlew buildPlugin` from bbj-intellij/ -- build compiles without errors.
    Grep for `javaInteropPort` in all three files to confirm wiring.
    Grep for `detectJavaInteropPort` in BbjSettings.java to confirm auto-detection method exists.
  </verify>
  <done>
    Settings page has a "Java Interop" section with static "localhost" label and editable port field. Port auto-detects from BBjServices config in reset() (best-effort, falls back to 5008). Port validates as integer 1-65535. Port persists via BbjSettings.State and changing it triggers language server restart.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BbjJavaInteropService with TCP health check</name>
  <files>
    bbj-intellij/src/main/java/com/basis/bbj/intellij/ui/BbjJavaInteropService.java
    bbj-intellij/src/main/resources/META-INF/plugin.xml
  </files>
  <action>
    **Design rationale for plugin-side TCP health check:**
    The language server connects to java-interop internally (java-interop.ts createSocket()) but does
    NOT expose connection status via LSP protocol -- no custom notifications, no status fields. The LS
    just silently fails java completions if java-interop is unreachable. Modifying the language server
    is out of scope per REQUIREMENTS.md. Therefore the plugin independently probes the TCP port as the
    only way to show connection status without LS changes. This is for UI STATUS DISPLAY only -- the
    plugin does not manage the LS-to-java-interop connection.

    **BbjJavaInteropService.java** (new file in ui/ package, following BbjServerService patterns):

    Create a project-level service that periodically checks if java-interop (BBjServices) is reachable on localhost:port via TCP socket.

    Structure:
    ```
    public final class BbjJavaInteropService implements Disposable {
        // States: CONNECTED, DISCONNECTED, CHECKING
        public enum InteropStatus { CONNECTED, DISCONNECTED, CHECKING }

        // Message bus topic for status changes
        public interface BbjJavaInteropStatusListener {
            Topic<BbjJavaInteropStatusListener> TOPIC = Topic.create(...)
            void statusChanged(InteropStatus status);
        }

        private InteropStatus currentStatus = InteropStatus.DISCONNECTED;
        private final Project project;
        private final Alarm checkAlarm;
        private long disconnectedSince = 0;  // timestamp for grace period
        private static final int CHECK_INTERVAL_MS = 5000;  // check every 5s
        private static final long GRACE_PERIOD_MS = 2000;   // 2s grace before broadcasting disconnect
    }
    ```

    Key methods:
    - `getInstance(Project project)` -- static factory via project.getService()
    - `startChecking()` -- begins periodic TCP check via Alarm. Called when language server status changes to "started" (subscribe to BbjServerStatusListener.TOPIC in constructor)
    - `stopChecking()` -- cancels alarm. Called when language server stops.
    - `checkConnection()` -- attempts TCP socket connect to localhost:port with 1000ms timeout. On success: status = CONNECTED, disconnectedSince = 0. On failure: if disconnectedSince == 0, set disconnectedSince = now, status stays CONNECTED (grace period). If now - disconnectedSince > GRACE_PERIOD_MS, status = DISCONNECTED.
    - `getCurrentStatus()` -- returns current InteropStatus
    - `broadcastStatus(InteropStatus newStatus)` -- if changed from previous, publish via message bus syncPublisher and trigger EditorNotifications.updateAllNotifications()
    - `dispose()` -- cancel alarm

    Important implementation details:
    - TCP check must NOT run on EDT. Use Alarm with ThreadToUse.POOLED_THREAD (same pattern as BbjServerService.restartAlarm)
    - Socket connect: `new Socket()`, `socket.connect(new InetSocketAddress("127.0.0.1", port), 1000)`, close immediately after. Wrap in try-catch.
    - Read port from BbjSettings.getInstance().getState().javaInteropPort at check time (not cached -- user may change it)
    - Subscribe to BbjServerService.BbjServerStatusListener.TOPIC in constructor: when server status is `started`, call `startChecking()`. When `stopped` or `stopping`, call `stopChecking()` and set status to DISCONNECTED.
    - Use ApplicationManager.invokeLater() for UI thread operations (message bus publish, editor notifications)

    **plugin.xml:**
    - Register as projectService: `<projectService serviceImplementation="com.basis.bbj.intellij.ui.BbjJavaInteropService"/>`
    - Place after the existing BbjServerService registration
  </action>
  <verify>
    Run `./gradlew buildPlugin` from bbj-intellij/ -- build compiles without errors.
    Grep for "BbjJavaInteropService" in plugin.xml to confirm registration.
    Grep for "BbjJavaInteropStatusListener" in BbjJavaInteropService.java to confirm topic exists.
  </verify>
  <done>
    BbjJavaInteropService exists as a project service. It subscribes to language server status, starts periodic TCP health checks when server is running, implements grace period for transient disconnects, and broadcasts java-interop status changes via message bus topic. TCP check is plugin-side because LS does not expose java-interop status via LSP protocol.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew buildPlugin` succeeds without errors
2. Settings page shows "Java Interop" section with localhost label and port field
3. Port auto-detects from BBjServices config (best-effort, falls back to 5008)
4. BbjJavaInteropService registered in plugin.xml as projectService
5. BbjJavaInteropStatusListener.TOPIC defined for message bus broadcasting
6. Port field validates numeric input 1-65535
</verification>

<success_criteria>
- Build passes cleanly
- Settings state includes javaInteropPort with default 5008
- Settings UI has Java Interop section with static "localhost" and editable port
- Port auto-detects from BBjServices config in reset() when at default value
- Port changes trigger debounced language server restart via existing mechanism
- BbjJavaInteropService performs TCP health checks on localhost:port
- Grace period prevents flashing on transient disconnects
- Status changes broadcast via message bus topic
</success_criteria>

<output>
After completion, create `.planning/phases/05-java-interop/05-01-SUMMARY.md`
</output>
