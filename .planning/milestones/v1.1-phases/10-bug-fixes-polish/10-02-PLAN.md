---
phase: 10-bug-fixes-polish
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/ui/BbjServerService.java
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/ui/BbjStatusBarWidget.java
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/lsp/BbjCompletionFeature.java
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/lsp/BbjLanguageServerFactory.java
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjIcons.java
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjNodeDetector.java
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjNodeDownloader.java
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/lsp/BbjLanguageServer.java
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/actions/BbjRunActionBase.java
  - bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjHomeDetector.java
  - bbj-intellij/META-INF/plugin.xml
  - bbj-intellij/src/main/resources/icons/bbj-function.svg
  - bbj-intellij/src/main/resources/icons/bbj-variable.svg
  - bbj-intellij/src/main/resources/icons/bbj-keyword.svg
autonomous: true

must_haves:
  truths:
    - "Closing the last BBj file does not immediately kill the language server; reopening within 30 seconds reuses it"
    - "Completion popup shows distinct platform icons for functions, variables, keywords, and other symbol types"
    - "Java class/method completions from java-interop show Java-specific icons distinct from BBj completions"
    - "Stale bbj-intellij/META-INF/ directory no longer exists"
    - "All code paths handle Linux correctly (path separators, Node.js detection, executable permissions)"
  artifacts:
    - path: "bbj-intellij/src/main/java/com/basis/bbj/intellij/ui/BbjServerService.java"
      provides: "Grace period lifecycle with 30-second delayed shutdown"
      contains: "FileEditorManagerListener"
    - path: "bbj-intellij/src/main/java/com/basis/bbj/intellij/ui/BbjStatusBarWidget.java"
      provides: "Idle state display during grace period"
      contains: "Idle"
    - path: "bbj-intellij/src/main/java/com/basis/bbj/intellij/lsp/BbjCompletionFeature.java"
      provides: "LSPCompletionFeature subclass with platform icon mapping and Java-interop distinction"
      contains: "AllIcons.Nodes"
    - path: "bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjIcons.java"
      provides: "Cleaned up icon constants without orphaned completion icons"
  key_links:
    - from: "BbjServerService"
      to: "FileEditorManagerListener"
      via: "Message bus subscription tracking BBj file open/close"
      pattern: "FileEditorManagerListener"
    - from: "BbjServerService"
      to: "BbjStatusBarWidget"
      via: "Status broadcast including idle state"
      pattern: "BbjServerStatusListener"
    - from: "BbjCompletionFeature"
      to: "AllIcons.Nodes"
      via: "Platform icon mapping replacing custom SVG icons"
      pattern: "AllIcons\\.Nodes"
    - from: "BbjLanguageServerFactory"
      to: "BbjCompletionFeature"
      via: "setCompletionFeature() wiring in createClientFeatures()"
      pattern: "setCompletionFeature"
---

<objective>
Fix LS shutdown grace period (FIX-04), wire completion icons with Java-interop distinction (FIX-05), remove stale META-INF (FIX-06), and review Linux code paths (FIX-07).

Purpose: Server lifecycle polish (grace period prevents disruptive restarts), native completion icons with Java-specific distinction (consistent look, Java classes visually distinct from BBj), codebase cleanup (stale files removed), and cross-platform correctness (Linux support).
Output: BbjServerService with 30-second grace period, BbjCompletionFeature as LSPCompletionFeature subclass using AllIcons.Nodes with Java-interop icon distinction, deleted stale META-INF, Linux-safe code paths.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-bug-fixes-polish/10-CONTEXT.md
@.planning/phases/10-bug-fixes-polish/10-RESEARCH.md
@bbj-intellij/src/main/java/com/basis/bbj/intellij/ui/BbjServerService.java
@bbj-intellij/src/main/java/com/basis/bbj/intellij/ui/BbjStatusBarWidget.java
@bbj-intellij/src/main/java/com/basis/bbj/intellij/lsp/BbjCompletionFeature.java
@bbj-intellij/src/main/java/com/basis/bbj/intellij/lsp/BbjLanguageServerFactory.java
@bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjIcons.java
@bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjNodeDetector.java
@bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjNodeDownloader.java
@bbj-intellij/src/main/java/com/basis/bbj/intellij/lsp/BbjLanguageServer.java
@bbj-intellij/src/main/java/com/basis/bbj/intellij/actions/BbjRunActionBase.java
@bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjHomeDetector.java
@bbj-intellij/META-INF/plugin.xml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement LS shutdown grace period with idle status</name>
  <files>
    bbj-intellij/src/main/java/com/basis/bbj/intellij/ui/BbjServerService.java
    bbj-intellij/src/main/java/com/basis/bbj/intellij/ui/BbjStatusBarWidget.java
  </files>
  <action>
Add a 30-second grace period to BbjServerService so the language server stays alive briefly after the last BBj file closes. If a BBj file reopens during the grace period, cancel the shutdown timer and reuse the running server.

**BbjServerService.java changes:**

1. Add imports:
```java
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.fileEditor.FileEditorManagerListener;
import com.intellij.openapi.vfs.VirtualFile;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
```

2. Add fields:
```java
private static final int GRACE_PERIOD_SECONDS = 30;
private final ScheduledExecutorService gracePeriodScheduler =
    Executors.newSingleThreadScheduledExecutor(r -> {
        Thread t = new Thread(r, "BBj-LS-Grace-Period");
        t.setDaemon(true);
        return t;
    });
private ScheduledFuture<?> gracePeriodTask;
private volatile boolean inGracePeriod = false;
```

3. In the constructor, AFTER the existing `Disposer.register(project, this)`, add file editor listener:
```java
MessageBusConnection connection = project.getMessageBus().connect(this);
connection.subscribe(FileEditorManagerListener.FILE_EDITOR_MANAGER,
    new FileEditorManagerListener() {
        @Override
        public void fileOpened(@NotNull FileEditorManager source,
                              @NotNull VirtualFile file) {
            if (isBbjFile(file)) {
                cancelGracePeriod();
            }
        }

        @Override
        public void fileClosed(@NotNull FileEditorManager source,
                              @NotNull VirtualFile file) {
            if (isBbjFile(file)) {
                checkAndStartGracePeriod(source);
            }
        }
    });
```
NOTE: Use `project.getMessageBus().connect(this)` (passing `this` as Disposable parent) so the connection auto-disconnects on project close.

4. Add helper methods:
```java
private boolean isBbjFile(@NotNull VirtualFile file) {
    String ext = file.getExtension();
    return ext != null && (ext.equals("bbj") || ext.equals("bbl") ||
                           ext.equals("bbjt") || ext.equals("src") ||
                           ext.equals("bbx"));
}

private void checkAndStartGracePeriod(@NotNull FileEditorManager manager) {
    // Check if any BBj files are still open
    for (VirtualFile open : manager.getOpenFiles()) {
        if (isBbjFile(open)) {
            return; // Still have BBj files open, no grace period needed
        }
    }
    startGracePeriod();
}

private synchronized void startGracePeriod() {
    if (inGracePeriod) return;
    inGracePeriod = true;
    logToConsole("Last BBj file closed. Language server will shut down in "
        + GRACE_PERIOD_SECONDS + " seconds...",
        com.intellij.execution.ui.ConsoleViewContentType.SYSTEM_OUTPUT);

    // Notify UI of idle state
    ApplicationManager.getApplication().invokeLater(() ->
        project.getMessageBus()
            .syncPublisher(BbjServerStatusListener.TOPIC)
            .statusChanged(currentStatus) // Re-broadcast to trigger idle display
    );

    gracePeriodTask = gracePeriodScheduler.schedule(() -> {
        inGracePeriod = false;
        logToConsole("Grace period expired. Stopping language server.",
            com.intellij.execution.ui.ConsoleViewContentType.SYSTEM_OUTPUT);
        ApplicationManager.getApplication().invokeLater(() -> {
            LanguageServerManager.getInstance(project).stop("bbjLanguageServer");
        });
    }, GRACE_PERIOD_SECONDS, TimeUnit.SECONDS);
}

private synchronized void cancelGracePeriod() {
    if (!inGracePeriod) return;
    inGracePeriod = false;
    if (gracePeriodTask != null && !gracePeriodTask.isDone()) {
        gracePeriodTask.cancel(false);
        gracePeriodTask = null;
    }
    logToConsole("BBj file opened. Grace period cancelled.",
        com.intellij.execution.ui.ConsoleViewContentType.SYSTEM_OUTPUT);

    // Re-broadcast status to clear idle display
    ApplicationManager.getApplication().invokeLater(() ->
        project.getMessageBus()
            .syncPublisher(BbjServerStatusListener.TOPIC)
            .statusChanged(currentStatus)
    );
}

public boolean isInGracePeriod() {
    return inGracePeriod;
}
```

5. In the `dispose()` method, add cleanup for the scheduler:
```java
gracePeriodScheduler.shutdownNow();
```

**BbjStatusBarWidget.java changes:**

6. In the `updateStatus()` method, after determining icon and text based on ServerStatus, add a grace period check BEFORE setting the labels:
```java
// Check for grace period idle state
BbjServerService service = BbjServerService.getInstance(project);
if (service.isInGracePeriod() && status == ServerStatus.started) {
    icon = BbjIcons.STATUS_STARTING; // Dimmed/different icon for idle
    text = "BBj: Idle";
}
```
This uses the existing STATUS_STARTING icon (which has a different visual from STATUS_READY) as the "dimmed" idle indicator. Place this logic AFTER the switch statement but BEFORE `iconLabel.setIcon(icon)`.

CONTEXT.md decision: "Status bar hint during grace period -- subtle indication (e.g., dimmed icon or 'idle' text) so user knows the LS is still alive but winding down."
  </action>
  <verify>
Run `./gradlew build` from bbj-intellij/ -- build succeeds. Inspect BbjServerService.java: has FileEditorManagerListener subscription, GRACE_PERIOD_SECONDS = 30, startGracePeriod()/cancelGracePeriod() methods, isInGracePeriod() accessor. Inspect BbjStatusBarWidget.java: shows "BBj: Idle" during grace period.
  </verify>
  <done>
BbjServerService tracks BBj file open/close via FileEditorManagerListener. Last file close starts 30-second grace period timer. File reopen cancels timer and reuses running server. Status bar shows "BBj: Idle" during grace period. Build compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace completion icons with platform AllIcons, wire into LSP4IJ, and distinguish Java-interop completions</name>
  <files>
    bbj-intellij/src/main/java/com/basis/bbj/intellij/lsp/BbjCompletionFeature.java
    bbj-intellij/src/main/java/com/basis/bbj/intellij/lsp/BbjLanguageServerFactory.java
    bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjIcons.java
    bbj-intellij/src/main/resources/icons/bbj-function.svg
    bbj-intellij/src/main/resources/icons/bbj-variable.svg
    bbj-intellij/src/main/resources/icons/bbj-keyword.svg
    bbj-intellij/META-INF/plugin.xml
  </files>
  <action>
Replace custom BBj completion icons with IntelliJ platform icons (AllIcons.Nodes.*), wire BbjCompletionFeature into LSP4IJ via setCompletionFeature(), and distinguish Java-interop completions from BBj completions with different icons. Clean up orphaned resources.

**CONTEXT.md locked decision:** "Java class/method completions from java-interop should show Java-specific icons to distinguish them from BBj completions."

**Background on how Java vs BBj completions are distinguished at the LSP protocol level:**

The BBj language server's `BBjNodeKindProvider` maps both `JavaMethod` and `MethodDecl`/`LibFunction` to `CompletionItemKind.Function`, and both `JavaClass` and `BbjClass` to `CompletionItemKind.Class`. So `CompletionItemKind` alone cannot distinguish Java from BBj completions.

However, completions from Java-interop carry distinguishing metadata in the LSP `CompletionItem`:
- Java method completions have a `detail` field containing the full Java method signature (e.g., `"String toString(): String"`) with Java type names containing dots (package-qualified types like `java.lang.String` or simple names like `String`)
- Java class completions have package-qualified names or `detail` fields with Java package paths
- BBj function completions have BBj-specific detail text (e.g., `"Built-in function"`) or no dots in type signatures
- BBj keyword completions have `detail: "Keyword"` and `kind: CompletionItemKind.Keyword`

**BbjCompletionFeature.java -- Rewrite as LSPCompletionFeature subclass:**

1. The current BbjCompletionFeature is a standalone utility class with a static `getIcon(CompletionItemKind)` method. It is ORPHANED -- never called by LSP4IJ (confirmed in v1.0 integration check). Rewrite it as a proper `LSPCompletionFeature` subclass that LSP4IJ calls automatically.

2. Check what LSP4IJ provides for completion customization. First try importing `com.redhat.devtools.lsp4ij.client.features.LSPCompletionFeature`. If it exists, extend it and override the icon method. The key method to override is likely `getIcon()` or `getCompletionIcon()` which receives the full `CompletionItem` (not just the kind).

3. Rewrite BbjCompletionFeature:

```java
package com.basis.bbj.intellij.lsp;

import com.intellij.icons.AllIcons;
import com.redhat.devtools.lsp4ij.client.features.LSPCompletionFeature;
import org.eclipse.lsp4j.CompletionItem;
import org.eclipse.lsp4j.CompletionItemKind;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.Icon;

/**
 * Maps LSP CompletionItemKind to IntelliJ platform icons.
 * Distinguishes Java-interop completions from BBj completions
 * by inspecting the completion item's detail field.
 *
 * Uses native platform icons for consistency with other languages.
 */
public class BbjCompletionFeature extends LSPCompletionFeature {

    // Override the method that provides icons for completion items.
    // The exact method signature depends on the LSP4IJ version.
    // Try getCompletionIcon(CompletionItem) first, fall back to alternatives.

    /**
     * Determines if a completion item originates from Java interop
     * by checking for Java-style signatures in the detail field.
     *
     * Java-interop completions have detail containing Java type signatures
     * (e.g., "String toString(): String", "void close() throws IOException").
     * BBj completions have detail like "Keyword" or "Built-in function" or
     * BBj-specific type names without Java package patterns.
     */
    private static boolean isJavaInteropCompletion(@NotNull CompletionItem item) {
        CompletionItemKind kind = item.getKind();
        // Only check for Function/Method and Class kinds -- other kinds
        // (Keyword, Field, Variable) are always BBj-native
        if (kind != CompletionItemKind.Function && kind != CompletionItemKind.Method
                && kind != CompletionItemKind.Class) {
            return false;
        }

        String detail = item.getDetail();
        if (detail == null || detail.isEmpty()) {
            return false;
        }

        // Java method signatures contain return types with Java class names.
        // BBj keywords have detail "Keyword", BBj functions have no Java types.
        // Look for patterns characteristic of Java signatures:
        // - Contains parentheses with type parameters: "String foo(int, String)"
        // - Contains Java type names (capitalized words with dots or common Java types)
        // - Detail contains ":" followed by a return type (from BBjCompletionProvider format)

        // The BBj completion provider formats Java method completions as:
        // label: "methodName(param1, param2)" with detail showing the full signature
        // including Java return types. BBj builtins use BBj-specific type names.

        // Heuristic: If the detail contains a Java-style return type annotation
        // (": TypeName" where TypeName starts with uppercase), it's likely Java.
        // Also check for common Java types.
        return detail.contains("java.") || detail.contains("javax.")
                || detail.contains("com.basis.") || detail.contains("throws ");
    }

    /**
     * Maps a CompletionItemKind to a platform icon, with Java-interop distinction.
     *
     * This static method is used by the LSPCompletionFeature override methods below.
     * If the LSP4IJ API provides a CompletionItem-level override, use isJavaInteropCompletion()
     * to select Java-specific icons. Otherwise, fall back to kind-only mapping.
     */
    public static @Nullable Icon getIconForKind(@Nullable CompletionItemKind kind, boolean isJava) {
        if (kind == null) {
            return null;
        }

        if (isJava) {
            // Java-interop completions get distinct icons per CONTEXT.md decision
            return switch (kind) {
                case Function, Method -> AllIcons.Nodes.AbstractMethod;
                case Class -> AllIcons.Nodes.AbstractClass;
                default -> null;
            };
        }

        // BBj completions and general mappings
        return switch (kind) {
            case Function, Method -> AllIcons.Nodes.Method;
            case Class -> AllIcons.Nodes.Class;
            case Interface -> AllIcons.Nodes.Interface;
            case Variable -> AllIcons.Nodes.Variable;
            case Field -> AllIcons.Nodes.Field;
            case Property -> AllIcons.Nodes.Property;
            case Keyword -> AllIcons.Nodes.Tag;
            case Constant -> AllIcons.Nodes.Constant;
            case Enum -> AllIcons.Nodes.Enum;
            case EnumMember -> AllIcons.Nodes.Field;
            case Module, Package -> AllIcons.Nodes.Package;
            case Snippet -> AllIcons.Nodes.Template;
            case Folder -> AllIcons.Nodes.Package;
            default -> null;
        };
    }

    /**
     * Fallback: kind-only mapping without CompletionItem context.
     * Used when the LSP4IJ override method only receives kind, not full item.
     */
    public static @Nullable Icon getIcon(@Nullable CompletionItemKind kind) {
        return getIconForKind(kind, false);
    }
}
```

**IMPORTANT NOTES on LSP4IJ API discovery:**

The LSP4IJ `LSPCompletionFeature` API may vary by version. During execution:

a. First, try `import com.redhat.devtools.lsp4ij.client.features.LSPCompletionFeature`. If this class exists, check what methods it provides for icon customization. Look for:
   - `getCompletionIcon(CompletionItem item)` -- ideal, gives full item context for Java detection
   - `getIcon(CompletionItem item)` -- same, different name
   - If only `getIcon(CompletionItemKind kind)` is available -- fall back to kind-only mapping (Java distinction won't be possible at this level; see alternative below)

b. If `LSPCompletionFeature` doesn't exist in the current LSP4IJ version, keep BbjCompletionFeature as a utility class (current pattern) but add the Java-interop detection logic. Wire it manually if possible through `LSPClientFeatures`.

c. Alternative approach for Java distinction if LSP4IJ doesn't expose full CompletionItem: The language server could be modified to use different CompletionItemKinds for Java vs BBj completions (e.g., `Method` for Java, `Function` for BBj). However, this is a language-server-side change and would be a follow-up if the IntelliJ-side approach doesn't work. Add a TODO comment if this path is needed.

**Wire into BbjLanguageServerFactory.createClientFeatures():**

4. In BbjLanguageServerFactory.java, chain `.setCompletionFeature(new BbjCompletionFeature())` after the existing `.setDocumentLinkFeature(...)` call:

```java
.setDocumentLinkFeature(new LSPDocumentLinkFeature() {
    @Override
    public boolean isSupported(@NotNull PsiFile file) {
        return false;
    }
})
.setCompletionFeature(new BbjCompletionFeature())
```

If `setCompletionFeature()` method doesn't exist on LSPClientFeatures, check for alternative wiring methods. The v1.0 integration check confirmed this was the intended approach but it failed in Phase 4 due to API differences at that time. The API may have been added in newer LSP4IJ versions.

**BbjIcons.java -- Remove orphaned icon constants:**

5. Remove these three lines from BbjIcons.java:
```java
Icon FUNCTION = IconLoader.getIcon("/icons/bbj-function.svg", BbjIcons.class);
Icon VARIABLE = IconLoader.getIcon("/icons/bbj-variable.svg", BbjIcons.class);
Icon KEYWORD = IconLoader.getIcon("/icons/bbj-keyword.svg", BbjIcons.class);
```
Keep all other icon constants (FILE, STATUS_READY, STATUS_STARTING, STATUS_ERROR, TOOL_WINDOW, INTEROP_CONNECTED, INTEROP_DISCONNECTED, CONFIG, RUN_GUI, RUN_BUI, RUN_DWC).

**Delete orphaned SVG icon files:**

6. Delete these files:
- `bbj-intellij/src/main/resources/icons/bbj-function.svg`
- `bbj-intellij/src/main/resources/icons/bbj-variable.svg`
- `bbj-intellij/src/main/resources/icons/bbj-keyword.svg`

**Delete stale META-INF directory (FIX-06):**

7. Delete the entire `bbj-intellij/META-INF/` directory (contains an outdated plugin.xml from early development). The canonical plugin.xml is at `bbj-intellij/src/main/resources/META-INF/plugin.xml`.

Verify no other files reference the stale META-INF path before deleting.

**Icon mapping decisions per CONTEXT.md:**
- Function/Method (BBj) -> AllIcons.Nodes.Method (standard for callable symbols)
- Function/Method (Java-interop) -> AllIcons.Nodes.AbstractMethod (visually distinct -- has italic/abstract marker)
- Class (BBj) -> AllIcons.Nodes.Class
- Class (Java-interop) -> AllIcons.Nodes.AbstractClass (visually distinct -- has abstract marker)
- Variable -> AllIcons.Nodes.Variable (distinct from Field)
- Field -> AllIcons.Nodes.Field
- Keyword -> AllIcons.Nodes.Tag (distinct visual, recognizable)
- Constant -> AllIcons.Nodes.Constant
- Enum -> AllIcons.Nodes.Enum
- Module/Package/Folder -> AllIcons.Nodes.Package
  </action>
  <verify>
Run `./gradlew build` from bbj-intellij/ -- build succeeds. Verify:
1. BbjCompletionFeature.java extends LSPCompletionFeature (or is utility class if API unavailable) and imports AllIcons.Nodes (not BbjIcons)
2. BbjCompletionFeature has isJavaInteropCompletion() method that checks detail field for Java patterns
3. Java-interop completions get distinct icons (AbstractMethod/AbstractClass) vs BBj completions (Method/Class)
4. BbjLanguageServerFactory.createClientFeatures() chains .setCompletionFeature(new BbjCompletionFeature())
5. BbjIcons.java has no FUNCTION/VARIABLE/KEYWORD constants
6. bbj-function.svg, bbj-variable.svg, bbj-keyword.svg deleted
7. bbj-intellij/META-INF/ directory no longer exists
  </verify>
  <done>
BbjCompletionFeature wired into LSP4IJ via setCompletionFeature(). Maps CompletionItemKind to AllIcons.Nodes platform icons. Java-interop completions distinguished from BBj completions using detail field heuristic -- Java methods/classes get AbstractMethod/AbstractClass icons, BBj gets Method/Class. BbjIcons.java cleaned of orphaned FUNCTION/VARIABLE/KEYWORD constants. Three orphaned SVG files deleted. Stale bbj-intellij/META-INF/ directory deleted. Build compiles.
  </done>
</task>

<task type="auto">
  <name>Task 3: Review and fix Linux code paths</name>
  <files>
    bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjNodeDetector.java
    bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjNodeDownloader.java
    bbj-intellij/src/main/java/com/basis/bbj/intellij/lsp/BbjLanguageServer.java
    bbj-intellij/src/main/java/com/basis/bbj/intellij/actions/BbjRunActionBase.java
    bbj-intellij/src/main/java/com/basis/bbj/intellij/BbjHomeDetector.java
  </files>
  <action>
Review all platform-dependent code paths for Linux correctness. This is a code review + fix pass per CONTEXT.md -- no Linux runtime testing available.

**Review checklist for each file:**

1. **BbjNodeDetector.java** -- Review Node.js detection:
   - Uses `PathEnvironmentVariableUtil.findInPath("node")` -- this is correct for Linux (searches PATH)
   - Verify `canExecute()` check works for Linux binaries -- it does (Java File API)
   - NO changes expected unless issues found

2. **BbjNodeDownloader.java** -- Review download and extraction:
   - Check `getPlatformName()`: Returns "linux" for `SystemInfo.isLinux` -- correct
   - Check `getArchitecture()`: Currently returns "x64" for Linux regardless. This is wrong for Linux ARM64 (e.g., Raspberry Pi, AWS Graviton). Fix by adding ARM64 detection for Linux:
   ```java
   private static @NotNull String getArchitecture() {
       if (SystemInfo.isAarch64) {
           return "arm64";
       }
       if (!SystemInfo.is64Bit) {
           throw new UnsupportedOperationException("32-bit systems are not supported");
       }
       return "x64";
   }
   ```
   This simplifies the method: ARM64 detection applies to ALL platforms (macOS, Linux), then falls through to x64 check.
   - Check `extractTarGz()`: Uses `tar` command -- available on all Linux distros, correct
   - Check executable permission: `targetPath.toFile().setExecutable(true)` -- correct for Linux
   - Check `getNodeDataDirectory()`: Uses `PathManager.getPluginsPath()` -- IntelliJ handles this per-platform, correct

3. **BbjLanguageServer.java** -- Review language server startup:
   - `resolveNodePath()` falls through to "node" string if all detection fails -- on Linux this will work if node is on PATH
   - `resolveServerPath()` uses `PluginManagerCore.getPlugin()` which is platform-agnostic
   - `GeneralCommandLine` with `setWorkDirectory(new File(project.getBasePath()))` -- `File` handles forward slashes on all platforms
   - NO changes expected unless issues found

4. **BbjRunActionBase.java** -- Review run command paths:
   - `getBbjExecutablePath()`: Uses `SystemInfo.isWindows ? "bbj.exe" : "bbj"` -- correct, Linux uses "bbj" same as macOS
   - Uses `new File(bbjHome, "bin/" + exeName)` -- forward slash works on Linux/macOS
   - `getClasspathArg()`: Returns `-CP<entry>` -- this is a BBj flag, NOT a Java classpath. No path separator issue here since it's a single entry name, not a file path list
   - `getWebBbjPath()`: Uses `plugin.getPluginPath().resolve("lib/tools/web.bbj")` -- Path.resolve is cross-platform, correct
   - NO changes expected unless issues found

5. **BbjHomeDetector.java** -- Review BBj home detection:
   - `getCommonLocations()`: Returns `"/usr/local/bbx", "/opt/bbx", "/opt/basis/bbj"` for non-Windows -- these are standard Linux BBj locations, correct
   - `detectFromInstallerTrace()`: Uses `Paths.get(System.getProperty("user.home"), "BASIS", "Install.properties")` -- forward slashes, works on Linux
   - `isValidBbjHome()`: Uses `new File(path, "cfg/BBj.properties")` -- cross-platform, correct
   - NO changes expected unless issues found

**Summary of expected fixes:**
- BbjNodeDownloader.java: Simplify `getArchitecture()` to detect ARM64 on ALL platforms (not just macOS)
- All other files: Confirm correct, add clarifying comments where Linux behavior differs

If any additional issues are discovered during review, fix them and document in the summary.
  </action>
  <verify>
Run `./gradlew build` from bbj-intellij/ -- build succeeds. Inspect BbjNodeDownloader.getArchitecture(): ARM64 detection covers Linux (not just macOS). Verify all files use platform-agnostic APIs: PathEnvironmentVariableUtil for PATH searches, File/Path for filesystem operations, SystemInfo for platform detection.
  </verify>
  <done>
All Linux code paths reviewed and confirmed correct or fixed. BbjNodeDownloader ARM64 detection extended to Linux. No hardcoded path separators found. PathEnvironmentVariableUtil used for PATH searches. Build compiles.
  </done>
</task>

</tasks>

<verification>
1. `./gradlew build` in bbj-intellij/ compiles successfully
2. BbjServerService has FileEditorManagerListener tracking open BBj files
3. Grace period: 30-second timer, cancellable on file reopen
4. BbjStatusBarWidget shows "BBj: Idle" during grace period
5. BbjCompletionFeature wired into LSP4IJ via setCompletionFeature() in BbjLanguageServerFactory
6. BbjCompletionFeature uses AllIcons.Nodes (no BbjIcons dependency for completion icons)
7. Java-interop completions show distinct icons (AbstractMethod/AbstractClass) from BBj completions (Method/Class)
8. Orphaned icon files (bbj-function.svg, bbj-variable.svg, bbj-keyword.svg) deleted
9. BbjIcons.java has no FUNCTION/VARIABLE/KEYWORD constants
10. bbj-intellij/META-INF/ directory deleted
11. BbjNodeDownloader detects ARM64 on Linux (not just macOS)
12. No hardcoded path separators in any file
</verification>

<success_criteria>
- Build compiles with zero errors
- FIX-04: LS stays alive 30 seconds after last file close, reuses on reopen
- FIX-05: Completion popup uses platform AllIcons.Nodes icons, with Java-interop completions visually distinct from BBj completions
- FIX-06: Stale bbj-intellij/META-INF/ directory removed
- FIX-07: Linux paths correct (ARM64 detection, PATH-based Node.js lookup, platform-agnostic file ops)
</success_criteria>

<output>
After completion, create `.planning/phases/10-bug-fixes-polish/10-02-SUMMARY.md`
</output>
