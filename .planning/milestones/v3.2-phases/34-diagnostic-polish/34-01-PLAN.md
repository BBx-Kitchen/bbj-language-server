---
phase: 34-diagnostic-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/package.json
  - bbj-vscode/src/language/bbj-validator.ts
  - bbj-vscode/test/imports.test.ts
autonomous: true

must_haves:
  truths:
    - "VS Code settings panel shows 'BBj' (capital B, capital B, lowercase j) in the AutoSaveUponRun description, not 'bbj'"
    - "A USE statement referencing a non-existent file path shows an error diagnostic on the bbjFilePath portion"
    - "USE statements referencing valid (indexed) file paths produce no new diagnostics"
    - "Existing import tests continue to pass without regression"
  artifacts:
    - path: "bbj-vscode/package.json"
      provides: "Corrected product name capitalization in settings description"
      contains: "Auto Save upon run of BBj program"
    - path: "bbj-vscode/src/language/bbj-validator.ts"
      provides: "BBj file path validation in checkUsedClassExists"
      contains: "use.bbjFilePath"
    - path: "bbj-vscode/test/imports.test.ts"
      provides: "Test for unresolvable file path diagnostic"
      contains: "could not be resolved"
  key_links:
    - from: "bbj-vscode/src/language/bbj-validator.ts"
      to: "IndexManager.allElements(BbjClass.$type)"
      via: "checkUsedClassExists BBj file path branch"
      pattern: "indexManager\\.allElements"
    - from: "bbj-vscode/src/language/bbj-validator.ts"
      to: "BBjWorkspaceManager.getSettings().prefixes"
      via: "PREFIX directory resolution for candidate paths"
      pattern: "workspaceManager\\.getSettings"
---

<objective>
Fix product name capitalization in VS Code settings and add error diagnostics for unresolvable BBj file paths in USE statements.

Purpose: POL-01 corrects a branding inconsistency where "bbj" appears lowercase in settings. POL-02 gives users immediate, actionable feedback when a USE statement references a file that doesn't exist, instead of silently failing to resolve.

Output: Updated package.json with correct "BBj" capitalization, extended validator with BBj file path checking, and tests proving the diagnostic works.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-diagnostic-polish/34-RESEARCH.md

@bbj-vscode/package.json (line 303 — "bbj program" text to fix)
@bbj-vscode/src/language/bbj-validator.ts (checkUsedClassExists method at line 275)
@bbj-vscode/src/language/bbj-scope.ts (BBjPathPattern export at line 56, getBBjClassesFromFile at line 219)
@bbj-vscode/src/language/bbj-module.ts (BBjServices type, service wiring)
@bbj-vscode/test/imports.test.ts (existing USE statement tests)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix settings capitalization and add BBj file path validation</name>
  <files>
    bbj-vscode/package.json
    bbj-vscode/src/language/bbj-validator.ts
  </files>
  <action>
**POL-01: Settings capitalization (package.json line 303)**

Change `"description": "Auto Save upon run of bbj program"` to `"description": "Auto Save upon run of BBj program"`. This is the only occurrence of incorrect "bbj" capitalization in user-facing settings descriptions. The configuration title on line 268 already reads "BBj configuration" correctly.

**POL-02: BBj file path validation (bbj-validator.ts)**

1. Add imports to bbj-validator.ts:
   - `AstUtils, IndexManager, URI, UriUtils` from `'langium'` (AstUtils may already be imported — check first; IndexManager is NEW)
   - `BBjPathPattern` from `'./bbj-scope.js'`
   - `BBjWorkspaceManager` from `'./bbj-ws-manager.js'`
   - `BbjClass` from `'./generated/ast.js'` (may already be partially imported — add BbjClass to existing import)
   - `resolve` from `'path'` (already imported — verify)

2. Add fields to BBjValidator class (alongside existing javaInterop and typeInferer):
   ```typescript
   protected readonly indexManager: IndexManager;
   protected readonly workspaceManager: BBjWorkspaceManager;
   ```

3. Initialize in constructor:
   ```typescript
   this.indexManager = services.shared.workspace.IndexManager;
   this.workspaceManager = services.shared.workspace.WorkspaceManager as BBjWorkspaceManager;
   ```

4. Extend the `checkUsedClassExists` method. After the existing `if (use.javaClass)` block, add a new block for BBj file paths:

   ```typescript
   if (use.bbjFilePath) {
       const match = use.bbjFilePath.match(BBjPathPattern);
       if (match) {
           const cleanPath = match[1];
           const currentDocUri = AstUtils.getDocument(use).uri;
           const prefixes = this.workspaceManager.getSettings()?.prefixes ?? [];
           const adjustedFileUris = [
               UriUtils.resolvePath(UriUtils.dirname(currentDocUri), cleanPath)
           ].concat(
               prefixes.map(prefixPath => URI.file(resolve(prefixPath, cleanPath)))
           );
           const resolved = this.indexManager.allElements(BbjClass.$type).some(bbjClass => {
               return adjustedFileUris.some(adjustedFileUri =>
                   bbjClass.documentUri.toString().toLowerCase().endsWith(adjustedFileUri.fsPath.toLowerCase())
               );
           });
           if (!resolved) {
               accept('error', `File '${cleanPath}' could not be resolved. Check the file path and PREFIX configuration.`, {
                   node: use,
                   property: 'bbjFilePath'
               });
           }
       }
   }
   ```

   This uses the exact same path resolution strategy as `getBBjClassesFromFile` in bbj-scope.ts (relative to current doc + PREFIX directories), and the same case-insensitive `.toLowerCase()` matching. It checks whether ANY BbjClass exists at the resolved paths via the index (synchronous — no async issues). The error targets the `bbjFilePath` property so the squiggly appears on the `::path::` portion only.

   Important: The `typeResolutionWarningsEnabled` guard at the top of checkUsedClassExists already covers this new code path, so users who disable type resolution warnings won't see these errors either.
  </action>
  <verify>
Run `cd bbj-vscode && npx vitest run` — all existing tests pass. Specifically verify that the import tests in `test/imports.test.ts` still pass (they use `use ::importMe.bbj::ImportMe` which resolves via the test's pre-parsed document).
  </verify>
  <done>
Line 303 of package.json reads "Auto Save upon run of BBj program". The checkUsedClassExists method handles both `use.javaClass` (existing) and `use.bbjFilePath` (new) branches. Existing import tests pass without regression.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add test for unresolvable BBj file path diagnostic</name>
  <files>
    bbj-vscode/test/imports.test.ts
  </files>
  <action>
Add a new test to the existing `describe('Import tests', ...)` block in `imports.test.ts` that verifies an error diagnostic appears for a USE statement with a non-existent file path.

```typescript
test('USE with non-existent file path produces error diagnostic', async () => {
    const document = await parse(`
        use ::nonexistent/file.bbj::SomeClass
    `, { validation: true });
    expectNoParserLexerErrors(document);
    // Should have exactly one validation error about unresolvable file
    const errors = document.diagnostics?.filter(d => d.severity === 1) ?? [];
    expect(errors).toHaveLength(1);
    expect(errors[0].message).toContain("could not be resolved");
});
```

Note: In the LSP protocol, `DiagnosticSeverity.Error === 1`. The test uses `severity === 1` to filter for errors only (excluding warnings from other validators).

Also add a complementary test confirming that valid BBj file paths (from the existing `importMe.bbj` parsed in `beforeAll`) produce NO new diagnostics — this is already covered by the existing `'Import full-qualified, use afterwards'` test, but add an explicit assertion comment to make it clear:

```typescript
test('USE with valid file path produces no file-path error', async () => {
    const document = await parse(`
        use ::importMe.bbj::ImportMe
        let x = new ImportMe()
    `, { validation: true });
    expectNoParserLexerErrors(document);
    // No error diagnostics — file path resolves via pre-parsed importMe.bbj
    const errors = document.diagnostics?.filter(d => d.severity === 1) ?? [];
    expect(errors).toHaveLength(0);
});
```
  </action>
  <verify>
Run `cd bbj-vscode && npx vitest run test/imports.test.ts` — both new tests pass. The non-existent file test shows 1 error diagnostic. The valid file test shows 0 error diagnostics.
  </verify>
  <done>
Two new tests exist: one confirming error diagnostic for unresolvable path, one confirming no error for valid path. Both pass. Total import test count increased by 2.
  </done>
</task>

</tasks>

<verification>
1. `cd bbj-vscode && npx vitest run` — full test suite passes (no regressions)
2. `grep -n "BBj program" bbj-vscode/package.json` — line 303 shows "BBj" not "bbj"
3. `grep -n "bbjFilePath" bbj-vscode/src/language/bbj-validator.ts` — validator handles BBj file path validation
4. `npx vitest run test/imports.test.ts` — import tests pass including 2 new tests for file path diagnostics
</verification>

<success_criteria>
- VS Code settings description for AutoSaveUponRun reads "Auto Save upon run of BBj program"
- USE statement `use ::nonexistent.bbj::Foo` produces error diagnostic on the `::nonexistent.bbj::` portion with message containing "could not be resolved"
- USE statement `use ::importMe.bbj::ImportMe` (where importMe.bbj is indexed) produces zero error diagnostics
- All existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/34-diagnostic-polish/34-01-SUMMARY.md`
</output>
