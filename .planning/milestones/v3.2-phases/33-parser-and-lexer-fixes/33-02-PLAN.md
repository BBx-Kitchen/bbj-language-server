---
phase: 33-parser-and-lexer-fixes
plan: 02
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - bbj-vscode/src/language/bbj.langium
  - bbj-vscode/src/language/bbj-lexer.ts
  - bbj-vscode/test/parser.test.ts
autonomous: true

must_haves:
  truths:
    - "`mode$` and other `$`-suffixed variables inside DEF FN within class methods produce no lexer errors"
    - "`%`-suffixed and `!`-suffixed variables inside DEF FN within class methods also work"
    - "Multi-line DEF FN inside class method bodies with suffixed variables works"
    - "`select (chan)template FROM fileid` parses without false line-break errors"
    - "`select` with WHERE, SORTBY, and LIMIT clauses parses correctly"
    - "Existing parser tests continue to pass (no regressions from Plan 01 baseline)"
  artifacts:
    - path: "bbj-vscode/src/language/bbj.langium"
      provides: "SelectStatement grammar rule and DEF FN fixes"
      contains: "SelectStatement"
    - path: "bbj-vscode/test/parser.test.ts"
      provides: "Test coverage for DEF FN suffixed variables and SELECT verb"
  key_links:
    - from: "bbj-vscode/src/language/bbj.langium"
      to: "SingleStatement alternatives"
      via: "SelectStatement added to statement list"
      pattern: "SelectStatement"
---

<objective>
Fix two remaining parser/lexer bugs: suffixed variables ($, %, !) inside DEF FN within class method bodies producing lexer errors (PARSE-02), and add SELECT verb grammar support to eliminate false parse errors on valid SELECT statements (PARSE-03).

Purpose: Eliminate the last two false error patterns blocking clean diagnostics on valid BBj code.
Output: Updated grammar, potentially lexer, and tests; full test suite passing.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-parser-and-lexer-fixes/33-RESEARCH.md
@.planning/phases/33-parser-and-lexer-fixes/33-01-SUMMARY.md
@bbj-vscode/src/language/bbj.langium
@bbj-vscode/src/language/bbj-lexer.ts
@bbj-vscode/src/language/validations/line-break-validation.ts
@bbj-vscode/test/parser.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix DEF FN with suffixed variables inside class methods</name>
  <files>
    bbj-vscode/src/language/bbj.langium
    bbj-vscode/src/language/bbj-lexer.ts
    bbj-vscode/test/parser.test.ts
  </files>
  <action>
**PARSE-02: DEF FN suffixed variables in class methods**

The known issue states: "Single-line DEF FN inside class methods not parsed correctly by validate test helper (parser/lexer RPAREN_NO_NL token issue)."

The problem specifically affects suffixed variables (`mode$`, `count%`, `obj!`) inside DEF FN definitions when the DEF FN is inside a class method body. It works in main program scope.

**Diagnosis approach:**

1. First, write targeted test cases that reproduce the exact failure:

```typescript
test('PARSE-02: DEF FN with $ suffix variable in class method (#355)', async () => {
    const result = await parse(`
        class public TestClass
            method public void doWork()
                DEF FNGetMode$(X$)=X$+"_mode"
                mode$ = FNGetMode$("test")
                PRINT mode$
            methodend
        classend
    `);
    expectNoParserLexerErrors(result);
});

test('PARSE-02: DEF FN with % suffix variable in class method (#355)', async () => {
    const result = await parse(`
        class public TestClass
            method public void calc()
                DEF FNDouble%(X%)=X%*2
                result% = FNDouble%(5)
                PRINT result%
            methodend
        classend
    `);
    expectNoParserLexerErrors(result);
});

test('PARSE-02: DEF FN with ! suffix variable in class method (#355)', async () => {
    const result = await parse(`
        class public TestClass
            method public void process()
                DEF FNGetObj!(X!)=X!
                obj! = FNGetObj!(NULL())
            methodend
        classend
    `);
    expectNoParserLexerErrors(result);
});

test('PARSE-02: Multi-line DEF FN with suffixed vars in class method (#355)', async () => {
    const result = await parse(`
        class public TestClass
            method public void process()
                DEF FNFormat$(value$, prefix$)
                    result$ = prefix$ + ": " + value$
                    RETURN result$
                FNEND
                output$ = FNFormat$("hello", "msg")
                PRINT output$
            methodend
        classend
    `);
    expectNoParserLexerErrors(result);
});
```

2. Run the tests to see the exact error messages (lexer errors vs parser errors). Examine the error output to identify the token that causes the failure.

3. The root cause is likely one of:
   - **RPAREN_NO_NL interaction**: In single-line DEF FN `DEF FNA$(X$)=X$+"_mode"`, the `)` before `=` is `RPAREN_NO_NL`. The suffixed function name `FNA$` includes the `$` as part of `ID_WITH_SUFFIX`. The lexer may be confused by `FNA$` vs the `$` being part of a hex string or other token.
   - **ID_WITH_SUFFIX vs FN name**: The DEF FN name pattern `FN` + identifier may conflict with how `ID_WITH_SUFFIX` terminal matches.
   - **Context interaction**: Inside a method body, the lexer's line-continuation preprocessing may alter the token stream differently than in program scope.

4. Based on error output, apply the appropriate fix:

   **If the issue is DEF FN name with suffix** (e.g., `FNGetMode$` not tokenizing correctly):
   - Check how `FeatureName` (which includes `ID_WITH_SUFFIX`) works in the DEF FN name position
   - The DEF FN grammar rule (line 272-276) uses `name=FeatureName` which allows `ID_WITH_SUFFIX`
   - The FN name itself includes the suffix -- verify this is correctly handled

   **If the issue is RPAREN_NO_NL in the single-line form**:
   - The grammar rule `RPAREN_NO_NL '=' value=Expression` (line 274) expects `)=` without newline
   - Inside a method body, Langium may apply different token resolution
   - Try changing the pattern or adjusting terminal precedence

   **If the issue is line-continuation preprocessing in bbj-lexer.ts**:
   - The `prepareLineSplitter` method joins lines starting with `:` into a single line
   - Check if this preprocessing corrupts the DEF FN structure inside method bodies
   - Add debug logging to track what the lexer receives

5. Apply the minimal fix to make all DEF FN patterns work inside class method bodies. Remember: per user decision, this must be a solid fix, not a workaround. Both single-line and multi-line DEF FN forms must work.

After making changes, run:
```bash
cd bbj-vscode && npm run langium:generate && npm run build && npx vitest run test/parser.test.ts
```
  </action>
  <verify>
    Run `cd bbj-vscode && npm run langium:generate && npm run build && npx vitest run test/parser.test.ts` -- all new PARSE-02 tests pass, all previously-passing tests still pass.
  </verify>
  <done>
    1. `DEF FNGetMode$(X$)=X$+"_mode"` inside a class method body produces no lexer/parser errors
    2. All three suffixes ($, %, !) work in DEF FN inside method bodies
    3. Multi-line DEF FN with suffixed variables inside method bodies works
    4. Existing DEF FN tests (GRAM-04 tests on lines 2249-2278) still pass
    5. No regressions
  </done>
</task>

<task type="auto">
  <name>Task 2: Add SELECT verb grammar rule</name>
  <files>
    bbj-vscode/src/language/bbj.langium
    bbj-vscode/test/parser.test.ts
  </files>
  <action>
**PARSE-03: SELECT verb grammar**

SELECT is a BBj verb that is currently not in the grammar at all. Per the BBj documentation and user decisions, the full syntax is:

```
SELECT (channelno{,MODE=string}{,ERR=lineref})template
{:fieldname{,fieldname...}} FROM fileid {WHERE expr} {SORTBY expr} {LIMIT first, count}
```

**Step 1: Add SelectStatement to the grammar**

In `bbj.langium`, add a new `SelectStatement` rule. Follow the pattern used by `ReadStatement` and `OpenStatement`:

```langium
SelectStatement:
    'SELECT' '(' channelno=Expression Mode? Err? RPAREN_NO_NL
    template=Expression
    (':' fields+=Expression (',' fields+=Expression)*)?
    'FROM' fileid=Expression
    ('WHERE' where=Expression)?
    ('SORTBY' sortby=Expression)?
    ('LIMIT' limitFirst=Expression ',' limitCount=Expression)?
;
```

**Key grammar design notes:**
- Uses `RPAREN_NO_NL` after the channel spec (like `OpenStatement`) because the template follows on the same logical line
- `Mode` and `Err` use existing fragments (lines 530-524) -- they handle `,MODE=expr` and `,ERR=lineref`
- Field list uses `:` prefix (`:field1,field2`) -- this is the standard BBj field list syntax
- `FROM`, `WHERE`, `SORTBY` are used as keywords in this position only (they remain valid identifiers elsewhere since they aren't in the global keywords list -- Langium handles this automatically)
- `LIMIT` takes two expressions separated by comma
- Multi-line SELECT uses standard BBj `:` line-continuation (handled by `bbj-lexer.ts` `prepareLineSplitter` already)

**Step 2: Add SelectStatement to SingleStatement alternatives**

In the `SingleStatement` rule (around line 26-118), add `SelectStatement` to the list. Place it near the other verb statements (e.g., after `SaveStatement` or before `SortStatement`):

```langium
SingleStatement:
    KeywordStatement |
    ReadStatement |
    ...
    SelectStatement |
    ...
    ExpressionStatement
;
```

IMPORTANT: `SelectStatement` must appear BEFORE `ExpressionStatement` in the alternatives since `SELECT` could otherwise be parsed as an identifier/expression.

**Step 3: Handle keyword conflicts**

`FROM`, `WHERE`, `SORTBY`, `LIMIT` are contextual keywords only within SELECT. They should NOT be added to `ValidName` exclusions. Langium handles this automatically -- keywords used inline in parser rules are context-specific.

However, verify that `FROM` is not already a keyword that would conflict. Search for `'FROM'` in the grammar. If it exists elsewhere, ensure no ambiguity. If not found, it's safe to add.

**Step 4: Add tests**

```typescript
test('PARSE-03: SELECT verb basic syntax (#295)', async () => {
    const result = await parse(`
        ch = 1
        SELECT (ch)rec$ FROM "customers.dat"
    `);
    expectNoParserLexerErrors(result);
});

test('PARSE-03: SELECT verb with MODE and ERR (#295)', async () => {
    const result = await parse(`
        ch = 1
        SELECT (ch,MODE="BLOCK=200",ERR=errLabel)rec$ FROM "customers.dat"
        errLabel: STOP
    `);
    expectNoParserLexerErrors(result);
});

test('PARSE-03: SELECT verb with field list (#295)', async () => {
    const result = await parse(`
        ch = 1
        SELECT (ch)rec$:rec.name$,rec.phone$ FROM "customers.dat"
    `);
    expectNoParserLexerErrors(result);
});

test('PARSE-03: SELECT verb with WHERE and SORTBY (#295)', async () => {
    const result = await parse(`
        ch = 1
        SELECT (ch)rec$:rec.name$,rec.balance FROM "customers.dat" WHERE (rec.balance>rec.limit) SORTBY rec.name$
    `);
    expectNoParserLexerErrors(result);
});

test('PARSE-03: SELECT verb with LIMIT (#295)', async () => {
    const result = await parse(`
        ch = 1
        SELECT (ch)rec$ FROM "customers.dat" LIMIT 0, 100
    `);
    expectNoParserLexerErrors(result);
});

test('PARSE-03: SELECT verb with all clauses (#295)', async () => {
    const result = await parse(`
        ch = 1
        SELECT (ch,MODE="BLOCK=200")rec$:rec.name$,rec.balance FROM "customers.dat" WHERE (rec.balance>1000) SORTBY rec.name$ LIMIT 0, 50
    `);
    expectNoParserLexerErrors(result);
});

test('PARSE-03: SELECT verb with line continuation (#295)', async () => {
    const result = await parse(`
        ch = 1
        SELECT (ch,MODE="BLOCK=200")rec$:rec.cust_num$,rec.name$,
: rec.phone$,rec.limit,rec.balance FROM "customers.dat"
: WHERE (rec.balance>rec.limit) SORTBY rec.name$
    `);
    expectNoParserLexerErrors(result);
});
```

**Step 5: Verify line-break-validation doesn't flag SELECT**

Check `bbj-vscode/src/language/validations/line-break-validation.ts`. The `isStandaloneStatement` function (line 119-138) applies line-break checks to statements. SELECT follows the same pattern as other standalone statements (needs its own line). The existing logic should handle it correctly since SELECT is a standard statement. No changes needed to line-break-validation.ts unless tests show false positives.

After making changes, run:
```bash
cd bbj-vscode && npm run langium:generate && npm run build && npx vitest run test/parser.test.ts
```
  </action>
  <verify>
    Run `cd bbj-vscode && npm run langium:generate && npm run build && npx vitest run test/parser.test.ts` -- all new PARSE-03 tests pass, all previously-passing tests still pass including PARSE-01, PARSE-02, and PARSE-04 tests from Plan 01 and Task 1.
  </verify>
  <done>
    1. `SELECT (ch)rec$ FROM "customers.dat"` parses without errors
    2. SELECT with MODE, ERR, field list, WHERE, SORTBY, and LIMIT all parse correctly
    3. Multi-line SELECT with `:` continuation parses correctly
    4. No false line-break validation errors on SELECT statements
    5. No regressions in existing parser tests
  </done>
</task>

</tasks>

<verification>
1. `npm run langium:generate` completes without errors
2. `npm run build` compiles successfully
3. `npx vitest run test/parser.test.ts` shows all new tests passing, existing 177+ passing baseline maintained
4. Run `npx vitest run` to check full test suite (not just parser tests) for any regressions
5. The 6 known pre-existing failures remain unchanged (not increased)
</verification>

<success_criteria>
- DEF FN with suffixed variables ($, %, !) inside class method bodies produces no lexer or parser errors
- SELECT verb with all documented clauses (FROM, WHERE, SORTBY, LIMIT, MODE, ERR) parses correctly
- No regressions in existing parser tests
- All four PARSE requirements (01, 02, 03, 04) are satisfied across both plans
</success_criteria>

<output>
After completion, create `.planning/phases/33-parser-and-lexer-fixes/33-02-SUMMARY.md`
</output>
