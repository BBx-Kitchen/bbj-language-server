---
phase: 32-regression-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/lib/bbj-api.ts
  - bbj-vscode/src/language/bbj-ws-manager.ts
  - bbj-vscode/src/language/bbj-linker.ts
  - bbj-vscode/test/bbj-test-module.ts
  - bbj-vscode/test/linking.test.ts
autonomous: true

must_haves:
  truths:
    - "BBjAPI() resolves without linker error regardless of Java interop status"
    - "Case-insensitive BBjAPI access works (BbJaPi(), BBJAPI(), bbjapi())"
    - "Variables assigned from BBjAPI() have type BBjAPI enabling chained completion"
    - "Existing linker tests continue to pass"
  artifacts:
    - path: "bbj-vscode/src/language/lib/bbj-api.ts"
      provides: "Built-in synthetic BBjAPI class definition"
      contains: "class public BBjAPI"
    - path: "bbj-vscode/src/language/bbj-ws-manager.ts"
      provides: "Loads bbj-api.ts as additional document"
      contains: "builtinBBjAPI"
  key_links:
    - from: "bbj-vscode/src/language/lib/bbj-api.ts"
      to: "bbj-vscode/src/language/bbj-ws-manager.ts"
      via: "import and loadAdditionalDocuments collector"
      pattern: "builtinBBjAPI"
    - from: "bbj-vscode/src/language/bbj-linker.ts"
      to: "scope.getElement('BBjAPI')"
      via: "linker getCandidate case-insensitive lookup finds synthetic class in scope"
      pattern: "scope\\.getElement\\('BBjAPI'\\)"
---

<objective>
Make BBjAPI() always resolve as a built-in type, independent of Java interop service.

Purpose: BBjAPI() is the most-used factory function in BBj. When Java interop is unavailable, it currently fails to resolve, producing a linker error and breaking all downstream completion. This is the REG-01 regression.

Output: A synthetic built-in BBjAPI class loaded via Langium's built-in library pattern, ensuring `api! = BBjAPI()` never shows a linker error and `api!` has type BBjAPI for downstream member completion.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/32-regression-fixes/32-CONTEXT.md
@.planning/phases/32-regression-fixes/32-RESEARCH.md
@bbj-vscode/src/language/bbj-ws-manager.ts
@bbj-vscode/src/language/bbj-linker.ts
@bbj-vscode/src/language/bbj-scope.ts
@bbj-vscode/src/language/bbj-type-inferer.ts
@bbj-vscode/src/language/bbj-module.ts
@bbj-vscode/src/language/lib/functions.ts
@bbj-vscode/test/bbj-test-module.ts
@bbj-vscode/test/linking.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create built-in BBjAPI class and load it as synthetic document</name>
  <files>
    bbj-vscode/src/language/lib/bbj-api.ts
    bbj-vscode/src/language/bbj-ws-manager.ts
  </files>
  <action>
Create `bbj-vscode/src/language/lib/bbj-api.ts` following the exact same pattern as `lib/functions.ts`, `lib/variables.ts`, `lib/labels.ts`, and `lib/events.ts`. Export a `builtinBBjAPI` string constant containing a minimal BBj class definition:

```
class public BBjAPI
classend
```

This is a BbjClass (not a JavaClass), which means it will be indexed automatically by Langium and found via the scope provider. The linker's existing case-insensitive lookup at bbj-linker.ts:106-110 looks for 'BBjAPI' in scope. Currently it only finds it if the Java interop service has loaded a JavaClass named BBjAPI. With this synthetic BbjClass document, the name 'BBjAPI' will always be in scope.

In `bbj-ws-manager.ts`:
1. Import `builtinBBjAPI` from `./lib/bbj-api.js`
2. In `loadAdditionalDocuments()`, add a line after the existing collectors:
   `collector(this.documentFactory.fromString(builtinBBjAPI, URI.parse('bbjlib:///bbj-api.bbl')));`

Use the URI scheme `bbjlib:///` consistent with the other built-in documents.

IMPORTANT: The synthetic class is intentionally minimal (no methods). Method signatures come from the Java interop service when available. The built-in just ensures the TYPE exists so `api! = BBjAPI()` resolves and `api!` gets type BBjAPI. When Java interop IS available, the JavaClass version with full methods will also be in scope; the linker will find whichever is available. This is fine because chained calls like `api!.getConfig()` use the type inferer which checks JavaClass first.

NOTE on type inference for BBjAPI(): The type inferer in `bbj-type-inferer.ts` handles `isMethodCall(expression)` by calling `this.getType(expression.method)`. For `BBjAPI()`, `expression.method` is a SymbolRef whose `symbol.ref` resolves to the BbjClass named BBjAPI (or JavaClass if interop is running). The type inferer already handles `isClass(reference)` at line 37, returning the class directly. So `api!` will get type BBjAPI (BbjClass) which enables member completion through the scope provider's `createBBjClassMemberScope`. When Java interop is available, the members come from the JavaClass version instead. This is the correct behavior per user decision: "Only BBjAPI() itself needs special built-in treatment -- chained calls resolve through normal return-type inference."
  </action>
  <verify>
Run `npm test` from `bbj-vscode/` directory. All existing tests should pass (this change only ADDS a built-in document, it doesn't modify existing behavior). Specifically check that no new test failures appear beyond the 18 pre-existing failures documented in project history.
  </verify>
  <done>
The file `bbj-vscode/src/language/lib/bbj-api.ts` exists and exports `builtinBBjAPI`. The `loadAdditionalDocuments` method in `bbj-ws-manager.ts` loads it as a synthetic document with URI `bbjlib:///bbj-api.bbl`. Existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix BBjAPI linking test and add comprehensive regression tests</name>
  <files>
    bbj-vscode/test/linking.test.ts
    bbj-vscode/test/bbj-test-module.ts
    bbj-vscode/src/language/bbj-linker.ts
  </files>
  <action>
**Fix the skipped BBjAPI test in linking.test.ts:**

The test at line 126 (`test.skip('Case insensitive access to BBjAPI', ...)`) was skipped because the test module's `JavaInteropTestService` adds JavaClasses without triggering Langium indexing. With the new built-in BbjClass document, the BBjAPI type is now loaded via `loadAdditionalDocuments` and indexed automatically. Unskip this test (change `test.skip` to `test`).

However, there is a subtlety: the linker at bbj-linker.ts:106-110 currently only looks for BBjAPI when the container is a MethodCall AND the property is 'symbol' (it's inside the `isSymbolRef(refInfo.container)` block where `refInfo.container.$containerProperty === 'method'`). The scope lookup `scope.getElement('BBjAPI')` searches the NamedElement scope, which includes both JavaClass entries AND BbjClass entries (via importedBBjClasses). The built-in BbjClass named 'BBjAPI' will be found through the `importedBBjClasses` path since it's loaded as a BbjClass document.

Wait -- actually review the scope provider more carefully. In `getScope()` at bbj-scope.ts, when `isSymbolRef(context.container)` AND it's a method call context (the `$containerProperty === 'method'` branch falls through to `super.getCandidate` in the linker), the linker's special case at line 106-110 calls `this.scopeProvider.getScope(refInfo)` which goes to the default case. The default NamedElement scope at bbj-scope.ts:289-298 returns JavaClass entries and LibMember entries. BbjClasses are NOT in the NamedElement global scope by default.

**Critical fix needed in bbj-linker.ts:** The BBjAPI special case at line 106-110 needs to also search for BbjClass in scope, not just JavaClass. Two options:

Option A (simpler): In the special case block, after the existing scope lookup, if `description` is undefined, also search the program's imported BBj classes. But this is fragile.

Option B (better, per user decision "hardcode recognition"): Instead of relying on scope lookup, make the linker directly return a description for the built-in BBjAPI BbjClass. Add a static field to BbjLinker (similar to `ERR_PARAM`) that holds a pre-built AstNodeDescription pointing to the built-in BBjAPI document URI:

```typescript
static BBJAPI_DESC: AstNodeDescription = {
    type: BbjClass.$type,
    name: 'BBjAPI',
    documentUri: URI.parse('bbjlib:///bbj-api.bbl'),
    path: ''  // Will be resolved at link time
};
```

Then in the special case block (line 106-110), change the logic to:
1. First try the existing scope lookup (finds JavaClass if interop is running)
2. If not found, return `BbjLinker.BBJAPI_DESC` (always resolves to built-in BbjClass)

Actually, the simpler and more correct approach: Since the built-in BBjAPI class document gets indexed, BbjClasses from it appear in the scope via `importedBBjClasses` in the SymbolRef branch (bbj-scope.ts:182). But the BBjAPI case is in the MethodCall branch (refInfo.container.$containerProperty === 'method'), which calls the general scope. Let me trace again:

In `getCandidate()` at bbj-linker.ts:89-113:
- Line 89-104: `isSymbolRef` AND NOT a method call container -> custom scope logic
- Line 106-111: `isSymbolRef` AND method call container AND refText is 'bbjapi' -> special case, scope.getElement('BBjAPI')

The `this.scopeProvider.getScope(refInfo)` call at line 108 for a SymbolRef in a method-call position goes to the `isSymbolRef` branch in bbj-scope.ts:172-206. Specifically, it creates `memberAndImports` which includes `this.importedBBjClasses(program)`. The built-in BBjAPI class is NOT imported via USE statements, so it won't appear in `importedBBjClasses`.

The built-in BBjAPI class WILL appear in the NamedElement global scope via `getGlobalScope` at bbj-scope.ts:288-303 for `NamedElement.$type` when `isSymbolRef` and `property === 'symbol'`. But wait, that scope only includes LibMembers, JavaClasses, and JavaPackages -- NOT BbjClasses.

**The correct fix:** Since BBjAPI is being loaded as a BbjClass (not a JavaClass), and the existing scope paths for method calls don't include BbjClasses in the global scope, we need to handle this in the linker. The cleanest approach per user decision ("hardcode recognition so it always resolves"):

In the BBjAPI special case block in `getCandidate()` (bbj-linker.ts:106-111):
1. Keep the existing scope lookup as first attempt (finds JavaClass when interop is running)
2. If scope lookup returns nothing, search the index for a BbjClass named 'BBjAPI':
   ```typescript
   if (!description) {
       const indexManager = (this.wsManager() as BBjWorkspaceManager).services?.shared.workspace.IndexManager;
       // ... or simpler: use the workspace manager to find it
   }
   ```

Actually, the simplest approach: use `this.scopeProvider.getScope()` which already works, but the issue is the scope doesn't include BbjClasses in this context. Since we want BBjAPI to ALWAYS resolve, let's add a fallback in the linker that queries the index directly:

```typescript
if (refInfo.reference.$refText.toLowerCase() === 'bbjapi' && isMethodCall(symbolRef.$container)) {
    const scope = this.scopeProvider.getScope(refInfo);
    const description = scope.getElement('BBjAPI');
    if (description) {
        return description;
    }
    // Fallback: find built-in BBjAPI BbjClass via index
    const wsManager = this.wsManager();
    if (wsManager instanceof BBjWorkspaceManager) {
        const indexManager = wsManager['indexManager'] as IndexManager;
        const bbjApiDesc = indexManager.allElements(BbjClass.$type).find(
            e => e.name === 'BBjAPI' && e.documentUri.toString().startsWith('bbjlib://')
        );
        if (bbjApiDesc) {
            return bbjApiDesc;
        }
    }
    return this.createLinkingError(refInfo);
}
```

Wait, the linker already has access to services. Let me check... The BbjLinker extends DefaultLinker which has access to `this.scopeProvider`. We need access to the IndexManager. The DefaultLinker doesn't have it directly, but we can get it through services.

Actually, looking more carefully: the cleanest fix is to make the built-in BBjAPI class visible in the global scope. In `getGlobalScope()` at bbj-scope.ts:288-303, for `NamedElement.$type`, add BbjClass entries from the index that come from `bbjlib://` URIs. But this would expose ALL built-in BbjClasses globally, which is actually correct for BBjAPI since it's meant to be an implicit import.

**Final approach (cleanest):** In `BbjScopeProvider.getGlobalScope()`, when `referenceType` is `NamedElement.$type`, include BbjClasses from built-in library documents (URI starts with `bbjlib://`) alongside the existing JavaClass and LibMember entries. This way the existing linker code at line 106-110 will find 'BBjAPI' in scope naturally.

In bbj-scope.ts, in `getGlobalScope()`, in the `NamedElement.$type` case (line 289-298), add built-in BbjClasses:

```typescript
case NamedElement.$type: {
    if (isSymbolRef(_context.container) && _context.property === 'symbol') {
        // Include built-in BbjClasses (from bbjlib:// URIs) alongside standard entries
        const builtinBbjClasses = this.indexManager.allElements(BbjClass.$type)
            .filter(e => e.documentUri.toString().startsWith('bbjlib://'));
        return new StreamScopeWithPredicate(
            libraryIndex(this.indexManager).concat(builtinBbjClasses),
            new StreamScopeWithPredicate(this.indexManager.allElements(JavaClass.$type), javaPackageScope),
            { caseInsensitive: true }
        );
    }
}
```

Hmm, but this changes scope behavior globally. Let me think about whether there are side effects...

The built-in BBjAPI BbjClass would appear in scope for ALL NamedElement symbol lookups, not just BBjAPI(). This means any code like `x = BBjAPI` (without parentheses) would also resolve. But since BBjAPI is case-insensitive and only has one built-in class, the risk is minimal. And actually, the linker's branch at line 89-104 filters out methods/constructors for non-method-call contexts, so a bare `BBjAPI` reference would correctly resolve to the class.

ACTUALLY, upon further reflection, the simplest and most robust approach: Don't modify the scope at all. Instead, modify the linker's BBjAPI special case to import `IndexManager` and do a direct index lookup as fallback. The linker already has `this.wsManager()` which gives access to the shared services. Here's the refined approach:

In `bbj-linker.ts`:
1. Add import for `IndexManager` from langium
2. Add import for `BbjClass` from generated/ast
3. In the BBjAPI special case block, after the existing scope.getElement fails, add fallback:

```typescript
if (refInfo.reference.$refText.toLowerCase() === 'bbjapi' && isMethodCall(symbolRef.$container)) {
    // Special case for BBjAPI implicit import, it can be accessed case insensitively
    const scope = this.scopeProvider.getScope(refInfo);
    const description = scope.getElement('BBjAPI');
    if (description) {
        return description;
    }
    // Fallback: find built-in BBjAPI class (always available, independent of Java interop)
    const wsManager = this.wsManager();
    if (wsManager instanceof BBjWorkspaceManager) {
        const builtinBBjAPI = (wsManager as BBjWorkspaceManager).indexManager
            .allElements(BbjClass.$type)
            .find(e => e.name === 'BBjAPI');
        if (builtinBBjAPI) {
            return builtinBBjAPI;
        }
    }
    return this.createLinkingError(refInfo);
}
```

Wait -- `indexManager` is a protected field on `DefaultWorkspaceManager`. We need it accessible from the linker. The BBjWorkspaceManager doesn't expose it publicly. But looking at Langium's service container, `IndexManager` is available as `services.shared.workspace.IndexManager`. The BbjLinker already stores `wsManager` but not the IndexManager directly.

Simplest: Store a reference to IndexManager in BbjLinker constructor. Add a field `indexManager: () => IndexManager` similar to how `wsManager` is stored. Then use it in the fallback.

In `bbj-linker.ts` constructor:
```typescript
this.indexManager = () => services.shared.workspace.IndexManager;
```

Then in the BBjAPI case:
```typescript
const builtinBBjAPI = this.indexManager().allElements(BbjClass.$type)
    .find(e => e.name === 'BBjAPI');
```

**Implementation in bbj-linker.ts:**
1. Add `IndexManager` to the langium imports
2. Add `BbjClass` to the generated/ast imports
3. Add field: `indexManager: () => IndexManager;`
4. In constructor, add: `this.indexManager = () => services.shared.workspace.IndexManager;`
5. Modify the BBjAPI special case block (lines 106-111) to add the index fallback described above

**Tests in linking.test.ts:**
1. Unskip the existing test (line 126): Change `test.skip('Case insensitive access to BBjAPI'` to `test('Case insensitive access to BBjAPI'`
2. Update the comment (remove the TODO about test module indexing)
3. Add additional test cases:

```typescript
test('BBjAPI() resolves without Java interop', async () => {
    const document = await validate(`
        api! = BBjAPI()
    `)
    expectNoErrors(document)
})

test('BBjAPI() variable enables chained member access', async () => {
    // Note: Without Java interop, BBjAPI resolves to BbjClass which has no methods
    // So chained calls won't resolve. This test verifies the base assignment works.
    const document = await validate(`
        api! = BBjAPI()
        REM api!.getThinClient() would need Java interop for method resolution
    `)
    expectNoErrors(document)
})
```

**In bbj-test-module.ts:**
No changes needed. The `JavaInteropTestService` still creates a fake JavaClass BBjAPI for tests that need it (e.g., interop-dependent tests). The built-in BbjClass BBjAPI will be loaded automatically via `loadAdditionalDocuments` since the test uses `BBjSharedModule` which includes `BBjWorkspaceManager`. Both the BbjClass and JavaClass named BBjAPI will be in scope; the linker will find whichever matches first (JavaClass via scope, then BbjClass via index fallback).
  </action>
  <verify>
Run `npm test` from `bbj-vscode/`. The previously skipped 'Case insensitive access to BBjAPI' test should now pass. All new BBjAPI tests should pass. No regressions in other linking tests.

Specifically verify:
1. `npx vitest run test/linking.test.ts` -- all tests pass including the unskipped one
2. `npx vitest run` -- full suite passes (within expected pre-existing failure count)
  </verify>
  <done>
The 'Case insensitive access to BBjAPI' test is unskipped and passes. New BBjAPI resolution tests pass. BBjAPI() resolves without linker error regardless of Java interop service status. All existing linking tests continue to pass.
  </done>
</task>

</tasks>

<verification>
1. Run full test suite: `cd bbj-vscode && npm test` -- pass count should increase (unskipped test + new tests)
2. Grep for `test.skip` in linking.test.ts -- the BBjAPI test should no longer be skipped
3. Verify built-in file exists: `cat bbj-vscode/src/language/lib/bbj-api.ts` should show BBjAPI class definition
4. Verify ws-manager loads it: grep for `builtinBBjAPI` in bbj-ws-manager.ts
5. Verify linker fallback: grep for `BbjClass` in bbj-linker.ts (the index lookup fallback)
</verification>

<success_criteria>
- `api! = BBjAPI()` produces no linker error in tests
- `BbJaPi()` (case-insensitive) produces no linker error in tests
- Built-in BBjAPI class loads independently of Java interop
- All existing tests pass (no regressions)
- Previously skipped BBjAPI test is now active and passing
</success_criteria>

<output>
After completion, create `.planning/phases/32-regression-fixes/32-01-SUMMARY.md`
</output>
