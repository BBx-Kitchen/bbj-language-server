---
phase: 28-variable-scoping-declaration-order
plan: 02
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - bbj-vscode/test/variable-scoping.test.ts
  - bbj-vscode/src/language/validations/check-variable-scoping.ts
autonomous: true

must_haves:
  truths:
    - "Use-before-assignment hint fires for LET, DIM, DREAD, FOR init, and plain assignment variables used above their first declaration"
    - "Use-before-assignment hint does NOT fire for DECLARE variables (whole-scope visibility)"
    - "Use-before-assignment hint does NOT fire for unresolved references (linking warning is sufficient)"
    - "DREAD counts as an assignment point -- variables first assigned via DREAD suppress use-before-assignment for subsequent usages"
    - "A DREAD referencing a variable previously DIM'd as an array resolves without error"
    - "Conflicting DECLARE types produce an error diagnostic with both type names and the line of the first DECLARE"
    - "Same-type duplicate DECLAREs do NOT produce an error"
    - "DECLARE AUTO does not flag type mismatches vs plain DECLARE (for this phase, treated as same type)"
    - "Existing tests pass -- no regressions"
  artifacts:
    - path: "bbj-vscode/test/variable-scoping.test.ts"
      provides: "Comprehensive test coverage for SCOPE-01, SCOPE-04, SCOPE-05"
      min_lines: 100
  key_links:
    - from: "bbj-vscode/test/variable-scoping.test.ts"
      to: "bbj-vscode/src/language/validations/check-variable-scoping.ts"
      via: "validationHelper triggers registered checks"
      pattern: "validate.*variable-scoping"
---

<objective>
Comprehensive test suite for variable scoping validation + edge case fixes.

Purpose: Verify all three SCOPE requirements (SCOPE-01, SCOPE-04, SCOPE-05) with targeted tests, and fix any edge cases discovered during test writing.

Output: A thorough test file and any necessary fixes to the validation logic.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-variable-scoping-declaration-order/28-CONTEXT.md
@.planning/phases/28-variable-scoping-declaration-order/28-RESEARCH.md
@.planning/phases/28-variable-scoping-declaration-order/28-01-SUMMARY.md
@bbj-vscode/src/language/validations/check-variable-scoping.ts
@bbj-vscode/test/validation.test.ts
@bbj-vscode/test/linking.test.ts
@bbj-vscode/test/test-helper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Comprehensive test suite for variable scoping</name>
  <files>bbj-vscode/test/variable-scoping.test.ts</files>
  <action>
Create `bbj-vscode/test/variable-scoping.test.ts` following the test patterns from `validation.test.ts`.

Use `createBBjServices(EmptyFileSystem)` and `validationHelper<Program>` as in existing tests. Use `beforeAll` with `initializeWorkspace`.

Use Langium's `expectIssue` (from `langium/test`) for hint-severity diagnostics, and `expectError` for error-severity diagnostics. Also use `expectNoIssues` for positive cases.

**Test structure with describe blocks:**

```
describe('Variable Scoping', () => {
    describe('SCOPE-01: Use before assignment', () => { ... })
    describe('SCOPE-04: DIM/DREAD linkage', () => { ... })
    describe('SCOPE-05: DECLARE type propagation', () => { ... })
})
```

**SCOPE-01 Tests (use-before-assignment):**

1. "Variable used before LET shows hint" -- `PRINT x$` then `LET x$ = "hello"` -> expect hint on PRINT line containing 'used before assignment'
2. "Variable used after LET shows no hint" -- `LET x$ = "hello"` then `PRINT x$` -> expectNoIssues (or only non-scoping issues)
3. "Variable used before DIM shows hint" -- `PRINT a$` then `DIM a$[10]` -> expect hint
4. "Variable used before plain assignment shows hint" -- `PRINT y` then `y = 5` -> expect hint
5. "Variable used before FOR init shows hint" -- `PRINT i` then `FOR i = 1 TO 10` / `NEXT i` -> expect hint
6. "DREAD counts as assignment" -- `PRINT a$` then `DREAD a$` -> expect hint on PRINT; then `DREAD b$` then `PRINT b$` -> no hint on second PRINT
7. "Variable in compound statement" -- `x = 1 ; PRINT y ; y = 2` -> expect hint for y used before assignment
8. "No hint for DECLARE variable used before DECLARE statement" -- `PRINT myVar!.charAt(1)` then `DECLARE java.lang.String myVar!` -> expect NO use-before-assignment hint (DECLARE has whole-scope visibility)
9. "Method scope: use before assignment in method body" -- Inside a class method, `PRINT x` then `x = 5` -> expect hint
10. "Method params are always visible" -- `method public test(BBjString name!)` then `PRINT name!` at top of body -> no hint
11. "No hint for unresolved references" -- `PRINT unknownVar$` (never assigned anywhere) -> should NOT produce use-before-assignment hint (only linking warning)
12. "Assignment inside IF counts (branching ignored)" -- `IF cond THEN x = 1` then later `PRINT x` BELOW the IF -> no hint (the IF line is above, so assignment is "before" usage per user decision)
13. "Multiple variables, some before some after" -- `PRINT a ; b = 1 ; PRINT b ; a = 2` -> hint for `a` on first PRINT, no hint for `b` on second PRINT
14. "READ statement variables count as assignment" -- `READ(1)a$,b$` then `PRINT a$` -> no hint

**SCOPE-04 Tests (DIM/DREAD linkage):**

15. "DREAD after DIM resolves without error" -- `DIM a$[10]` then `DREAD a$` -> no linking errors
16. "DREAD creates variable in scope if not DIM'd" -- `DREAD x$` then `PRINT x$` -> no linking errors (DREAD creates the variable)
17. "DIM then DREAD preserves array info" -- `DIM key$[10]` then `DREAD key$` -> no errors, key$ resolves

**SCOPE-05 Tests (DECLARE and conflicting types):**

18. "Conflicting DECLARE types produce error" -- `DECLARE java.lang.String x!` then `DECLARE java.lang.Integer x!` -> expect error containing 'Conflicting DECLARE'
19. "Same-type duplicate DECLARE is fine" -- `DECLARE java.lang.String x!` twice -> no error
20. "DECLARE in method body applies to entire method" -- Already covered by existing linking.test.ts 'DECLARE anywhere in method body' test, but add explicit no-hint verification
21. "DECLARE AUTO property is parsed" -- `DECLARE AUTO java.lang.String x!` -> parses without error. Verify the node has `auto === true`.

**Important implementation notes:**
- Use `DiagnosticSeverity.Hint` (value 4) from `vscode-languageserver` to check hint severity
- For hint checks, filter `validationResult.diagnostics` by severity === DiagnosticSeverity.Hint and check the message
- The `expectIssue` helper from `langium/test` can be used but may not directly support hint severity. If not, manually filter diagnostics.
- BBj is case-insensitive. Variable names in test snippets should test both cases (e.g., `X` vs `x`).
- Use valid BBj syntax in test snippets. Lines do NOT need indentation for BBj; the test strings are parsed as full programs.
- For class/method tests, wrap in `class public TestClass` / `classend`.
  </action>
  <verify>
Run `npx vitest run bbj-vscode/test/variable-scoping.test.ts` -- all new tests should pass.
Run `npx vitest run` from project root -- all existing tests should still pass (no regressions).
  </verify>
  <done>
All SCOPE-01 use-before-assignment tests pass (hint severity fires correctly, does not fire for DECLARE/unresolved/params).
All SCOPE-04 DIM/DREAD tests pass (DREAD after DIM resolves, DREAD creates variables).
All SCOPE-05 DECLARE tests pass (conflicting types error, same-type duplicate OK, auto property parsed).
Full test suite has no regressions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix edge cases discovered during testing</name>
  <files>bbj-vscode/src/language/validations/check-variable-scoping.ts</files>
  <action>
After writing the tests in Task 1, run them. If any tests fail due to edge cases in the validation logic, fix the validation implementation. Common edge cases to watch for:

1. **SymbolRef inside array subscript of DREAD** -- `DREAD COLOR$[ALL]` has an ArrayElement wrapping the SymbolRef. The validation should handle `isArrayElement(item)` within DREAD items by extracting the receiver variable name.

2. **ForStatement variable not being a SymbolRef** -- The ForStatement `init` is an `Assignment`, and `init.variable` may be a SymbolRef. Extract: `isSymbolRef(init.variable) ? init.variable.symbol.$refText : undefined`.

3. **ENTER statement variables** -- EnterStatement uses `variables` property (not `items`). Make sure the walk handles `isEnterStatement` -> `stmt.variables`.

4. **Nested class/method scoping** -- The Program-level check must NOT descend into BbjClass bodies or MethodDecl bodies. Similarly, MethodDecl-level check must NOT descend into nested DefFunction bodies. Use appropriate tree traversal bounds.

5. **SymbolRef that resolves to a library function/field** -- Skip any SymbolRef whose `.ref` resolves to something from the library (isLibFunction, isLibMember, etc.). These are global definitions, not local variables.

6. **Case sensitivity in DECLARE conflict detection** -- Both the variable name AND the type name comparison must be case-insensitive for variable names, but type names should use the canonical form from `getFQNFullname()`.

If all tests pass on first run, this task is a no-op. Just verify and move on.
  </action>
  <verify>
Run `npx vitest run bbj-vscode/test/variable-scoping.test.ts` -- ALL tests pass.
Run `npx vitest run` from project root -- full suite passes, no regressions.
Run `npm run build` in `bbj-vscode/` -- compiles cleanly.
  </verify>
  <done>
All variable-scoping tests pass. All existing tests pass. Build is clean. Edge cases are handled correctly.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run bbj-vscode/test/variable-scoping.test.ts` -- all tests pass
2. `npx vitest run` from project root -- no regressions (18 known pre-existing failures acceptable)
3. `npm run build` in `bbj-vscode/` -- clean build
4. Manual check: test file covers all three SCOPE requirements with positive and negative cases
</verification>

<success_criteria>
- Test file exists with 15+ test cases covering SCOPE-01, SCOPE-04, SCOPE-05
- All new tests pass
- No regressions in existing test suite
- Edge cases in validation logic are fixed
- Phase 28 success criteria are demonstrably met through passing tests
</success_criteria>

<output>
After completion, create `.planning/phases/28-variable-scoping-declaration-order/28-02-SUMMARY.md`
</output>
