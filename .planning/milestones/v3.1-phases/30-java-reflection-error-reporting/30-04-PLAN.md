---
phase: 30-java-reflection-error-reporting
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/bbj-type-inferer.ts
  - bbj-vscode/src/language/validations/check-classes.ts
  - bbj-vscode/test/classes.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "a! = a!.toString() does NOT produce a cyclic reference error"
    - "class public A extends B / class public B extends A produces a cyclic inheritance error on both classes"
    - "Cyclic inheritance error message names the classes involved in the cycle"
    - "Existing class access-level checks and inheritance resolution are unaffected"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-type-inferer.ts"
      provides: "Re-entrancy guard preventing false cyclic detection"
      contains: "resolving"
    - path: "bbj-vscode/src/language/validations/check-classes.ts"
      provides: "Cyclic inheritance validator"
      contains: "cyclic"
    - path: "bbj-vscode/test/classes.test.ts"
      provides: "Tests for both fixes"
      contains: "cyclic"
  key_links:
    - from: "bbj-vscode/src/language/bbj-type-inferer.ts"
      to: "Langium linker"
      via: "re-entrancy guard returns undefined instead of triggering cyclic error"
      pattern: "resolving.*has"
    - from: "bbj-vscode/src/language/validations/check-classes.ts"
      to: "bbj-vscode/src/language/bbj-nodedescription-provider.ts"
      via: "getClass() to walk extends chain"
      pattern: "getClass.*extends"
---

<objective>
Fix two cyclic reference detection bugs identified in UAT: (1) eliminate false positive cyclic reference errors on self-referencing variable assignments like `a! = a!.toString()`, and (2) add dedicated cyclic inheritance detection for class hierarchies like `A extends B` / `B extends A`.

Purpose: Close the last UAT gap in Phase 30 so cyclic reference errors are accurate -- no false positives on variable self-references, and actual class inheritance cycles are properly detected with meaningful error messages.

Output: Modified type inferer with re-entrancy guard, new cyclic inheritance validator in check-classes.ts, and tests covering both fixes.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/30-java-reflection-error-reporting/30-02-SUMMARY.md
@.planning/debug/cyclic-reference-detection.md
@bbj-vscode/src/language/bbj-type-inferer.ts
@bbj-vscode/src/language/validations/check-classes.ts
@bbj-vscode/src/language/bbj-scope.ts
@bbj-vscode/test/classes.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add re-entrancy guard to BBjTypeInferer.getType()</name>
  <files>bbj-vscode/src/language/bbj-type-inferer.ts</files>
  <action>
Add a `private resolving = new Set<AstNode>()` field to BBjTypeInferer.

At the top of getType(), check if the expression is already in the resolving set. If so, return undefined immediately (this breaks the re-entrant chain that causes the false positive).

Otherwise, add the expression to the resolving set, execute the existing logic, and remove it from the set in a finally block.

The re-entrancy chain that causes the false positive is:
1. MemberCall(a!.toString()).member starts resolving (Langium sets _ref = RefResolving)
2. BbjScopeProvider.getScope() calls typeInferer.getType(receiver = SymbolRef(a!))
3. getType resolves a! -> Assignment node
4. getType(Assignment) calls getType(assignment.value) where value IS the same MemberCall
5. getType(MemberCall) accesses expression.member.ref -> _ref === RefResolving -> Langium throws cyclic error

By detecting that we're already inside getType() for the same MemberCall expression (step 4->5), we return undefined instead of accessing member.ref again, preventing Langium's re-entrancy guard from firing.

Implementation pattern:
```typescript
private resolving = new Set<AstNode>();

public getType(expression: Expression): JavaPackage | Class | undefined {
    if (this.resolving.has(expression)) {
        return undefined;
    }
    this.resolving.add(expression);
    try {
        // ... existing getType body ...
    } finally {
        this.resolving.delete(expression);
    }
}
```

Do NOT change any of the existing type inference logic inside the method body. Only wrap it with the guard.
  </action>
  <verify>Run `npx vitest run --reporter=verbose` from bbj-vscode/ directory. All existing tests pass, especially the "Inheritance chain resolution" and "Classes access-levels" test suites. No new test failures introduced.</verify>
  <done>BBjTypeInferer.getType() has a re-entrancy guard that prevents the same expression from being resolved recursively, eliminating the false positive cyclic reference error on patterns like `a! = a!.toString()`.</done>
</task>

<task type="auto">
  <name>Task 2: Add cyclic inheritance validator and tests</name>
  <files>bbj-vscode/src/language/validations/check-classes.ts, bbj-vscode/test/classes.test.ts</files>
  <action>
**Part A: Add cyclic inheritance check in check-classes.ts**

Add a new method `checkCyclicInheritance` to the ClassValidator class. Register it in the BbjClass validation check (inside the existing `BbjClass:` handler, after the visibility check, after the extends/implements forEach loops).

The check should:
1. For each BbjClass, walk the extends chain using `getClass(bbjType.extends[0])` (BBj classes support single inheritance only -- the `extends` array has at most 1 element for classes)
2. Use a `visited: Set<BbjClass>` starting with the current class
3. At each step, resolve the super class via `getClass()`. If the resolved super is a BbjClass and is already in visited, report a cyclic inheritance error
4. Stop walking if: super is not a BbjClass (it's a JavaClass or undefined), or depth exceeds 20 (MAX_INHERITANCE_DEPTH), or cycle detected
5. Error message format: `"Cyclic inheritance detected: class '${klass.name}' is involved in an inheritance cycle."` with severity "error"
6. Report the error on `{ node: decl, property: 'extends', index: 0 }`

Import `getClass` from `'../bbj-nodedescription-provider.js'` (already imported as `getClassRef` -- add `getClass` to the import).

The check goes inside the existing `BbjClass:` handler. After the visibility check early return and after the existing extends/implements forEach loops, add:

```typescript
// Check for cyclic inheritance
if (decl.extends.length > 0) {
    validator.checkCyclicInheritance(decl, accept);
}
```

The method implementation:
```typescript
public checkCyclicInheritance(klass: BbjClass, accept: ValidationAcceptor): void {
    const visited = new Set<BbjClass>();
    visited.add(klass);
    let current: BbjClass | undefined = klass;
    while (current && current.extends.length > 0) {
        const superType = getClass(current.extends[0]);
        if (!isBbjClass(superType)) {
            break; // Java class or unresolvable -- stop walking
        }
        if (visited.has(superType)) {
            accept("error", `Cyclic inheritance detected: class '${klass.name}' is involved in an inheritance cycle.`, {
                node: klass,
                property: 'extends',
                index: 0
            });
            return;
        }
        visited.add(superType);
        current = superType;
    }
}
```

**Part B: Add tests in classes.test.ts**

Add a new describe block `"Cyclic inheritance detection"` in classes.test.ts (after the existing "Inheritance chain resolution" describe block). Follow the exact same pattern used in the existing test suites (services setup, validate helper, disposables, beforeAll, afterEach).

Tests to add:

1. **"Direct cyclic inheritance (A extends B, B extends A) reports error"**
   - Input: Two public classes A extends B and B extends A in the same file
   - Expect: At least one diagnostic containing "Cyclic inheritance"
   - Both classes should get the error

2. **"Self-extending class (A extends A) reports error"**
   - Input: `class public A extends A`
   - Expect: diagnostic containing "Cyclic inheritance"

3. **"Three-class cycle (A extends B, B extends C, C extends A) reports error"**
   - Input: Three public classes forming a cycle
   - Expect: diagnostics containing "Cyclic inheritance"

4. **"No false positive on valid linear inheritance"**
   - Input: `class public Base` / `class public Child extends Base`
   - Expect: zero diagnostics

5. **"No false positive on self-referencing variable assignment"**
   - Input: `a! = a!.toString()` (inside a class method where `a!` is assigned an object)
   - This tests the type inferer fix from Task 1
   - Expect: zero diagnostics containing "Cyclic" (there may be unresolved reference warnings for toString since EmptyFileSystem lacks java.lang.Object, but no cyclic errors)

For test 5, use a pattern like:
```typescript
const { diagnostics } = await validate(`
    class public Foo
        method public doWork()
            declare auto Foo a!
            a! = a!.toString()
        methodend
    classend
`);
const cyclicErrors = diagnostics.filter(d => d.message.toLowerCase().includes('cyclic'));
expect(cyclicErrors).toHaveLength(0);
```

Note: The `toString()` member call may produce an unresolved reference warning since java.lang.Object is not available in EmptyFileSystem tests. That is expected and fine -- we only care that there is NO cyclic reference error. If `toString()` causes issues due to member resolution, simplify to just `a! = a!` (plain self-assignment without method call) to test the non-cyclic case, though the method-call version is the real regression test.
  </action>
  <verify>Run `npx vitest run --reporter=verbose` from bbj-vscode/ directory. All new cyclic inheritance tests pass. All existing tests still pass (753+ tests). Specifically verify: the "Cyclic inheritance detection" test suite shows all tests passing, and the "Inheritance chain resolution" suite has zero regressions.</verify>
  <done>Cyclic class inheritance is detected with meaningful error messages. Self-referencing variable access (a! = a!.toString()) does not produce false cyclic errors. All existing tests continue passing.</done>
</task>

</tasks>

<verification>
1. `npx vitest run --reporter=verbose` from bbj-vscode/ -- all tests pass including new cyclic inheritance tests
2. New "Cyclic inheritance detection" test suite has 5 passing tests
3. No regressions in "Inheritance chain resolution" or "Classes access-levels" suites
4. No regressions in overall test count (was 753+, should be 758+)
</verification>

<success_criteria>
- `a! = a!.toString()` produces zero cyclic reference errors
- `class public A extends B` / `class public B extends A` produces cyclic inheritance errors
- Self-extending class (`A extends A`) produces cyclic inheritance error
- Valid linear inheritance chains produce zero errors
- All pre-existing tests pass without regression
</success_criteria>

<output>
After completion, create `.planning/phases/30-java-reflection-error-reporting/30-04-SUMMARY.md`
</output>
