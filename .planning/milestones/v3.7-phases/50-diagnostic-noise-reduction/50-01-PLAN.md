---
phase: 50-diagnostic-noise-reduction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/bbj-document-validator.ts
autonomous: true
requirements:
  - DIAG-01
  - DIAG-02

must_haves:
  truths:
    - "A file with parse errors shows only parse errors and semantic errors — no linking errors appear"
    - "A file with any Error-severity diagnostic shows no warnings or hints"
    - "Parse errors are capped at a configurable maximum (default 20)"
    - "The suppression hierarchy is extensible — adding a BBjCPL tier in Phase 53 requires only adding an enum value and a classification check"
    - "When suppression is disabled via setSuppressCascading(false), all diagnostics pass through unfiltered"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-document-validator.ts"
      provides: "validateDocument() override with applyDiagnosticHierarchy(), DiagnosticTier enum, module-level config flags"
      contains: "applyDiagnosticHierarchy"
  key_links:
    - from: "BBjDocumentValidator.validateDocument()"
      to: "super.validateDocument()"
      via: "await super call, then post-process returned Diagnostic[]"
      pattern: "super\\.validateDocument"
    - from: "applyDiagnosticHierarchy()"
      to: "DiagnosticTier enum"
      via: "getDiagnosticTier() classifies each diagnostic"
      pattern: "getDiagnosticTier"
---

<objective>
Implement the core diagnostic suppression logic in BBjDocumentValidator that eliminates cascading noise when parse errors exist and enforces a clean diagnostic hierarchy.

Purpose: Users currently see 40+ diagnostics for a single syntax error because linking errors cascade. This plan reduces that to 1-3 meaningful diagnostics by suppressing linking errors when parse errors are present, and suppressing all warnings/hints when any Error-severity diagnostic exists.

Output: Modified `bbj-document-validator.ts` with `validateDocument()` override, extensible `DiagnosticTier` enum, `applyDiagnosticHierarchy()` filter function, and module-level config flags (`setSuppressCascading`, `setMaxErrors`).
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-diagnostic-noise-reduction/50-RESEARCH.md
@bbj-vscode/src/language/bbj-document-validator.ts
@bbj-vscode/src/language/bbj-validator.ts (lines 22-26 — module-level flag pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add module-level config flags and validateDocument override with extensible hierarchy</name>
  <files>bbj-vscode/src/language/bbj-document-validator.ts</files>
  <action>
Add the following to `bbj-document-validator.ts`:

**1. Module-level config flags** (follow the exact pattern from `bbj-validator.ts` lines 22-26):

```typescript
// Diagnostic suppression configuration
let suppressCascadingEnabled = true;
let maxErrorsDisplayed = 20;

export function setSuppressCascading(enabled: boolean): void {
    suppressCascadingEnabled = enabled;
}
export function setMaxErrors(max: number): void {
    maxErrorsDisplayed = max;
}
```

Place these ABOVE the `BBjDocumentValidator` class definition, after the `ValidationOptions` interface.

**2. DiagnosticTier enum** (extensible for Phase 53):

```typescript
/**
 * Diagnostic source tiers — ordered by priority.
 * Higher-priority tiers suppress lower ones.
 * Phase 53 will add BBjCPL = 3 as the highest tier.
 */
const enum DiagnosticTier {
    Warning  = 0,   // warnings/hints — suppressed when any error present
    Semantic = 1,   // semantic/validation errors (Error severity, non-parse)
    Parse    = 2,   // parser errors — also suppress linking errors
    // BBjCPL = 3,  // Phase 53: compiler errors — suppress everything below
}
```

Place this after the config flags, before the class.

**3. getDiagnosticTier() classifier:**

```typescript
function getDiagnosticTier(d: Diagnostic): DiagnosticTier {
    if (d.data?.code === DocumentValidator.ParsingError) return DiagnosticTier.Parse;
    if (d.severity === DiagnosticSeverity.Error) return DiagnosticTier.Semantic;
    return DiagnosticTier.Warning;
    // Phase 53 adds: if (d.source === 'bbj-cpl') return DiagnosticTier.BBjCPL;
}
```

**4. applyDiagnosticHierarchy() function:**

```typescript
/**
 * Apply the BBj diagnostic hierarchy rules:
 *
 * - Parse errors present → suppress ALL linking errors (identified by data.code, NOT severity)
 * - Any Error-severity diagnostic present → suppress all warnings/hints
 * - Cap parse errors at maxErrors
 *
 * IMPORTANT: Rule 1 matches linking errors by data.code (DocumentValidator.LinkingError),
 * NOT by severity. The existing toDiagnostic() override downgrades non-cyclic linking
 * errors to Warning severity, but they must still be identified and suppressed by their
 * data.code when parse errors exist. Without Rule 1, linking errors would only be
 * suppressed when ANY error exists (Rule 2), which is wrong — linking errors should
 * survive when only semantic errors (no parse errors) are present.
 */
function applyDiagnosticHierarchy(
    diagnostics: Diagnostic[],
    suppressEnabled: boolean,
    maxErrors: number
): Diagnostic[] {
    if (!suppressEnabled) return diagnostics;

    const hasParseErrors = diagnostics.some(
        d => d.data?.code === DocumentValidator.ParsingError
    );
    const hasAnyError = diagnostics.some(
        d => d.severity === DiagnosticSeverity.Error
    );

    let result = diagnostics;

    // Rule 1: parse errors present → suppress ALL linking errors
    // Must match on data.code, not severity (linking errors are downgraded to Warning by toDiagnostic)
    if (hasParseErrors) {
        result = result.filter(
            d => d.data?.code !== DocumentValidator.LinkingError
        );
    }

    // Rule 2: any Error-severity diagnostic → suppress all warnings/hints
    if (hasAnyError) {
        result = result.filter(
            d => d.severity === DiagnosticSeverity.Error
        );
    }

    // Rule 3: cap displayed parse errors at maxErrors (semantic errors never capped)
    const parseErrors = result.filter(d => d.data?.code === DocumentValidator.ParsingError);
    if (parseErrors.length > maxErrors) {
        const nonParseErrors = result.filter(d => d.data?.code !== DocumentValidator.ParsingError);
        result = [...parseErrors.slice(0, maxErrors), ...nonParseErrors];
    }

    return result;
}
```

Place `getDiagnosticTier` and `applyDiagnosticHierarchy` AFTER the `DiagnosticTier` enum, before the class.

**5. Override validateDocument() in BBjDocumentValidator class:**

Add this as the FIRST method in the class body (before `processLinkingErrors`):

```typescript
override async validateDocument(
    document: LangiumDocument,
    options?: ValidationOptions,
    cancelToken?: CancellationToken
): Promise<Diagnostic[]> {
    const diagnostics = await super.validateDocument(document, options, cancelToken);
    return applyDiagnosticHierarchy(diagnostics, suppressCascadingEnabled, maxErrorsDisplayed);
}
```

**6. Add required imports:**

Add `CancellationToken` to the `vscode-languageserver` import (line 4, alongside `Diagnostic`, `DiagnosticSeverity`, `Range`, etc.). Do NOT import it from `langium` — it is not a direct export from langium. The existing imports already include `DocumentValidator`, `LangiumDocument`, `Diagnostic`, and `DiagnosticSeverity`.

**Cross-file suppression decision (Claude's discretion):** Apply suppression per-file only. Each file's diagnostics are filtered based on that file's own parse state. If File B imports broken File A, File B's linking errors survive because File B itself has no parse errors. This is correct — File B's linking errors are real and accurate. The user should fix File A first.

**What to avoid and WHY:**
- Do NOT use `stopAfterParsingErrors` from `ValidationOptions` — it stops ALL further validation including semantic checks that should survive parse errors.
- Do NOT filter by message text — use `d.data?.code` which is stable.
- Do NOT add setTimeout/debounce inside validateDocument — it must return promptly. Langium's built-in rebuild batching handles recovery timing.
- Do NOT modify the existing `toDiagnostic()` or `processLinkingErrors()` overrides — they remain unchanged.
  </action>
  <verify>
Run `npm run build` from `bbj-vscode/` to verify TypeScript compilation succeeds with zero errors. Then run `npm test` to verify existing tests still pass (the 6 pre-existing failures should remain unchanged — no new failures).
  </verify>
  <done>
`bbj-document-validator.ts` contains: (1) exported `setSuppressCascading()` and `setMaxErrors()` functions, (2) `DiagnosticTier` enum with Parse/Semantic/Warning tiers and commented BBjCPL placeholder, (3) `getDiagnosticTier()` classifier, (4) `applyDiagnosticHierarchy()` implementing three rules (linking suppression, warning suppression, parse error cap), (5) `validateDocument()` override calling `super.validateDocument()` then filtering through hierarchy. Build succeeds with zero new errors.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` in `bbj-vscode/` compiles with zero errors
2. `npm test` in `bbj-vscode/` shows no new test failures (6 pre-existing failures unchanged)
3. `grep -c "applyDiagnosticHierarchy" bbj-vscode/src/language/bbj-document-validator.ts` returns 2+ (definition + call site)
4. `grep -c "setSuppressCascading\|setMaxErrors" bbj-vscode/src/language/bbj-document-validator.ts` returns 2+ (function definitions)
5. `grep -c "DiagnosticTier" bbj-vscode/src/language/bbj-document-validator.ts` returns 5+ (enum + usages)
</verification>

<success_criteria>
- BBjDocumentValidator.validateDocument() override exists and calls applyDiagnosticHierarchy on results
- Three suppression rules implemented: linking suppression on parse errors, warning/hint suppression on any error, parse error cap
- Extensible DiagnosticTier enum has Parse, Semantic, Warning values with commented BBjCPL placeholder
- Module-level setSuppressCascading() and setMaxErrors() exported for Plan 02 to wire
- Build and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/50-diagnostic-noise-reduction/50-01-SUMMARY.md`
</output>
