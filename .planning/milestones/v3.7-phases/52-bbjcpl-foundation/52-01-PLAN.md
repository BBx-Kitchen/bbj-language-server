---
phase: 52-bbjcpl-foundation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/test/test-data/cpl-fixtures/single-error.bbj
  - bbj-vscode/test/test-data/cpl-fixtures/multiple-errors.bbj
  - bbj-vscode/test/test-data/cpl-fixtures/no-errors.bbj
  - bbj-vscode/test/test-data/cpl-fixtures/single-error-stderr.txt
  - bbj-vscode/test/test-data/cpl-fixtures/multiple-errors-stderr.txt
  - bbj-vscode/test/test-data/cpl-fixtures/no-errors-stderr.txt
  - bbj-vscode/test/cpl-parser.test.ts
  - bbj-vscode/src/language/bbj-cpl-parser.ts
autonomous: false
requirements:
  - CPL-01
  - CPL-03

must_haves:
  truths:
    - "Real bbjcpl stderr output has been captured against synthetic .bbj files and committed as fixture files"
    - "The output parser produces LSP Diagnostic objects with correct 0-based line numbers from bbjcpl's 1-based physical line numbers"
    - "Empty stderr input produces an empty diagnostic array"
    - "Multiple errors in one file produce multiple diagnostics with correct independent line numbers"
    - "The parser ignores non-error lines (source code lines, blank lines, stdout content)"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-cpl-parser.ts"
      provides: "parseBbjcplOutput() function"
      exports: ["parseBbjcplOutput"]
    - path: "bbj-vscode/test/cpl-parser.test.ts"
      provides: "Parser unit tests against real fixtures"
      min_lines: 40
    - path: "bbj-vscode/test/test-data/cpl-fixtures/single-error-stderr.txt"
      provides: "Real single-error bbjcpl output"
    - path: "bbj-vscode/test/test-data/cpl-fixtures/multiple-errors-stderr.txt"
      provides: "Real multi-error bbjcpl output"
  key_links:
    - from: "bbj-vscode/test/cpl-parser.test.ts"
      to: "bbj-vscode/src/language/bbj-cpl-parser.ts"
      via: "import { parseBbjcplOutput }"
      pattern: "parseBbjcplOutput"
    - from: "bbj-vscode/src/language/bbj-cpl-parser.ts"
      to: "vscode-languageserver"
      via: "import { Diagnostic, DiagnosticSeverity, Range }"
      pattern: "DiagnosticSeverity\\.Error"
---

<objective>
Capture real bbjcpl compiler output as test fixtures, then TDD an output parser that converts bbjcpl stderr into LSP Diagnostic objects.

Purpose: Establish empirically verified test data (CPL-01) and a thoroughly tested parser (CPL-03) before building the process lifecycle service. The parser is the critical correctness component — if line numbers or severity are wrong, all downstream diagnostics are wrong.

Output: Committed fixture files with real bbjcpl output, a `parseBbjcplOutput()` function, and a comprehensive test suite validating against those fixtures.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-bbjcpl-foundation/52-CONTEXT.md
@.planning/phases/52-bbjcpl-foundation/52-RESEARCH.md
</context>

<tasks>

<task type="checkpoint:human-action">
  <name>Task 1: Capture real bbjcpl output as test fixtures</name>
  <action>
This task requires a real bbjcpl installation. The user must have BBj installed with `bbjcpl` accessible.

**Step 1: Create synthetic .bbj test files with deliberate errors.**

Create `bbj-vscode/test/test-data/cpl-fixtures/` directory with these files:

`single-error.bbj` — One syntax error (extra closing paren):
```bbj
rem Single error test fixture
class public TestClass
    method public void brokenMethod())
        print "hello"
    methodend
classend
```

`multiple-errors.bbj` — Three syntax errors:
```bbj
rem Multiple error test fixture
class public TestClass
    method public void firstBroken())
        print "hello"
    methodend
    method public void secondBroken(
        print "world"
    methodend
classend
```

`no-errors.bbj` — Valid BBj file:
```bbj
rem No errors test fixture
class public TestClass
    method public void validMethod()
        print "hello"
    methodend
classend
```

**Step 2: User runs bbjcpl against each file and captures output.**

Ask the user to run these commands (adjust bbjcpl path for their system):

```bash
# Capture stderr for single error
bbjcpl -N bbj-vscode/test/test-data/cpl-fixtures/single-error.bbj 2> bbj-vscode/test/test-data/cpl-fixtures/single-error-stderr.txt

# Capture stderr for multiple errors
bbjcpl -N bbj-vscode/test/test-data/cpl-fixtures/multiple-errors.bbj 2> bbj-vscode/test/test-data/cpl-fixtures/multiple-errors-stderr.txt

# Capture stderr for no errors (should be empty)
bbjcpl -N bbj-vscode/test/test-data/cpl-fixtures/no-errors.bbj 2> bbj-vscode/test/test-data/cpl-fixtures/no-errors-stderr.txt

# Also capture stdout to check for unexpected content
bbjcpl -N bbj-vscode/test/test-data/cpl-fixtures/single-error.bbj > bbj-vscode/test/test-data/cpl-fixtures/single-error-stdout.txt 2>/dev/null
```

**Step 3: Inspect the captured output.**

Read the captured stderr files. Document the actual format observed. Pay special attention to:
- Exact format of error lines (does it match `<filepath>: error at line <legacy> (<physical>):` from CONTEXT.md?)
- Whether any non-error content appears (warnings, info, banners)
- Whether stdout has any content
- Whether the physical line numbers in parentheses are accurate

**Step 4: Commit the fixture files.**

Commit both the synthetic .bbj files AND the captured stderr .txt files as test fixtures.

If the real bbjcpl output format differs from the documented format in CONTEXT.md, update the regex in Task 2 accordingly. The empirical output is authoritative.
  </action>
  <resume-signal>Paste the captured stderr content (or confirm fixtures are committed). If the format differs from expectations, describe the differences.</resume-signal>
</task>

<task type="auto">
  <name>Task 2: TDD the bbjcpl output parser</name>
  <files>
    bbj-vscode/src/language/bbj-cpl-parser.ts
    bbj-vscode/test/cpl-parser.test.ts
  </files>
  <action>
**TDD RED phase: Write tests first.**

Create `bbj-vscode/test/cpl-parser.test.ts` with these test cases. Use the captured fixture content from Task 1 (read the committed .txt files) as test inputs. Do NOT use hardcoded strings if real fixtures differ from the documented format.

Test cases:
1. **Single error:** Parse the single-error-stderr.txt content. Expect exactly 1 diagnostic with:
   - `severity === DiagnosticSeverity.Error`
   - `source === 'BBj Compiler'`
   - `range.start.line` equal to the physical line number minus 1 (0-based)
   - `range.start.character === 0`
   - `range.end.character === Number.MAX_SAFE_INTEGER`
   - `message` contains "Syntax error"

2. **Multiple errors:** Parse the multiple-errors-stderr.txt content. Expect the correct number of diagnostics with independent, accurate line numbers.

3. **No errors (empty stderr):** Parse empty string. Expect empty array.

4. **Non-error lines ignored:** Parse a string containing source code lines (the indented second line of each error) mixed with error lines. Only error lines should produce diagnostics.

5. **Line number off-by-one guard:** Explicitly verify that physical line `(34)` from bbjcpl maps to LSP line `33` (0-based).

Import pattern:
```typescript
import { describe, test, expect } from 'vitest';
import { parseBbjcplOutput } from '../src/language/bbj-cpl-parser.js';
import { DiagnosticSeverity } from 'vscode-languageserver';
import * as fs from 'fs';
import * as path from 'path';
```

Read fixture files using `fs.readFileSync()` in `beforeAll` or inline.

Run tests — they MUST fail (function does not exist yet).

**TDD GREEN phase: Implement the parser.**

Create `bbj-vscode/src/language/bbj-cpl-parser.ts`:

```typescript
import { Diagnostic, DiagnosticSeverity, Range } from 'vscode-languageserver';

// Match: "/path/to/file.bbj: error at line 340 (34):"
// Group 1 captures the physical line number (in parentheses)
const ERROR_LINE_RE = /^.+:\s+error at line \d+ \((\d+)\):/;

export function parseBbjcplOutput(stderr: string): Diagnostic[] {
    const diagnostics: Diagnostic[] = [];
    if (!stderr.trim()) return diagnostics;

    const lines = stderr.split('\n');

    for (const line of lines) {
        const match = ERROR_LINE_RE.exec(line);
        if (!match) continue;

        // bbjcpl reports 1-based physical lines; LSP ranges are 0-based
        const physicalLine = parseInt(match[1], 10) - 1;

        const range: Range = {
            start: { line: physicalLine, character: 0 },
            end:   { line: physicalLine, character: Number.MAX_SAFE_INTEGER },
        };

        diagnostics.push({
            range,
            severity: DiagnosticSeverity.Error,
            source: 'BBj Compiler',
            message: `Syntax error at line ${physicalLine + 1}`,
        });
    }

    return diagnostics;
}
```

**IMPORTANT:** If the real bbjcpl output captured in Task 1 differs from the expected format:
- Adjust the regex `ERROR_LINE_RE` to match the ACTUAL output
- Adjust the message extraction if bbjcpl provides richer error text
- Update tests to match actual expectations

Run tests — they MUST all pass.

**TDD REFACTOR phase (if needed):** If the regex or function can be simplified, refactor. Tests must still pass.

Commit pattern:
- RED: `test(52-01): add failing tests for bbjcpl output parser`
- GREEN: `feat(52-01): implement bbjcpl output parser`
- REFACTOR (optional): `refactor(52-01): clean up parser`
  </action>
  <verify>
Run `npm test -- --run bbj-vscode/test/cpl-parser.test.ts` — all tests pass. Run full test suite `npm test` — no regressions (6 pre-existing failures unchanged).
  </verify>
  <done>
parseBbjcplOutput() converts real bbjcpl stderr into accurate LSP Diagnostic objects. Every fixture produces correct diagnostics with 0-based line numbers, Error severity, and "BBj Compiler" source label.
  </done>
</task>

</tasks>

<verification>
1. Fixture files exist in `bbj-vscode/test/test-data/cpl-fixtures/` with real bbjcpl output
2. `parseBbjcplOutput()` is exported from `bbj-cpl-parser.ts`
3. All parser tests pass against real fixture data
4. No regressions in existing test suite
5. Line numbers verified correct (1-based to 0-based conversion)
</verification>

<success_criteria>
- Real bbjcpl stderr captured and committed as test fixtures (CPL-01)
- Parser produces correct LSP Diagnostics validated against real output (CPL-03)
- Off-by-one line number conversion verified
- TDD commits present (RED then GREEN)
</success_criteria>

<output>
After completion, create `.planning/phases/52-bbjcpl-foundation/52-01-SUMMARY.md`
</output>
