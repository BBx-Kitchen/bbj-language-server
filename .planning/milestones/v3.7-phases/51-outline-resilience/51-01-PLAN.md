---
phase: 51-outline-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bbj-vscode/src/language/bbj-document-symbol-provider.ts
  - bbj-vscode/src/language/bbj-module.ts
  - bbj-vscode/test/document-symbol.test.ts
autonomous: true
requirements:
  - OUTL-01
  - OUTL-02

must_haves:
  truths:
    - "Structure View does not go blank or throw errors when a file has syntax errors"
    - "Methods and classes defined before the syntax error point are visible in Structure View"
    - "Methods and classes defined after the syntax error point are visible in Structure View"
    - "Partial methods whose name/signature was parsed but body is broken appear in the outline"
    - "Nodes with missing names show with fallback label (parse error)"
  artifacts:
    - path: "bbj-vscode/src/language/bbj-document-symbol-provider.ts"
      provides: "Error-safe document symbol provider extending DefaultDocumentSymbolProvider"
      contains: "class BBjDocumentSymbolProvider"
    - path: "bbj-vscode/src/language/bbj-module.ts"
      provides: "Module registration of custom DocumentSymbolProvider"
      contains: "DocumentSymbolProvider"
    - path: "bbj-vscode/test/document-symbol.test.ts"
      provides: "Error-recovery tests for document symbols on partial ASTs"
      contains: "parse error"
  key_links:
    - from: "bbj-vscode/src/language/bbj-module.ts"
      to: "bbj-vscode/src/language/bbj-document-symbol-provider.ts"
      via: "BBjModule.lsp.DocumentSymbolProvider factory"
      pattern: "DocumentSymbolProvider.*BBjDocumentSymbolProvider"
    - from: "bbj-vscode/src/language/bbj-document-symbol-provider.ts"
      to: "bbj-vscode/node_modules/langium/lib/lsp/document-symbol-provider.js"
      via: "extends DefaultDocumentSymbolProvider"
      pattern: "extends DefaultDocumentSymbolProvider"
---

<objective>
Make Structure View (document symbols) survive syntax errors in both VS Code and IntelliJ. Create a custom BBjDocumentSymbolProvider that handles partial ASTs gracefully — methods, classes, labels, fields, and variables before and after parse error points remain visible in the outline. Nodes with unrecoverable names show with a `(parse error)` fallback label.

Purpose: Users editing BBj files with syntax errors currently get a blank or errored Structure View. This phase makes the outline resilient so developers maintain navigation context even while actively editing broken code.

Output: `bbj-document-symbol-provider.ts` with error-safe traversal, module registration, and tests covering partial-AST scenarios.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-outline-resilience/51-RESEARCH.md
@bbj-vscode/src/language/bbj-module.ts
@bbj-vscode/src/language/bbj-node-kind.ts
@bbj-vscode/test/document-symbol.test.ts
@bbj-vscode/node_modules/langium/lib/lsp/document-symbol-provider.js
@bbj-vscode/node_modules/langium/lib/lsp/document-symbol-provider.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BBjDocumentSymbolProvider with error-safe AST traversal</name>
  <files>bbj-vscode/src/language/bbj-document-symbol-provider.ts, bbj-vscode/src/language/bbj-module.ts</files>
  <action>
Create `bbj-vscode/src/language/bbj-document-symbol-provider.ts` with class `BBjDocumentSymbolProvider extends DefaultDocumentSymbolProvider`.

**Implementation details:**

1. **Override `getSymbols()`**: Wrap `this.getSymbol(document, document.parseResult.value)` in a top-level try/catch. On any uncaught exception, return `[]` instead of propagating the error to the LSP client (which would make the outline go blank).

2. **Guard synthetic documents early**: At the top of `getSymbols()`, check if the document URI is synthetic (`bbjlib://` scheme or `JavaSyntheticDocUri` from `java-interop.js`). If synthetic, delegate to `super.getSymbols()` (no error recovery needed for generated documents). Import `JavaSyntheticDocUri` from `./java-interop.js`.

3. **Override `getSymbol()`**: Wrap the entire body in a try/catch that returns `[]` on failure (per-node guard — a single bad node cannot kill the entire traversal). Inside the try block:
   - Call `this.nameProvider.getNameNode(astNode)` to get the name CST node.
   - If `nameNode && astNode.$cstNode`: compute the name via `this.nameProvider.getName(astNode)`. If the computed name is empty or undefined (error recovery case), use `'(parse error)'` as the display name. Call `this.createSymbol(document, astNode, astNode.$cstNode, nameNode, displayName)` and return the result in an array.
   - If `nameNode` is falsy but `astNode.$cstNode` exists and `(astNode as any).name` is a non-empty string: the name provider couldn't find the CST node for the name but the AST has a name property. Create a symbol using `astNode.$cstNode` as both the cstNode and nameNode parameters, passing the `.name` string as `computedName`.
   - If `astNode.$cstNode` exists but neither nameNode nor `.name` is available: this is a broken named node. Create a symbol with name `'(parse error)'` using `astNode.$cstNode` for both range and selectionRange. Use `this.nodeKindProvider.getSymbolKind(astNode)` for the kind. Manually construct the `DocumentSymbol` object (do not call `createSymbol` because `nameNode` would be invalid). Include `children: this.getChildSymbols(document, astNode)` so child symbols are still recovered.
   - Otherwise (no `$cstNode` at all): fall through to `this.getChildSymbols(document, astNode) ?? []` to still collect any children that do have valid CST nodes.

4. **Override `getChildSymbols()`**: Wrap iteration in try/catch. For each child from `AstUtils.streamContents(astNode)`, wrap `this.getSymbol(document, child)` in its own try/catch. If an individual child throws, skip it and continue with the next. Return `undefined` if no children collected (preserving the `DefaultDocumentSymbolProvider` contract).

5. **Deep-walk fallback**: After the standard `getChildSymbols()` finishes, check if the document has parse errors (`document.parseResult.parserErrors.length > 0 || document.parseResult.lexerErrors.length > 0`). If so, and the current node is the root (check `!astNode.$container`), AND `document.textDocument.getText().length < 200000` (large file threshold — skip deep walk for files over ~200K chars), perform a deep-walk fallback:
   - Use `AstUtils.streamAllContents(document.parseResult.value)` to find all named AST nodes in the tree.
   - For each node found by the deep walk that has a name and `$cstNode`, check if it already appears in the result set (compare by `$cstNode.range` start offset to avoid duplicates).
   - Add any missing symbols as flat top-level entries. This catches symbols that `streamContents` missed because their parent container node was broken.
   - This deep-walk fallback only runs at the root level (not recursively) and only when there are parse errors, so the performance impact on valid files is zero.

6. **Module registration**: In `bbj-module.ts`, add `DocumentSymbolProvider: (services) => new BBjDocumentSymbolProvider(services)` to the `lsp` section of `BBjModule`. Add the import for `BBjDocumentSymbolProvider` from `./bbj-document-symbol-provider.js`.

**Imports needed in bbj-document-symbol-provider.ts:**
- `AstNode, AstUtils, DefaultDocumentSymbolProvider, LangiumDocument` from `langium`
- `LangiumServices` from `langium/lsp`
- `DocumentSymbol, DocumentSymbolParams, SymbolKind` from `vscode-languageserver`
- `JavaSyntheticDocUri` from `./java-interop.js`

**What to avoid:**
- Do NOT add any debounce logic — Langium already handles this (confirmed in research).
- Do NOT use `SymbolTag.Deprecated` to mark partial symbols — per Claude's discretion, keep the same `SymbolKind` as normal. The `(parse error)` name suffix is sufficient visual differentiation.
- Do NOT modify the grammar or parser — this is symbol provider level only.
- Do NOT throw from `getSymbols()` under any circumstances — the entire method must be exception-safe.
- LSP `DocumentSymbol.name` must never be an empty string — always fall back to `'(parse error)'`.
  </action>
  <verify>
Run `npm run build` from `bbj-vscode/` to confirm TypeScript compiles cleanly with the new file and module registration. Verify no import errors or type mismatches.
  </verify>
  <done>
`BBjDocumentSymbolProvider` exists with per-node try/catch, `(parse error)` fallback label, deep-walk fallback for parse errors, synthetic document guard, and is registered in `BBjModule.lsp`. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add error-recovery tests for document symbols on partial ASTs</name>
  <files>bbj-vscode/test/document-symbol.test.ts</files>
  <action>
Add error-recovery test cases to the existing `document-symbol.test.ts` file. The existing test `'DocumentSymbol definitions test'` validates symbols on valid files. Add new tests inside the same `describe` block that validate symbol recovery on files with syntax errors.

**Test cases to add:**

1. **`'symbols survive broken method body'`**: Parse a class with a broken method (invalid syntax in body) followed by a valid method:
   ```
   class public TestClass
     method public void broken(
     methodend
     method public void good()
     methodend
   classend
   ```
   Assert: `TestClass` appears as a symbol. `good` appears as a child of `TestClass`. `broken` may or may not appear (depends on parser recovery) — the key assertion is that the outline does NOT throw and `TestClass` + `good` are present. If `broken` is recovered with a name, it should also be present.

2. **`'symbols before and after syntax error'`**: Parse a program with valid declarations, a syntax error mid-file, then more valid declarations:
   ```
   declare BBjString before!
   @@@ SYNTAX ERROR @@@
   declare BBjString after!
   some_label:
     release
   ```
   Assert: `before!` appears as a symbol. `some_label` appears as a symbol. The result is NOT empty. No exception thrown.

3. **`'class with missing name shows (parse error)'`**: Parse a class with a missing name:
   ```
   class public
     method public void validMethod()
     methodend
   classend
   ```
   Assert: A symbol exists (either with name `(parse error)` or the class is skipped and `validMethod` appears as a top-level symbol via deep-walk). The key assertion is no exception and the outline is not empty if any symbols were recoverable.

4. **`'empty/completely broken file returns empty array'`**: Parse a completely unparseable string like `@@@ %%% ###`.
   Assert: The result is an empty array `[]`, not an exception. `symbols.length` should be `0` or a small number of recovered tokens.

5. **`'existing valid file behavior preserved'`**: This is already covered by the existing test, but add a brief assertion that the existing test's symbols still match after the provider change. (May skip if the existing test is sufficient.)

**Test pattern**: Use the existing `validate()` and `documentSymbolProvider` from the file's top-level setup. Parse content, then call `documentSymbolProvider.getSymbols(document, { textDocument: { uri: document.uri.toString() } })`. Assert on the result.

**Key assertion helper**: For error-recovery tests, do NOT call `expectNoErrors()` (the files intentionally have errors). Instead directly check `symbols` array length and names.

**What to avoid:**
- Do NOT assert exact symbol counts for broken files — parser recovery is nondeterministic. Assert minimum expected symbols (e.g., `expect(symbols.length).toBeGreaterThanOrEqual(1)`).
- Do NOT modify the existing passing test.
  </action>
  <verify>
Run `npx vitest run test/document-symbol.test.ts` from `bbj-vscode/` to confirm all tests pass, including both the existing test and the new error-recovery tests.
  </verify>
  <done>
At least 4 new test cases pass covering: broken method body, symbols before/after error, missing class name, and completely broken file. The existing `'DocumentSymbol definitions test'` still passes unchanged. All tests confirm no exceptions thrown during symbol computation on partial ASTs.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes cleanly in `bbj-vscode/` (TypeScript compilation, no errors)
2. `npx vitest run test/document-symbol.test.ts` passes all tests (existing + new)
3. `npx vitest run` passes the full test suite (no regressions introduced)
4. Manual verification (optional): open a BBj file with a syntax error in VS Code, confirm Structure View shows symbols before and after the error point
</verification>

<success_criteria>
- BBjDocumentSymbolProvider registered and active in the language server
- Files with syntax errors produce non-empty symbol results (not blank outline)
- Symbols before the error point visible
- Symbols after the error point visible (via standard walk or deep-walk fallback)
- No TypeError or unhandled exception during symbol computation on any partial AST
- Nodes with missing names display as `(parse error)`
- Existing valid-file symbol behavior is unchanged
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/51-outline-resilience/51-01-SUMMARY.md`
</output>
